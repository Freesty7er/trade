////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с типами, объектами метаданных и их строковыми представлениями.

// Получает дерево метаданных конфигурации с заданным отбором по объектам метаданных.
//
// Параметры:
// Отбор – Структура – содержит значения элементов отбора.
//						Если параметр задан, то будет получено дерево метаданных в соответствии с заданным отбором. 
//						Ключ (Строка) – имя свойства элемента метаданных;
//						Значение (Массив) – множество значений для отбора.
//
// Пример инициализации переменной "Отбор":
//
// Массив = Новый Массив;
// Массив.Добавить("Константа.ИспользоватьСинхронизациюДанных");
// Массив.Добавить("Справочник.Валюты");
// Массив.Добавить("Справочник.Организации");
// Отбор = Новый Структура;
// Отбор.Вставить("ПолноеИмя", Массив);
// 
//  Возвращаемое значение:
//  Тип: ДеревоЗначений - дерево описания метаданных конфигурации
//
Функция ПолучитьДеревоМетаданныхКонфигурации(Отбор = Неопределено) Экспорт
	
	ИспользоватьОтбор = (Отбор <> Неопределено);
	
	КоллекцииОбъектовМетаданных = Новый ТаблицаЗначений;
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Имя");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Синоним");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("Картинка");
	КоллекцииОбъектовМетаданных.Колонки.Добавить("КартинкаОбъекта");
	
	НоваяСтрокаКоллекцииОбъектовМетаданных("Константы",               "Константы",                 БиблиотекаКартинок.Константа,              БиблиотекаКартинок.Константа,                    КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Справочники",             "Справочники",               БиблиотекаКартинок.Справочник,             БиблиотекаКартинок.Справочник,                   КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Документы",               "Документы",                 БиблиотекаКартинок.Документ,               БиблиотекаКартинок.ДокументОбъект,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовХарактеристик", "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыСчетов",             "Планы счетов",              БиблиотекаКартинок.ПланСчетов,             БиблиотекаКартинок.ПланСчетовОбъект,             КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("ПланыВидовРасчета",       "Планы видов характеристик", БиблиотекаКартинок.ПланВидовХарактеристик, БиблиотекаКартинок.ПланВидовХарактеристикОбъект, КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыСведений",        "Регистры сведений",         БиблиотекаКартинок.РегистрСведений,        БиблиотекаКартинок.РегистрСведений,              КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыНакопления",      "Регистры накопления",       БиблиотекаКартинок.РегистрНакопления,      БиблиотекаКартинок.РегистрНакопления,            КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыБухгалтерии",     "Регистры бухгалтерии",      БиблиотекаКартинок.РегистрБухгалтерии,     БиблиотекаКартинок.РегистрБухгалтерии,           КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("РегистрыРасчета",         "Регистры расчета",          БиблиотекаКартинок.РегистрРасчета,         БиблиотекаКартинок.РегистрРасчета,               КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("БизнесПроцессы",          "Бизнес-процессы",           БиблиотекаКартинок.БизнесПроцесс,          БиблиотекаКартинок.БизнесПроцессОбъект,          КоллекцииОбъектовМетаданных);
	НоваяСтрокаКоллекцииОбъектовМетаданных("Задачи",                  "Задачи",                    БиблиотекаКартинок.Задача,                 БиблиотекаКартинок.ЗадачаОбъект,                 КоллекцииОбъектовМетаданных);
	
	// возвращаемое значение функции
	ДеревоМетаданных = Новый ДеревоЗначений;
	ДеревоМетаданных.Колонки.Добавить("Имя");
	ДеревоМетаданных.Колонки.Добавить("ПолноеИмя");
	ДеревоМетаданных.Колонки.Добавить("Синоним");
	ДеревоМетаданных.Колонки.Добавить("Картинка");
	
	Для Каждого СтрокаКоллекции Из КоллекцииОбъектовМетаданных Цикл
		
		СтрокаДерева = ДеревоМетаданных.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаДерева, СтрокаКоллекции);
		Для Каждого ОбъектМетаданных Из Метаданные[СтрокаКоллекции.Имя] Цикл
			
			Если ИспользоватьОтбор Тогда
				
				ОбъектПрошелФильтр = Истина;
				Для Каждого ЭлементОтбора Из Отбор Цикл
					
					Значение = ?(ВРег(ЭлементОтбора.Ключ) = ВРег("ПолноеИмя"), ОбъектМетаданных.ПолноеИмя(), ОбъектМетаданных[ЭлементОтбора.Ключ]);
					Если ЭлементОтбора.Значение.Найти(Значение) = Неопределено Тогда
						ОбъектПрошелФильтр = Ложь;
						Прервать;
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не ОбъектПрошелФильтр Тогда
					Продолжить;
				КонецЕсли;
				
			КонецЕсли;
			
			СтрокаДереваОМ = СтрокаДерева.Строки.Добавить();
			СтрокаДереваОМ.Имя       = ОбъектМетаданных.Имя;
			СтрокаДереваОМ.ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			СтрокаДереваОМ.Синоним   = ОбъектМетаданных.Синоним;
			СтрокаДереваОМ.Картинка  = СтрокаКоллекции.КартинкаОбъекта;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// удаляем строки без подчиненных элементов
	Если ИспользоватьОтбор Тогда
		
		// используем обратный порядок обхода дерева значений
		КолвоЭлементовКоллекции = ДеревоМетаданных.Строки.Количество();
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
			
			ТекущийИндекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
			СтрокаДерева = ДеревоМетаданных.Строки[ТекущийИндекс];
			Если СтрокаДерева.Строки.Количество() = 0 Тогда
				ДеревоМетаданных.Строки.Удалить(ТекущийИндекс);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ДеревоМетаданных;
	
КонецФункции

// Получить представление физического места размещения информационной базы для отображения администратору.
//
// Возвращаемое значение:
//   Строка      - представление информационной базы
//
// Пример возвращаемого результата:
// - для ИБ в файлом режиме: \\FileServer\1c_ib\
// - для ИБ в серверном режиме: ServerName:1111 / information_base_name
//
Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
	
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
	
	Если ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
		Возврат Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
	КонецЕсли;
	
	// Прибавить к имени сервера имя пути информационной базы
	ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "SRVR=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
	НачальнаяПозицияКопирования = 6 + 1;
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	
	СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
	
	// Позиция имени сервера
	ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "REF=");
	Если ПозицияПоиска <> 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НачальнаяПозицияКопирования = 6;
	ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	ПутьКБД = ИмяСервера + "/ " + ИмяИБНаСервере;
	Возврат ПутьКБД;
	
КонецФункции

// Возвращает строку реквизитов объекта метаданных с заданным типом
//
// Параметры:
//  Ссылка – ЛюбаяСсылка – ссылка на элемент базы данных, для которого требуется получить результат функции
//  Тип    – Тип – тип значения реквизита
// 
//  Возвращаемое значение:
// Тип: Строка – строка реквизитов объекта метаданных конфигурации, разделенные символом ","
//
Функция ИменаРеквизитовПоТипу(Ссылка, Тип) Экспорт
	
	Результат = "";
	МетаданныеОбъекта = Ссылка.Метаданные();
	
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		Если Реквизит.Тип.СодержитТип(Тип) Тогда
			Результат = Результат + ?(ПустаяСтрока(Результат), "", ", ") + Реквизит.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции


// Возвращает менеджер объекта по полному имени объекта метаданных
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  ПолноеИмя    - Строка, полное имя объекта метаданных,
//                 например, "Справочник.Организации"
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	КлассОМ = ЧастиИмени[0];
	ИмяОМ   = ЧастиИмени[1];
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Возврат ПланыОбмена[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Возврат Справочники[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Возврат Документы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Возврат ЖурналыДокументов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Возврат Перечисления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Возврат Отчеты[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Возврат Обработки[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Возврат ПланыВидовХарактеристик[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Возврат ПланыСчетов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Возврат ПланЫВидовРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Возврат РегистрыСведений[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Возврат РегистрыНакопления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Возврат РегистрыБухгалтерии[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Возврат РегистрыРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Возврат БизнесПроцессы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Возврат Задачи[ИмяОМ];
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru='Неизвестный тип объекта метаданных (%1)'"), КлассОМ);
	КонецЕсли;
	
КонецФункции

// Возвращает менеджер объекта по ссылке на объект
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Справочники[ИмяОбъекта];
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Документы[ИмяОбъекта];
		
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
		
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
		
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
		
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Задачи[ИмяОбъекта];
		
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Перечисления[ИмяОбъекта];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки
//
// Параметры:
//  ЛюбаяСсылка - значение любой ссылки информационной базы данных
// 
// Возвращаемое значение:
//  Истина - ссылка физически существует;
//  Ложь   - ссылка физически не существует
//
Функция СсылкаСуществует(ЛюбаяСсылка) Экспорт
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Ссылка КАК Ссылка
	|ИЗ
	|	[ИмяТаблицы]
	|ГДЕ
	|	Ссылка = &Ссылка
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(ЛюбаяСсылка));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Функция ВидОбъектаПоСсылке возвращает имя вида объектов метаданных
// по ссылке на объект.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
// 
Функция ВидОбъектаПоСсылке(Ссылка) Экспорт
	
	Возврат ВидОбъектаПоТипу(ТипЗнч(Ссылка));
	
КонецФункции 

// Функция возвращает имя вида объектов метаданных по типу объекта.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Тип       - Тип прикладного объекта, определенный в конфигурации
//
// Возвращаемое значение:
//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
// 
Функция ВидОбъектаПоТипу(Тип) Экспорт
	
	Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Справочник";
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Документ";
		
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "БизнесПроцесс";
		
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовХарактеристик";
		
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланСчетов";
		
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовРасчета";
		
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Задача";
		
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланОбмена";
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Перечисление";
		
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru='Неверный тип значения параметра (%1)'"), Строка(Тип));
		
	КонецЕсли;
	
КонецФункции 

// Возвращает полное имя объекта метаданных по переданному значению ссылки
// Например,
//  "Справочник.Номенклатура";
//  "Документ.ПриходнаяНакладная"
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - значение ссылки, для которого необходимо получить имя таблицы ИБ
// 
// Возвращаемое значение:
//  Строка - полное имя объекта метаданных для указанного значения ссылки
//
Функция ИмяТаблицыПоСсылке(Ссылка) Экспорт
	
	Возврат Ссылка.Метаданные().ПолноеИмя();
	
КонецФункции

// Проверить, что значение имеет ссылочный тип данных.
//
// Параметры:
//  Значение       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  Булево       - Истина, если тип значения ссылочный.
//
Функция ЗначениеСсылочногоТипа(Значение) Экспорт
	
	Если Значение = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Задачи.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверка того, что тип имеет ссылочный тип данных
//
Функция ЭтоСсылка(Тип) Экспорт
	
	Возврат Справочники.ТипВсеСсылки().СодержитТип(Тип)
	ИЛИ Документы.ТипВсеСсылки().СодержитТип(Тип)
	ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(Тип)
	ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
	ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
	ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
	ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
	ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
	ИЛИ Задачи.ТипВсеСсылки().СодержитТип(Тип)
	ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип);
	
КонецФункции


// Возвращает строковое представление типа. 
// Для ссылочных типов возвращает в формате "СправочникСсылка.ИмяОбъекта" или "ДокументСсылка.ИмяОбъекта"
// Для остальных типов приводит тип к строке, например "Число".
//
Функция СтроковоеПредставлениеТипа(Тип) Экспорт
	
	Представление = "";
	
	Если ЭтоСсылка(Тип) Тогда
		
		ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
		ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".")[1];
		
		Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "СправочникСсылка";
			
		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ДокументСсылка";
			
		ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "БизнесПроцессСсылка";
			
		ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовХарактеристикСсылка";
			
		ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланСчетовСсылка";
			
		ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовРасчетаСсылка";
			
		ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ЗадачаСсылка";
			
		ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланОбменаСсылка";
			
		ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПеречислениеСсылка";
			
		КонецЕсли;
		
		Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);
		
	Иначе
		
		Результат = Строка(Тип);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверить, что описание типа состоит из единственного типа значения и 
// совпадает с нужным типом.
//
// Возвращаемое значение:
//   Булево      - Совпадает или нет
//
Функция ОписаниеТипаСостоитИзТипа(ОписаниеТипа, ТипЗначения) Экспорт
	
	Если ОписаниеТипа.Типы().Количество() = 1
		И ОписаниеТипа.Типы().Получить(0) = ТипЗначения Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет наличие табличной части у справочника
//
//Параметры
//  ИмяСправочника    - Строка - имя справочника, для которого осуществляется проверка.
//  ИмяТабличнойЧасти - Строка - имя табличной части, наличие которой проверяется.
//
//Возвращаемое значение:
//  Булево   - Истина, если табличная часть есть, ложь в обратном случае
//
//Пример:
//  Если НЕ ОбщегоНазначения.НаличиеТабличнойЧастиУСправочника(ИмяСправочника,"КонтактнаяИнформация") Тогда
//  	Возврат;
//  КонецЕсли;
//
Функция НаличиеТабличнойЧастиУСправочника(ИмяСправочника, ИмяТабличнойЧасти) Экспорт
	
	Возврат (Метаданные.Справочники[ИмяСправочника].ТабличныеЧасти.Найти(ИмяТабличнойЧасти) <> Неопределено);
	
КонецФункции 


// Возвращает признак того, что реквизит входит в подмножество стандартных реквизитов
//
// Параметры:
//  СтандартныеРеквизиты – ОписанияСтандартныхРеквизитов - тип и значение описывает коллекцию настроек различных стандартных реквизитов;
//  ИмяРеквизита – Строка – реквизит который необходимо проверить на принадлежность множеству стандартных реквизитов;
// 
//  Возвращаемое значение:
// Тип: Булево. Истина -  реквизит входит в подмножество стандартных реквизитов; Ложь – нет.
//
Функция ЭтоСтандартныйРеквизит(СтандартныеРеквизиты, ИмяРеквизита) Экспорт
	
	Для Каждого Реквизит ИЗ СтандартныеРеквизиты Цикл
		Если Реквизит.Имя = ИмяРеквизита Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
	
КонецФункции

// Получает таблицу значений с описанием требуемых свойств всех реквизитов объекта метаданного
// Получает значения свойств стандартных реквизитов и пользовательских реквизитов (созданных в режиме конфигуратора)
//
// Параметры:
//  ОбъектМетаданных  - Объект метаданных конфигурации, для которого необходимо получить значение свойств реквизитов.
//                      Например: Метаданные.Документ.РеализацияТоваровИУслуг
//  Свойства - Строка - свойства реквизитов, перечисленных через запятую, значение которых необходимо получить.
//                      Например: "Имя, Тип, Синоним, Подсказка"
//
// Возвращаемое значение:
//  ТаблицаЗначений - таблица значений с описанием требуемых свойств всех реквизитов объекта метаданного
//
Функция ПолучитьТаблицуОписанияСвойствОбъекта(ОбъектМетаданных, Свойства) Экспорт
	
	МассивСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Свойства);
	
	// возвращаемое значение функции
	ТаблицаОписанияСвойствОбъекта = Новый ТаблицаЗначений;
	
	// добавляем в таблицу поля согласно именам переданных свойств
	Для Каждого ИмяСвойства ИЗ МассивСвойств Цикл
		ТаблицаОписанияСвойствОбъекта.Колонки.Добавить(СокрЛП(ИмяСвойства));
	КонецЦикла;
	
	// заполняем строку таблицы свойствами реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.Реквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	// заполняем строку таблицы свойствами стандартных реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.СтандартныеРеквизиты Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
	КонецЦикла;
	
	Возврат ТаблицаОписанияСвойствОбъекта;
	
КонецФункции

// Возвращает состояние использования элемента состава общего реквизита
//
// Параметры:
//  ЭлементСостава - ОбъектМетаданных - элемент состава общего реквизита использование
//   которого требуется проверить
//  МетаданныеОбщегоРеквизита - ОбъектМетаданных - метаданные общего реквизита,  
//   которому принадлежит ЭлементСостава
//
// Возвращаемое значение:
//  Булево - Истина, если элемент состава используется, иначе Ложь
//
Функция ЭлементСоставаОбщегоРеквизитаИспользуется(Знач ЭлементСостава, Знач МетаданныеОбщегоРеквизита) Экспорт
	
	Если ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Использовать Тогда
		Возврат Истина;
	ИначеЕсли ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.НеИспользовать Тогда
		Возврат Ложь;
	Иначе
		Возврат МетаданныеОбщегоРеквизита.АвтоИспользование = Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
	КонецЕсли;
	
КонецФункции

// Возвращает признак того, что объект метаданных используется в общих реквизитах-разделителях.
//
// Параметры:
// ОбъектМетаданных - Строка; ОбъектМетаданных - Если объект метаданных задан строкой, происходит обращение к модулю повторного использования.
//
// Возвращаемое значение:
// Булево - Истина, если объект метаданных используется хотя бы в одном общем разделителе.
//
Функция ЭтоРазделенныйОбъектМетаданных(Знач ОбъектМетаданных) Экспорт
	
	Если ТипЗнч(ОбъектМетаданных) = Тип("Строка") Тогда
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных;
	Иначе
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	КонецЕсли;
	
	РазделенныеОбъектыМетаданных = ОбщегоНазначенияПовтИсп.РазделенныеОбъектыМетаданных();
	Возврат РазделенныеОбъектыМетаданных.Получить(ПолноеИмяОбъектаМетаданных) <> Неопределено;
	
КонецФункции



////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции 

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИменаРеквизитов - Строка или Структура - если Строка, то имена реквизитов, 
//               перечисленные через запятую, в формате требований к свойствам структуры.
//               Например, "Код, Наименование, Родитель".
//               Если Структура, то в качестве ключа передается псевдоним поля для
//               возвращаемой структуры с результатом, а в качестве значения (опционально) 
//               - фактическое имя поля в таблице. 
//               Если значение не определено, то в имя поля берется из ключа.
// 
// Возвращаемое значение:
//  Структура    - содержит список свойств, как список имен в строке
//                 ИменаРеквизитов, со значениям реквизитов, прочитанных
//                 из информационной базы.
// 
Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт
	
	Если ТипЗнч(ИменаРеквизитов) = Тип("Структура") Тогда
		СтруктураРеквизитов = ИменаРеквизитов;
	ИначеЕсли ТипЗнч(ИменаРеквизитов) = Тип("Строка") Тогда
		СтруктураРеквизитов = Новый Структура(ИменаРеквизитов);;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Неверный тип второго параметра ИменаИлиСтруктураРеквизитов: %1'"), 
		Строка(ТипЗнч(ИменаРеквизитов)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение), СокрЛП(КлючИЗначение.Значение), СокрЛП(КлючИЗначение.Ключ));
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
	КонецЦикла;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка = &Ссылка
	|");
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
КонецФункции

// Функция ПолучитьЗначениеРеквизита возвращает значение
// реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ПолучитьЗначенияРеквизитов(Ссылка, ИмяРеквизита);
	Возврат Результат[ИмяРеквизита];
	
КонецФункции 



// Функция возвращает ссылку на текущего пользователя базы данных,
// установленного по учетной записи пользователя конфигурации.
//
// Возвращаемое значение:
//  СправочникСсылка.Пользователи
//
Функция ТекущийПользователь() Экспорт
	
	Возврат Пользователи.ТекущийПользователь();
	
КонецФункции 

// Процедура выводит пользователю сообщение: в журнал регистрации, в панель комментариев, в окно сообщений (в зависимости от настроек).
//
// Параметры:
//	ТекстСообщения - Строка - Текст сообщения
//	Статус - ПеречислениеСсылка.ВидыСообщений - Вид сообщения
//		   - СтатусСообщения - Статус сообщения (используется для совместимости со старыми вызовами процедуры Сообщить)
//	Заголовок - Строка - Текст заголовка
//	РасшифровкаСообщения - Массив - Массив с данными расшифровки
//						 - Ссылка - Ссылка на объект
//	СтрокаРодитель - Родительская строка дерева значений для вывода сообщения
//	РаскрытьСообщение - Булево - Признак раскрытия строки дерева сообщений
//
// Возвращаемое значение:
//	СтрокаДереваЗначенний - Строка дерева значений, в которую записано текущее сообщение
//Если вывод сообщений в панель комментариев не предусмотрен, возвращается Неопределено
Функция Сообщение(Знач ТекстСообщения, Статус = Неопределено, Заголовок = "", РасшифровкаСообщения = Неопределено, СтрокаРодитель = Неопределено, РаскрытьСообщение = Истина, ЭтоСообщениеОбОшибке = Ложь) Экспорт
	
	Сообщить(ТекстСообщения);
	//ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок);
	//СтрокаДереваЗначений = ВыводСообщений.ВывестиСообщениеВПанельКомментариев(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, СтрокаРодитель, РаскрытьСообщение);
	
	//Если СтрокаДереваЗначений = Неопределено Тогда //Сообщение в панель комментариев не выведено, значит необходимо вывести его в окно сообщений
	//	ВыводСообщений.ВывестиСообщениеВОкноСообщений(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, ЭтоСообщениеОбОшибке);
	//КонецЕсли;
	
	//Возврат СтрокаДереваЗначений;
	Возврат Неопределено;
	
КонецФункции // Сообщение()


// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//	Заголовок - Строка - Текст заголовка
//          (выводится пользователю в режиме обычного приложения; 
//           в заголовке должен быть описан контекст выполняемых действий, например "Проведение документа №... от ...")
//	Статус - СтатусСообщения - Статус сообщения
//	РасшифровкаСообщения - Массив - Массив с данными расшифровки
//						 - Ссылка - Ссылка на объект
//
Процедура СообщитьОбОшибке(
	Знач ТекстСообщения, 
	Отказ = Ложь, 
	Заголовок = "",
	Статус = Неопределено,
	РасшифровкаСообщения = Неопределено
	) Экспорт
	
	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		//Для клиента и сервера запись в журнал регистрации попадет внутри процедуры Сообщение
		//ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок);
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#Иначе
		
		Сообщение(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, Неопределено, Истина, Истина);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Функция убирает из текста сообщения слущебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт
	
	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
		
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);
	
КонецФункции // ()

// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
	
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции

Функция ПолучитьМесячныйПрефиксНалоговыхДокументов(Дата) Экспорт
	
	НомерМесяца = Месяц(Дата);
	Индекс = НомерМесяца*3 - 2;
	
	Возврат Сред("Ян|Фв|Мр|Ап|Ма|Ин|Ил|Ав|Сн|Ок|Но|Дк", Индекс, 2);	
	
КонецФункции

Процедура ДобавитьПрефиксыНалоговогоДокумента(ДокументОбъект, Префикс) Экспорт
	
	Префикс = "";
	
	Если  НЕ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.НалоговаяНакладная")
		И НЕ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.Приложение2КНалоговойНакладной") Тогда
		Возврат;
	КонецЕсли;
	
	ПрефиксНалоговых = "";
	
	//Если УчетнаяПолитика.ВестиРаздельнуюНумерациюНалоговыхДокументов = Истина Тогда
	Если 1=2 Тогда
		
		// разделяем префиксом Налоговые от Приложений
		Если ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.НалоговаяНакладная") Тогда
			ПрефиксНалоговых = ПрефиксНалоговых + "Н";
		Иначе
			ПрефиксНалоговых = ПрефиксНалоговых + "П";
		КонецЕсли;
	Иначе
		ПрефиксНалоговых = ПрефиксНалоговых + "Н";
	КонецЕсли;
	
	// разделяем префиксом по месяцам
	ПрефиксНалоговых = ПрефиксНалоговых + ПолучитьМесячныйПрефиксНалоговыхДокументов(ДокументОбъект.Дата);
	
	ПрефиксНалоговых = Лев(ПрефиксНалоговых + "00000000", 8);
	
	Префикс = СОКРП(Префикс) + ПрефиксНалоговых; 
	
КонецПроцедуры

Процедура ПриУстановкеНовогоНомераДокументаПриУстановкеНовогоНомера(Источник, СтандартнаяОбработка, Префикс) Экспорт
	
	//ДобавитьПрефиксУзла(Префикс);	
	
	ДобавитьПрефиксыНалоговогоДокумента(Источник, Префикс);
	
КонецПроцедуры

// АвтоСозданиеНалоговойНакладной()
// 	- автоматически создает/обновляет налоговую накладную
Процедура АвтоСозданиеНалоговойНакладной(ДокументОбъект)
	
	Если ДокументОбъект.Контрагент.ВыписыватьИтоговуюНалоговуюНакладную ИЛИ 
		НЕ ДокументОбъект.Организация.ЕстьНДС Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ДополнительныеСвойства = Новый Структура;
	УправлениеНебольшойФирмойСервер.ИнициализироватьДополнительныеСвойстваДляПроведения(ДокументОбъект.Ссылка, ДополнительныеСвойства);
	
	Если НЕ ДополнительныеСвойства.УчетнаяПолитика.АвтоСозданиеНалоговыхДокументов Тогда
		Возврат;
	КонецЕсли;
	
	
	
	// поищем налоговую ... может уже есть.
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	НалоговаяНакладнаяСостав.Ссылка
	|ИЗ
	|	Документ.НалоговаяНакладная.Состав КАК НалоговаяНакладнаяСостав
	|ГДЕ
	|	НалоговаяНакладнаяСостав.РасходняНакладная = &Ссылка");
	
	Запрос.УстановитьПараметр("Ссылка", ДокументОбъект.Ссылка);
	
	ЭтоНовыйДокумент = Ложь;
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		// нету
		СвязанныйДокумент = Документы.НалоговаяНакладная.СоздатьДокумент();
		
		НоваяСтрока = СвязанныйДокумент.Состав.Добавить();
		НоваяСтрока.РасходняНакладная = ДокументОбъект.Ссылка;
		
		ЭтоНовыйДокумент = Истина;
		
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		СвязанныйДокумент = Выборка.Ссылка.ПолучитьОбъект();
	КонецЕсли;
	
	связанныйДокумент.СозданАвтоматически 	= Истина;
	связанныйДокумент.Дата 				= ДокументОбъект.ДатаОтгрузки;
	связанныйДокумент.Подразделение 	= ДокументОбъект.Подразделение;
	связанныйДокумент.Организация 		= ДокументОбъект.Организация;
	связанныйДокумент.Контрагент 		= ДокументОбъект.Контрагент;
	связанныйДокумент.Автор 			= ДокументОбъект.Автор;
	связанныйДокумент.Ответственный 	= ДокументОбъект.Ответственный;
	связанныйДокумент.ДокументОснование = ДокументОбъект.Ссылка;
	связанныйДокумент.СуммаДокумента 	= ДокументОбъект.СуммаДокумента;
	
	Если Не ЭтоНовыйДокумент Тогда
		связанныйДокумент.ДополнительныеСвойства.Вставить("ОбработкаСвязанныхДокументов", Истина);
	КонецЕсли;
	
	// обновим "Запасы"
	Запасы = СвязанныйДокумент.Запасы;
	Запасы.Очистить();
	
	Для Каждого СтрокаЗапасы Из ДокументОбъект.Запасы Цикл
		Если СтрокаЗапасы.Количество = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока = Запасы.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаЗапасы);
		
	КонецЦикла;
	
	Если ЭтоНовыйДокумент Тогда
		СвязанныйДокумент.УстановитьНовыйНомер();
	КонецЕсли;
	
	СвязанныйДокумент.Записать(РежимЗаписиДокумента.Запись);
	
	
КонецПроцедуры

Процедура АвтоСозданиеПриложения2КНалоговойНакладной(ДокументОбъект)
	
	Если ДокументОбъект.Контрагент.ВыписыватьИтоговуюНалоговуюНакладную ИЛИ 
		НЕ ДокументОбъект.Организация.ЕстьНДС Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ДополнительныеСвойства = Новый Структура;
	УправлениеНебольшойФирмойСервер.ИнициализироватьДополнительныеСвойстваДляПроведения(ДокументОбъект.Ссылка, ДополнительныеСвойства);
	
	Если НЕ ДополнительныеСвойства.УчетнаяПолитика.АвтоСозданиеНалоговыхДокументов Тогда
		Возврат;
	КонецЕсли;
	
	// сразу поищем налоговую к возврату
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	НалоговаяНакладнаяСостав.Ссылка
	|ИЗ
	|	Документ.НалоговаяНакладная.Состав КАК НалоговаяНакладнаяСостав
	|ГДЕ
	|	НалоговаяНакладнаяСостав.РасходняНакладная = &Ссылка");
	
	Запрос.УстановитьПараметр("Ссылка", ДокументОбъект.ДокОсн);
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		
		НалоговаяНакладная = Документы.НалоговаяНакладная.ПустаяСсылка();
		
	Иначе
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		НалоговаяНакладная = Выборка.Ссылка;
		
	КонецЕсли;
	
	// поищем Приложение 2 ... может уже есть.
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Приложение2КНалоговойНакладнойСостав.Ссылка
	|ИЗ
	|	Документ.Приложение2КНалоговойНакладной.Состав КАК Приложение2КНалоговойНакладнойСостав
	|ГДЕ
	|	Приложение2КНалоговойНакладнойСостав.ВозвратнаяНакладная = &Ссылка");
	
	Запрос.УстановитьПараметр("Ссылка", ДокументОбъект.Ссылка);
	
	ЭтоНовыйДокумент = Ложь;
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		// нету
		СвязанныйДокумент = Документы.Приложение2КНалоговойНакладной.СоздатьДокумент();
		
		
		НоваяСтрока = СвязанныйДокумент.Состав.Добавить();
		НоваяСтрока.ВозвратнаяНакладная = ДокументОбъект.Ссылка;
		
		ЭтоНовыйДокумент = Истина;
		
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		СвязанныйДокумент = Выборка.Ссылка.ПолучитьОбъект();
	КонецЕсли;
	
	связанныйДокумент.СозданАвтоматически 	= Истина;
	связанныйДокумент.Дата 				= ДокументОбъект.Дата;
	связанныйДокумент.Подразделение 	= ДокументОбъект.Подразделение;
	связанныйДокумент.Организация 		= ДокументОбъект.Организация;
	связанныйДокумент.Контрагент 		= ДокументОбъект.Контрагент;
	связанныйДокумент.Автор 			= ДокументОбъект.Автор;
	связанныйДокумент.Ответственный 	= ДокументОбъект.Ответственный;
	связанныйДокумент.ДокументОснование = ДокументОбъект.Ссылка;
	связанныйДокумент.СуммаДокумента 	= ДокументОбъект.СуммаДокумента;
	связанныйДокумент.НалоговяНакладная = НалоговаяНакладная;
	
	Если Не этоНовыйДокумент Тогда
		связанныйДокумент.ДополнительныеСвойства.Вставить("ОбработкаСвязанныхДокументов", Истина);
	КонецЕсли;
	
	// обновим "Запасы"
	Запасы = СвязанныйДокумент.Запасы;
	Запасы.Очистить();
	
	Для Каждого СтрокаЗапасы Из ДокументОбъект.Запасы Цикл
		НоваяСтрока = Запасы.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаЗапасы);
	КонецЦикла;
	
	Если ЭтоНовыйДокумент Тогда
		СвязанныйДокумент.УстановитьНовыйНомер();
	КонецЕсли;
	
	СвязанныйДокумент.Записать(РежимЗаписиДокумента.Запись);
	
	
КонецПроцедуры	// АвтоСозданиеПриложения2КНалоговойНакладной()

Процедура АвтоСозданиеВозвратаОтПокупателя(ДокументОбъект)
	
	ДополнительныеСвойства = Новый Структура;
	
	Попытка
		УправлениеНебольшойФирмойСервер.ИнициализироватьДополнительныеСвойстваДляПроведения(ДокументОбъект.Ссылка, ДополнительныеСвойства);
	Исключение
		Возврат;
	КонецПопытки;
	
	Если НЕ ДополнительныеСвойства.УчетнаяПолитика.АвтоСозданиеВозвратаПокупателяПриВозвратепоставщику Тогда
		Возврат;
	КонецЕсли;
	
	
	
	// поищем возврат от покупателя ... может уже есть.
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ВозвратОтПокупателя.Ссылка
	|ИЗ
	|	Документ.ВозвратОтПокупателя КАК ВозвратОтПокупателя
	|ГДЕ
	|	ВозвратОтПокупателя.ДокументОснование = &Ссылка");
	
	Запрос.УстановитьПараметр("Ссылка", ДокументОбъект.Ссылка);
	
	ЭтоНовыйДокумент = Ложь;
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		// нету
		СвязанныйДокумент = Документы.ВозвратОтПокупателя.СоздатьДокумент();
		
		ЭтоНовыйДокумент = Истина;
		
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		СвязанныйДокумент = Выборка.Ссылка.ПолучитьОбъект();
	КонецЕсли;
	
	СвязанныйДокумент.СозданАвтоматически 	= Истина;
	СвязанныйДокумент.ДокументОснование = ДокументОбъект.Ссылка;
	СвязанныйДокумент.ПометкаУдаления	= ДокументОбъект.ПометкаУдаления;
	
	связанныйДокумент.Дата 				= ДокументОбъект.Дата;
	связанныйДокумент.Подразделение 	= Справочники.СтруктурныеЕдиницы.НайтиПоКоду("000000021");
	связанныйДокумент.Менеджер 			= Справочники.Менеджеры.БезМенеджера;
	связанныйДокумент.Организация 		= ДокументОбъект.Организация;
	связанныйДокумент.Контрагент 		= ДополнительныеСвойства.УчетнаяПолитика.Контрагент;
	связанныйДокумент.ТипЦен 		    = ДополнительныеСвойства.УчетнаяПолитика.Контрагент.ТипЦен;
	связанныйДокумент.Автор 			= ДокументОбъект.Автор;
	связанныйДокумент.Ответственный 	= ДокументОбъект.Ответственный;
	
	связанныйДокумент.СуммаДокумента 	= ДокументОбъект.СуммаДокумента;
	
	Если Не этоНовыйДокумент Тогда
		связанныйДокумент.ДополнительныеСвойства.Вставить("ОбработкаСвязанныхДокументов", Истина);
	КонецЕсли;
	
	// обновим "Запасы"
	Запасы = СвязанныйДокумент.Запасы;
	Запасы.Очистить();
	
	Для Каждого СтрокаСостава Из ДокументОбъект.Запасы Цикл
		
		Если СтрокаСостава.Номенклатура = Справочники.Номенклатура.ПустаяСсылка() Тогда
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока = Запасы.Добавить();
		НоваяСтрока.Номенклатура 		=  СтрокаСостава.Номенклатура;
		НоваяСтрока.ЕдиницаИзмерения 	= НоваяСтрока.Номенклатура.ЕдиницаИзмерения;
		
		НоваяСтрока.Количество 	= СтрокаСостава.Количество;
		
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаСостава);
		
		НоваяСтрока.СтруктурнаяЕдиница 	= СтрокаСостава.Номенклатура.Родитель.Склад;
		НоваяСтрока.СуммаБезСкидки		= СтрокаСостава.Сумма;
		
		//СтруктураПараметров = Новый Структура("Номенклатура, ТипЦен, Подразделение, ДатаСреза", НоваяСтрока.Номенклатура, ЭтотОбъект.ТипЦен, ЭтотОбъект.Подразделение, ЭтотОбъект.Дата);
		//
		//НоваяСтрока.ПроцентСкидкиНаВес 	= ЦенообразованиеСервер.ВернутьСкидкуНаВес(СтруктураПараметров);
		//НоваяСтрока.Цена 				= ЦенообразованиеСервер.ВернутьЦенуНоменклатуры(СтруктураПараметров);
		//НоваяСтрока.ПроцентСкидки 		= СоответствиеСкидок.Получить(СтрокаСостава.Номенклатура.Родитель);
		
	КонецЦикла;
	
	Если ЭтоНовыйДокумент Тогда
		СвязанныйДокумент.УстановитьНовыйНомер();
	КонецЕсли;
	
	
	//СвязанныйДокумент.Записать(РежимЗаписиДокумента.Проведение);
	
	Если ДокументОбъект.Проведен Тогда
		СвязанныйДокумент.Записать(РежимЗаписиДокумента.Проведение);
	ИначеЕсли ЭтоНовыйДокумент Тогда
		СвязанныйДокумент.Записать(РежимЗаписиДокумента.Запись);
	Иначе
		СвязанныйДокумент.Записать(РежимЗаписиДокумента.ОтменаПроведения);
	КонецЕсли;
	
КонецПроцедуры

Процедура АвтоСозданиеПриходнойНакладной(ДокументОбъект)
	
	ДополнительныеСвойства = Новый Структура;
	УправлениеНебольшойФирмойСервер.ИнициализироватьДополнительныеСвойстваДляПроведения(ДокументОбъект.Ссылка, ДополнительныеСвойства);
	
	Если НЕ ДополнительныеСвойства.УчетнаяПолитика.АвтоСозданиеПриходнойНакладнойПриРеализации Тогда
		Возврат;
	КонецЕсли;
	
	// получим контрагента и подразделение
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ПараметрыУчетаПоПодразделениямСрезПоследних.СтруктурнаяЕдиница КАК Подразделение,
	|	ПараметрыУчетаПоПодразделениямСрезПоследних.УправляющаяКомпания КАК Контрагент
	|ИЗ
	|	РегистрСведений.ПараметрыУчетаПоПодразделениям.СрезПоследних(&ДатаСреза, Контрагент = &Контрагент) КАК ПараметрыУчетаПоПодразделениямСрезПоследних");
	
	Запрос.УстановитьПараметр("ДатаСреза", ДокументОбъект.Дата);
	Запрос.УстановитьПараметр("Контрагент", ДокументОбъект.Контрагент);
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		Если ЗначениеЗаполнено(Выборка.Контрагент) Тогда
			ПодразделениеВПриходнойНакладной 	= 	Выборка.Подразделение;
			КонтрагентВПриходнойНакладной 		= Выборка.Контрагент;
		Иначе
			Возврат;
		КонецЕсли;
		
	КонецЕсли;
	
	
	// поищем приходную накладную... может уже есть.
	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ПриходнаяНакладная.Ссылка
	|ИЗ
	|	Документ.ПриходнаяНакладная КАК ПриходнаяНакладная
	|ГДЕ
	|	ПриходнаяНакладная.ДокументОснование = &Ссылка");
	
	Запрос.УстановитьПараметр("Ссылка", ДокументОбъект.Ссылка);
	
	ЭтоНовыйДокумент = Ложь;
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		// нету
		СвязанныйДокумент = Документы.ПриходнаяНакладная.СоздатьДокумент();
		
		ЭтоНовыйДокумент = Истина;
		
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		СвязанныйДокумент = Выборка.Ссылка.ПолучитьОбъект();
		
	КонецЕсли;
	
	связанныйДокумент.СозданАвтоматически 	= Истина;
	связанныйДокумент.ДокументОснование = ДокументОбъект.Ссылка;
	связанныйДокумент.ПометкаУдаления	= ДокументОбъект.ПометкаУдаления;
	
	связанныйДокумент.Дата 				= ДокументОбъект.Дата;
	связанныйДокумент.Подразделение 	= ПодразделениеВПриходнойНакладной;
	//СвязанныйДокумент.Менеджер 			= Справочники.Менеджеры.БезМенеджера;
	связанныйДокумент.Комментарий 		= ДокументОбъект.Комментарий;
	связанныйДокумент.Контрагент 		= КонтрагентВПриходнойНакладной;
	связанныйДокумент.ТипЦен 		    = КонтрагентВПриходнойНакладной.ТипЦен;
	связанныйДокумент.Автор 			= ДокументОбъект.Автор;
	связанныйДокумент.Ответственный 	= ДокументОбъект.Ответственный;
	
	связанныйДокумент.СуммаДокумента 	= ДокументОбъект.СуммаДокумента;
	
	Если Не этоНовыйДокумент Тогда
		связанныйДокумент.ДополнительныеСвойства.Вставить("ОбработкаСвязанныхДокументов", Истина);
	КонецЕсли;
	
	// обновим "Запасы"
	Запасы = СвязанныйДокумент.Запасы;
	Запасы.Очистить();
	
	Для Каждого СтрокаСостава Из ДокументОбъект.Запасы Цикл
		
		Если СтрокаСостава.Номенклатура = Справочники.Номенклатура.ПустаяСсылка() Тогда
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока = Запасы.Добавить();
		НоваяСтрока.Номенклатура 		=  СтрокаСостава.Номенклатура;
		НоваяСтрока.ЕдиницаИзмерения 	= НоваяСтрока.Номенклатура.ЕдиницаИзмерения;
		
		НоваяСтрока.Количество 	= СтрокаСостава.Количество;
		
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаСостава);
		
		//НоваяСтрока.СтруктурнаяЕдиница = СтрокаСостава.Номенклатура.Родитель.Склад;
		
		//СтруктураПараметров = Новый Структура("Номенклатура, ТипЦен, Подразделение, ДатаСреза", НоваяСтрока.Номенклатура, ЭтотОбъект.ТипЦен, ЭтотОбъект.Подразделение, ЭтотОбъект.Дата);
		//
		//НоваяСтрока.ПроцентСкидкиНаВес 	= ЦенообразованиеСервер.ВернутьСкидкуНаВес(СтруктураПараметров);
		//НоваяСтрока.Цена 				= ЦенообразованиеСервер.ВернутьЦенуНоменклатуры(СтруктураПараметров);
		//НоваяСтрока.ПроцентСкидки 		= СоответствиеСкидок.Получить(СтрокаСостава.Номенклатура.Родитель);
		
	КонецЦикла;
	
	Если ЭтоНовыйДокумент Тогда
		СвязанныйДокумент.УстановитьНовыйНомер();
	КонецЕсли;
	
	Если ДокументОбъект.Проведен Тогда
		связанныйДокумент.Записать(РежимЗаписиДокумента.Проведение);
	ИначеЕсли ЭтоНовыйДокумент Тогда
		связанныйДокумент.Записать(РежимЗаписиДокумента.Запись);
	Иначе
		связанныйДокумент.Записать(РежимЗаписиДокумента.ОтменаПроведения);
	КонецЕсли;
	
	
КонецПроцедуры

Процедура АвтоСозданиеПоступленияДенег(ДокументОбъект)
	
	// Только для б/н .... и ЦО
	//Если НЕ ДокументОбъект.ДенежныйСчет.Безналичный ИЛИ 
	//		НЕ ДокументОбъект.Контрагент.Код = "000003949" ИЛИ
	Если НЕ ДокументОбъект.Контрагент.Код = "000003949" ИЛИ		
		НЕ ДокументОбъект.ОперацияДокумента = Справочники.ОперацииДокументов.РасходДенегОплата Тогда
		Возврат;
	КонецЕсли;
	
	ДополнительныеСвойства = Новый Структура;
	УправлениеНебольшойФирмойСервер.ИнициализироватьДополнительныеСвойстваДляПроведения(ДокументОбъект.Ссылка, ДополнительныеСвойства);
	
	// Проверка параметров учета по подразделению
	Если ДокументОбъект.ДенежныйСчет.Безналичный И НЕ ДополнительныеСвойства.УчетнаяПолитика.АвтоСозданиеПоступленияДенегПриРасходе Тогда
		Возврат;
	ИначеЕсли НЕ ДокументОбъект.ДенежныйСчет.Безналичный И НЕ ДополнительныеСвойства.УчетнаяПолитика.АвтоСозданиеПоступленияДенегПриРасходе Тогда
		Возврат;
	КонецЕсли;
	
	
	// получим контрагента и подразделение
	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ВложенныйЗапрос.Подразделение,
	|	ВложенныйЗапрос.Контрагент,
	|	ВЫБОР
	|		КОГДА &Безналиный
	|			ТОГДА РасчетныеСчета.Ссылка
	|		ИНАЧЕ ВложенныйЗапрос.ОсновнаяКасса
	|	КОНЕЦ КАК ДенежныйСчет
	|ИЗ
	|	(ВЫБРАТЬ
	|		ЦентральныйОфис.СтруктурнаяЕдиница КАК Подразделение,
	|		Филиал.Контрагент КАК Контрагент,
	|		ЦентральныйОфис.ОсновнаяКасса КАК ОсновнаяКасса
	|	ИЗ
	|		РегистрСведений.ПараметрыУчетаПоПодразделениям.СрезПоследних(&ДатаСреза, СтруктурнаяЕдиница = &Подразделение) КАК Филиал
	|			ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПараметрыУчетаПоПодразделениям.СрезПоследних(&ДатаСреза, Контрагент = &Контрагент) КАК ЦентральныйОфис
	|			ПО (ИСТИНА)) КАК ВложенныйЗапрос
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.РасчетныеСчета КАК РасчетныеСчета
	|		ПО ВложенныйЗапрос.Подразделение = РасчетныеСчета.Подразделение
	|			И (РасчетныеСчета.Наименование = &РасчетныйСчетНаименование)");
	
	Запрос.УстановитьПараметр("ДатаСреза", 					ДокументОбъект.Дата);
	Запрос.УстановитьПараметр("Подразделение", 				ДокументОбъект.Подразделение);
	Запрос.УстановитьПараметр("Контрагент", 				ДокументОбъект.Контрагент);
	Запрос.УстановитьПараметр("РасчетныйСчетНаименование", 	ДокументОбъект.ДенежныйСчет.Наименование);
	Запрос.УстановитьПараметр("Безналиный", 				ДокументОбъект.ДенежныйСчет.Безналичный);
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		Если НЕ ЗначениеЗаполнено(Выборка.Контрагент) Тогда
			Возврат;
		КонецЕсли;
		
		Подразделение 	= Выборка.Подразделение;
		Контрагент 		= Выборка.Контрагент;
		
		Если ЗначениеЗаполнено(ДокументОбъект.СчетПолучателя) Тогда
			ДенежныйСчет	= ДокументОбъект.СчетПолучателя;
		Иначе
			ДенежныйСчет	= Выборка.ДенежныйСчет;
		КонецЕсли;
		
	КонецЕсли;
	
	
	// поищем поступление денег ... может уже есть.
	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ПоступлениеДенег.Ссылка
	|ИЗ
	|	Документ.ПоступлениеДенег КАК ПоступлениеДенег
	|ГДЕ
	|	ПоступлениеДенег.ДокументОснование = &Ссылка");
	
	Запрос.УстановитьПараметр("Ссылка", ДокументОбъект.Ссылка);
	
	ЭтоНовыйДокумент = Ложь;
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		// нету
		СвязанныйДокумент = Документы.ПоступлениеДенег.СоздатьДокумент();
		
		ЭтоНовыйДокумент = Истина;
		
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		СвязанныйДокумент = Выборка.Ссылка.ПолучитьОбъект();
		
	КонецЕсли;
	
	связанныйДокумент.СозданАвтоматически 	= Истина;
	связанныйДокумент.ДокументОснование = ДокументОбъект.Ссылка;
	связанныйДокумент.ПометкаУдаления	= ДокументОбъект.ПометкаУдаления;
	
	связанныйДокумент.Дата 				= ДокументОбъект.Дата;
	связанныйДокумент.Подразделение 	= Подразделение;
	
	связанныйДокумент.Комментарий 		= ДокументОбъект.Комментарий;
	связанныйДокумент.Контрагент 		= Контрагент;
	
	связанныйДокумент.Автор 			= ДокументОбъект.Автор;
	связанныйДокумент.Ответственный 	= ДокументОбъект.Ответственный;
	
	связанныйДокумент.СуммаДокумента 	= ДокументОбъект.СуммаДокумента;
	связанныйДокумент.ОперацияДокумента = Справочники.ОперацииДокументов.ПоступлениеДенегОплата;
	связанныйДокумент.ДенежныйСчет		= ДенежныйСчет;
	
	Если Не этоНовыйДокумент Тогда
		связанныйДокумент.ДополнительныеСвойства.Вставить("ОбработкаСвязанныхДокументов", Истина);
	КонецЕсли;
	
	Если ЭтоНовыйДокумент Тогда
		СвязанныйДокумент.УстановитьНовыйНомер();
	КонецЕсли;
	
	Если ДокументОбъект.Проведен Тогда
		СвязанныйДокумент.Записать(РежимЗаписиДокумента.Проведение);
	ИначеЕсли ЭтоНовыйДокумент Тогда
		СвязанныйДокумент.Записать(РежимЗаписиДокумента.Запись);
	Иначе
		СвязанныйДокумент.Записать(РежимЗаписиДокумента.ОтменаПроведения);
	КонецЕсли;
	
	
КонецПроцедуры

Функция ПолучитьСоответствияТиповВидамДокументов()
	
	результат = Новый Соответствие;
	
	результат.Вставить(Тип("ДокументСсылка.ВозвратПоставщику"), Перечисления.СД_ВидыСвязанныхДокументов.ВозвратПоставщику);
	результат.Вставить(Тип("ДокументСсылка.ПриходнаяНакладная"), Перечисления.СД_ВидыСвязанныхДокументов.ПриходнаяНакладная);
	результат.Вставить(Тип("ДокументСсылка.РасходнаяНакладная"), Перечисления.СД_ВидыСвязанныхДокументов.РасходнаяНакладная);
	результат.Вставить(Тип("ДокументСсылка.ВозвратОтПокупателя"), Перечисления.СД_ВидыСвязанныхДокументов.ВозвратОтПокупателя);
	результат.Вставить(Тип("ДокументСсылка.ПоступлениеДенег"), Перечисления.СД_ВидыСвязанныхДокументов.ПоступлениеДенег);
	результат.Вставить(Тип("ДокументСсылка.РасходДенег"), Перечисления.СД_ВидыСвязанныхДокументов.РасходДенег);
	
	Возврат результат;
	
КонецФункции

Функция СоздатьДокументПоВидуСвязанногоДокумента(видДокумента)
	
	результат = Неопределено;
	
	Если видДокумента = Перечисления.СД_ВидыСвязанныхДокументов.ВозвратОтПокупателя Тогда
		результат = Документы.ВозвратПоставщику.СоздатьДокумент();
	ИначеЕсли видДокумента = Перечисления.СД_ВидыСвязанныхДокументов.РасходДенег Тогда
		результат = Документы.ПоступлениеДенег.СоздатьДокумент();
	ИначеЕсли видДокумента = Перечисления.СД_ВидыСвязанныхДокументов.ПриходнаяНакладная Тогда
		результат = Документы.РасходнаяНакладная.СоздатьДокумент();
	ИначеЕсли видДокумента = Перечисления.СД_ВидыСвязанныхДокументов.ВозвратПоставщику Тогда
		результат = Документы.ВозвратОтПокупателя.СоздатьДокумент();
	КонецЕсли;
	
	Возврат результат;
	
КонецФункции

Процедура ОбновитьСвязанныйДокумент(источник, связанныйДокумент = Неопределено)
	
	соответствияТиповВидамДокументов = ПолучитьСоответствияТиповВидамДокументов();
	
	запрос = Новый Запрос;
	
	#Область ТекстЗапроса
	
	запрос.Текст =
	"ВЫБРАТЬ
	|	&ДокументОснование
	|ПОМЕСТИТЬ ВТ_ДокументОснование
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ДокументОснование.ДокументОснование,
	|	СД_СоответствияСрезПоследних.КлючСоответствия,
	|	СД_СоответствияСрезПоследних.ПодразделениеЗначение,
	|	СД_СоответствияСрезПоследних.КонтрагентЗначение,
	|	СД_СвязанныеДокументы.Документ,
	|	СД_СвязанныеДокументы.КлючСоответствия КАК КлючСоответствияДокумента
	|ИЗ
	|	ВТ_ДокументОснование КАК ВТ_ДокументОснование
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.СД_Соответствия.СрезПоследних(
	|				&МоментВремени,
	|				КлючСоответствия.ВидДокумента = &ВидДокумента
	|					И КлючСоответствия.Подразделение = &Подразделение
	|					И КлючСоответствия.Контрагент = &Контрагент) КАК СД_СоответствияСрезПоследних
	|		ПО (СД_СоответствияСрезПоследних.Активно = ИСТИНА)
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.СД_СвязанныеДокументы КАК СД_СвязанныеДокументы
	|		ПО ВТ_ДокументОснование.ДокументОснование = СД_СвязанныеДокументы.ДокументОснование";
	
	#КонецОбласти
	
	запрос.УстановитьПараметр("МоментВремени", источник.МоментВремени());
	запрос.УстановитьПараметр("ДокументОснование", источник.Ссылка);
	запрос.УстановитьПараметр("ВидДокумента", соответствияТиповВидамДокументов.Получить(ТипЗнч(источник.Ссылка)));
	запрос.УстановитьПараметр("Подразделение", источник.Подразделение);
	запрос.УстановитьПараметр("Контрагент", источник.Контрагент);
	
	результатЗапроса = запрос.выполнить();
	
	Если результатЗапроса.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	результатЗапроса = результатЗапроса.выгрузить()[0];
	
	Если ЗначениеЗаполнено(результатЗапроса.КлючСоответствия) Тогда
		
		этоНовыйДокумент = Ложь;
		
		// должен быть связанный документ
		Если ЗначениеЗаполнено(результатЗапроса.Документ) Тогда
			связанныйДокумент = результатЗапроса.Документ.ПолучитьОбъект();
		Иначе
			связанныйДокумент = СоздатьДокументПоВидуСвязанногоДокумента(результатЗапроса.КлючСоответствия.ВидДокумента);
			этоНовыйДокумент = Истина;
		КонецЕсли;
		
		Если Не связанныйДокумент = Неопределено Тогда
			
			связанныйДокумент.ДополнительныеСвойства.Вставить("СозданАвтоматически", Истина);
			связанныйДокумент.ДополнительныеСвойства.Вставить("КлючСоответствия", результатЗапроса.КлючСоответствия);
			
			Если Не этоНовыйДокумент Тогда
				связанныйДокумент.ДополнительныеСвойства.Вставить("ОбработкаСвязанныхДокументов", Истина);
			КонецЕсли;
			
			связанныйДокумент.Заполнить(источник.Ссылка);
			
			связанныйДокумент.Дата = источник.Дата;
			
			связанныйДокумент.Записать(РежимЗаписиДокумента.Запись);
			
			Если источник.ПометкаУдаления Или связанныйДокумент.ПометкаУдаления Тогда
				связанныйДокумент.УстановитьПометкуУдаления(источник.ПометкаУдаления);
			КонецЕсли;
			
			Если источник.Проведен Тогда
				
				связанныйДокумент.Записать(РежимЗаписиДокумента.Проведение);
				
			ИначеЕсли связанныйДокумент.Проведен Тогда
				
				связанныйДокумент.Записать(РежимЗаписиДокумента.ОтменаПроведения);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура ОбновлениеСвязанныхДокументовПриЗаписи проверяет наличие связанных документов 
//	(созданных автоматически) и обновляет их
//
Процедура ОбновлениеСвязанныхДокументовПриЗаписи(источник, отказ) Экспорт
	
	#Если Не ВнешнееСоединение Тогда
		
		УстановитьПривилегированныйРежим(Истина);
		
		Если Не источник.Метаданные().Реквизиты.Найти("СозданАвтоматически") = Неопределено Тогда
			
			Если источник.СозданАвтоматически Тогда
				
				ключСоответствия = Неопределено;
				Если источник.ДополнительныеСвойства.Свойство("КлючСоответствия", ключСоответствия) Тогда
					
					// "запись" в регистре обновляется только при автоматическом изменении "сваязанного" документа
					менеджерЗаписи = РегистрыСведений.СД_СвязанныеДокументы.СоздатьМенеджерЗаписи();
					
					менеджерЗаписи.ДокументОснование = источник.ДокументОснование;
					менеджерЗаписи.Прочитать();
					
					Если менеджерЗаписи.ДокументОснование = Неопределено Тогда
						менеджерЗаписи.ДокументОснование = источник.ДокументОснование;
					КонецЕсли;
					
					менеджерЗаписи.Подразделение = источник.ДокументОснование.Подразделение;
					менеджерЗаписи.Документ = источник.Ссылка;
					менеджерЗаписи.КлючСоответствия = ключСоответствия; 
					менеджерЗаписи.Статус = 1;
					менеджерЗаписи.ДатаОбновления = ТекущаяДатаСеанса();
					
					менеджерЗаписи.Записать();
					
				КонецЕсли;
				
				Возврат;
				
			КонецЕсли;
			
		КонецЕсли;
		
		параметрыФоновогоЗадания = Новый Массив;
		параметрыФоновогоЗадания.Добавить(значениеВСтрокуВнутр(источник.Ссылка));
		//параметрыФоновогоЗадания.Добавить(ДанныеВXML(источник));
		параметрыФоновогоЗадания.Добавить(ТекущаяДатаСеанса());
		
		ФоновыеЗадания.Выполнить("ОбщегоНазначения.ОбновитьСвязанныйДокументВФоне", параметрыФоновогоЗадания, Новый УникальныйИдентификатор, "Обновление связанного документа");
		
		Если Ложь Тогда
			
			связанныйДокумент = Неопределено;
			ОбновитьСвязанныйДокумент(источник, связанныйДокумент);
			
			// ПЕРЕДЕЛАТЬ: оставлено для совместимости со старым "механизмом"
			Если связанныйДокумент = Неопределено Тогда
				
				Если ТипЗнч(Источник) = Тип("ДокументОбъект.РасходнаяНакладная") Тогда
					
					АвтоСозданиеНалоговойНакладной(Источник);
					
					АвтоСозданиеПриходнойНакладной(Источник);
					
				ИначеЕсли ТипЗнч(Источник) = Тип("ДокументОбъект.ВозвратОтПокупателя") Тогда
					
					АвтоСозданиеПриложения2КНалоговойНакладной(Источник);
					
				ИначеЕсли ТипЗнч(Источник) = Тип("ДокументОбъект.ВозвратПоставщику") Тогда
					
					АвтоСозданиеВозвратаОтПокупателя(Источник);
					
				ИначеЕсли ТипЗнч(Источник) = Тип("ДокументОбъект.РасходДенег") Тогда
					
					АвтоСозданиеПоступленияДенег(Источник);
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	#КонецЕсли
	
КонецПроцедуры	// ОбновлениеСвязанныхДокументовПриЗаписи()

Процедура ОбновитьСвязанныйДокументВФоне(адресВХранилище, времяЗапускаЗадания,режимЗаписи = Неопределено) Экспорт
	
	Пока времяЗапускаЗадания + 2 >= ТекущаяДатаСеанса() Цикл
	КонецЦикла;
	
	УстановитьПривилегированныйРежим(Истина);
	
	источник = значениеИзСтрокиВнутр(адресВХранилище);
	//источник = ДанныеИзXML(адресВХранилище);
	
	связанныйДокумент = Неопределено;
	ОбновитьСвязанныйДокумент(источник, связанныйДокумент);
	
	// ПЕРЕДЕЛАТЬ: оставлено для совместимости со старым "механизмом"
	Если связанныйДокумент = Неопределено Тогда
		
		Если ТипЗнч(Источник) = Тип("ДокументСсылка.РасходнаяНакладная") Тогда
			
			АвтоСозданиеНалоговойНакладной(источник);
			
			АвтоСозданиеПриходнойНакладной(источник);
			
		ИначеЕсли ТипЗнч(Источник) = Тип("ДокументСсылка.ВозвратОтПокупателя") Тогда
			
			АвтоСозданиеПриложения2КНалоговойНакладной(источник);
			
		ИначеЕсли ТипЗнч(Источник) = Тип("ДокументСсылка.ВозвратПоставщику") Тогда
			
			АвтоСозданиеВозвратаОтПокупателя(источник);
			
		ИначеЕсли ТипЗнч(Источник) = Тип("ДокументСсылка.РасходДенег") Тогда
			
			АвтоСозданиеПоступленияДенег(источник);
			
		КонецЕсли;
		
	КонецЕсли;
	
	//УдалитьИзВременногоХранилища(адресВХранилище);
	
КонецПроцедуры

Функция ДанныеВXML(Данные)
    ЗаписьXML = Новый ЗаписьXML();
    ЗаписьXML.УстановитьСтроку();
    СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Данные);
    Возврат ЗаписьXML.Закрыть();
КонецФункции

Функция ДанныеИзXML(Стр)
    ЧтениеXML = Новый ЧтениеXML();
    ЧтениеXML.УстановитьСтроку(Стр);
    Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML); 
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции для работы с прикладными типами и коллекциями значений

// Получает имя значения перечисления как объекта метаданных
//
// Параметры:
//  Значение - значение перечисления для которого необходимо получить имя перечисления
//
// Возвращаемое значение:
//  Строка - имя значения перечисления как объекта метаданных
//
Функция ИмяЗначенияПеречисления(Значение) Экспорт
	
	ОбъектМетаданных = Значение.Метаданные();
	
	ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);
	
	Возврат ОбъектМетаданных.ЗначенияПеречисления[ИндексЗначения].Имя;
	
КонецФункции 

// Заполняет массив-приемник уникальными значениями из массива-источника.
// Если элемент в массиве-приемнике уже существует, то добавления нового элемента не происходит.
//
// Параметры:
//  МассивПриемник – Массив – массив, который заполняется уникальными значениями
//  МассивИсточник – Массив – массив, из которого подбираются элементы в массив-приемник.
// 
Процедура ЗаполнитьМассивУникальнымиЗначениями(МассивПриемник, МассивИсточник) Экспорт
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого Значение Из МассивПриемник Цикл
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла;
	
	Для каждого Значение Из МассивИсточник Цикл
		Если УникальныеЗначения[Значение] = Неопределено Тогда
			МассивПриемник.Добавить(Значение);
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам 
// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
//
// Параметры:
//	МассивРеквизитов              - Массив - массив строк с именами реквизитов объекта.
//	МассивНепроверяемыхРеквизитов - Массив строк с именами реквизитов объекта, не требующих проверки.
//
Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл
		
		ПорядковыйНомер = МассивРеквизитов.Найти(ЭлементМассива);
		Если ПорядковыйНомер <> Неопределено Тогда
			МассивРеквизитов.Удалить(ПорядковыйНомер);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

//	Преобразует таблицу значений в массив.
//	Может использоваться для передачи на клиента данных, полученных
//	на сервере в виде таблицы значений в том случае, если таблица
//	значений содержит только такие значения, которые могут
//  быть переданы на клиента
//
//	Полученный массив содержит структуры, каждая из которых повторяет
//	структуру колонок таблицы значений.
//
//	Не рекомендуется использовать для преобразования таблиц значений
//	с большим количеством строк.
//
//	Параметры: ТаблицаЗначений
//	Возвращаемое значение: Массив
//
Функция ТаблицаЗначенийВМассив(ТаблицаЗначений) Экспорт
	
	Массив = Новый Массив();
	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат Массив;
	
КонецФункции

// Функция СтрокаТаблицыЗначенийВСтруктуру создает
// структуру со свойствами, как колонки таблицы
// значений передаваемой строки
// и устанавливает этим свойствам значения
// из строки таблицы значений
// 
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений
//
// ВозвращаемоеЗначение:
//  Структура
//
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
	
	Структура = Новый Структура;
	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

// Создает структуру аналогичную менеджеру записи регистра сведений
// 
// Параметры:
//	МенеджерЗаписи - РегистрСведенийМенеджерЗаписи,
//	МетаданныеРегистра - метаданные регистра сведений
//
Функция СтруктураПоМенеджеруЗаписи(МенеджерЗаписи, МетаданныеРегистра) Экспорт
	
	ЗаписьКакСтруктура = Новый Структура;
	
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		ЗаписьКакСтруктура.Вставить("Период", МенеджерЗаписи.Период);
	КонецЕсли;
	Для Каждого Поле Из МетаданныеРегистра.Измерения Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Ресурсы Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	Для Каждого Поле Из МетаданныеРегистра.Реквизиты Цикл
		ЗаписьКакСтруктура.Вставить(Поле.Имя, МенеджерЗаписи[Поле.Имя]);
	КонецЦикла;
	
	Возврат ЗаписьКакСтруктура;
	
КонецФункции

// Создает массив и копирует в него значения, содержащиеся в колонке коллекции строк
//
// Параметры:
//	КоллекцияСтрок - коллекция, для которой доступен обход посредством  
//		оператора Для каждого … Из … Цикл
//	ИмяКолонки - строка с именем поля коллекции, значения которого нужно выгрузить
//	ТолькоУникальныеЗначения - булево, необязательный, если истина, 
//		то в массив будут включены только различающиеся значения 
//
Функция ВыгрузитьКолонку(КоллекцияСтрок, ИмяКолонки, ТолькоУникальныеЗначения = Ложь) Экспорт
	
	МассивЗначений = Новый Массив;
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого СтрокаКоллекции Из КоллекцияСтрок Цикл
		Значение = СтрокаКоллекции[ИмяКолонки];
		Если ТолькоУникальныеЗначения И УникальныеЗначения[Значение] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивЗначений.Добавить(Значение);
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла; 
	
	Возврат МассивЗначений;
	
КонецФункции

// Преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
//
// Параметры:
//  XML     - текст в формате XML или ЧтениеXML.
//
// Схема XML:
//<?xml version="1.0" encoding="utf-8"?>
//<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
//  <xs:element name="Items">
//	<xs:complexType>
//	  <xs:sequence>
//		<xs:element maxOccurs="unbounded" name="Item">
//		  <xs:complexType>
//			<xs:attribute name="Code" type="xs:integer" use="required" />
//			<xs:attribute name="Name" type="xs:string" use="required" />
//			<xs:attribute name="Socr" type="xs:string" use="required" />
//			<xs:attribute name="Index" type="xs:string" use="required" />
//		  </xs:complexType>
//		</xs:element>
//	  </xs:sequence>
//	  <xs:attribute name="Description" type="xs:string" use="required" />
//	  <xs:attribute name="Columns" type="xs:string" use="required" />
//	</xs:complexType>
//  </xs:element>
//</xs:schema>
//
// Примеры XML-файлов см. в демонстрационной конфигурации.
// 
// Пример использования:
//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(РегистрыСведений.АдресныйКлассификатор.
//       ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст());
//
// Возвращаемое значение:
//  Структура с полями 
//   ИмяТаблицы - Строка
//   Данные - ТаблицаЗначений.
//
Функция ПрочитатьXMLВТаблицу(Знач XML) Экспорт
	
	Если ТипЗнч(XML) <> Тип("ЧтениеXML") Тогда
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(XML);
	Иначе
		Чтение = XML;
	КонецЕсли;
	
	// Прочитаем первый узел и проверим его
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение("Пустой XML");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение("Ошибка в структуре XML");
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла = ТипУзлаXML.КонецЭлемента И Чтение.Имя = "Items" Тогда
			Прервать;
		ИначеЕсли Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение("Ошибка в структуре XML");
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции // ПрочитатьXMLВТаблицу()

// Функция выполняет сравнение двух коллекций строк, для которых доступен обход 
// посредством оператора Для каждого … Из … Цикл.
// Сравниваемые коллекции должны отвечать следующим требованиям:
//	- доступен обход посредством оператора Для каждого … Из … Цикл,
//	- наличие в обеих коллекциях всех колонок, перечисленных в параметре ИменаКолонок 
//  (если ИменаКолонок не заполнен - всех колонок)
//
// Параметры:
//	КоллекцияСтрок1 - коллекция, отвечающая вышеописанным требованиям
//	КоллекцияСтрок2 - коллекция, отвечающая вышеописанным требованиям
//	ИменаКолонок 	- строка, разделенная запятыми - имена колонок, 
//						по которым производится сравнение. 
//						Не является обязательным для коллекций, 
//						состав колонок которых можно выявить: 
//						ТаблицаЗначений, СписокЗначений, Соответствие, Структура,
//						если не указан - сравнение производится по всем колонкам.
//						Для коллекций других типов является обязательным
//	ИсключаяКолонки	- имена колонок, которые игнорируются при сравнении, необязательный
//	УчитыватьПоследовательностьСтрок - булево, если Истина, то коллекции признаются 
//						идентичными только если одинаковые строки размещены 
//						в коллекциях на одинаковых местах
//
Функция КоллекцииИдентичны(КоллекцияСтрок1, КоллекцияСтрок2, ИменаКолонок = "", ИсключаяКолонки = "", УчитыватьПоследовательностьСтрок = Ложь) Экспорт
	
	// Типы коллекций, для которых доступен состав колонок, 
	// и можно выявить, если он не задан
	ТипыОсобыхКоллекций = Новый Массив;
	ТипыОсобыхКоллекций.Добавить(Тип("ТаблицаЗначений"));
	ТипыОсобыхКоллекций.Добавить(Тип("СписокЗначений"));
	
	ТипыКоллекцийКлючИЗначение = Новый Массив;
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("Соответствие"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("Структура"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированноеСоответствие"));
	ТипыКоллекцийКлючИЗначение.Добавить(Тип("ФиксированнаяСтруктура"));
	
	Если ПустаяСтрока(ИменаКолонок) Тогда
		Если ТипыОсобыхКоллекций.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено 
			Или ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
			СравниваемыеКолонки = Новый Массив;
			Если ТипЗнч(КоллекцияСтрок1) = Тип("ТаблицаЗначений") Тогда
				Для Каждого Колонка Из КоллекцияСтрок1.Колонки Цикл
					СравниваемыеКолонки.Добавить(Колонка.Имя);
				КонецЦикла;
			ИначеЕсли ТипЗнч(КоллекцияСтрок1) = Тип("СписокЗначений") Тогда
				СравниваемыеКолонки.Добавить("Значение");
				СравниваемыеКолонки.Добавить("Картинка");
				СравниваемыеКолонки.Добавить("Пометка");
				СравниваемыеКолонки.Добавить("Представление");
			ИначеЕсли ТипыКоллекцийКлючИЗначение.Найти(ТипЗнч(КоллекцияСтрок1)) <> Неопределено Тогда
				СравниваемыеКолонки.Добавить("Ключ");
				СравниваемыеКолонки.Добавить("Значение");
			КонецЕсли;
		Иначе
			ТекстИсключения = НСтр("ru = 'Для коллекции типа %1 необходимо указать имена полей, по которым производится сравнение'");
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИсключения, ТипЗнч(КоллекцияСтрок1));
		КонецЕсли;
	Иначе
		СравниваемыеКолонки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаКолонок);
	КонецЕсли;
	
	// Вычитаем исключаемые поля
	СравниваемыеКолонки = ОбщегоНазначенияКлиентСервер.СократитьМассив(СравниваемыеКолонки, 
	СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИсключаяКолонки));
	
	Если УчитыватьПоследовательностьСтрок Тогда
		
		// Параллельный обход обеих коллекций
		НомерСтрокиКоллекции1 = 0;
		Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
			// Спозиционируемся на аналогичную строку второй коллекции
			НомерСтрокиКоллекции2 = 0;
			ЕстьСтрокиКоллекции2 = Ложь;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				ЕстьСтрокиКоллекции2 = Истина;
				Если НомерСтрокиКоллекции2 = НомерСтрокиКоллекции1 Тогда
					Прервать;
				КонецЕсли;
				НомерСтрокиКоллекции2 = НомерСтрокиКоллекции2 + 1;
			КонецЦикла;
			Если Не ЕстьСтрокиКоллекции2 Тогда
				// Во второй коллекции вообще нет строк
				Возврат Ложь;
			КонецЕсли;
			// Сравниваем значения полей двух строк
			Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
				Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаКоллекции2[ИмяКолонки] Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
			НомерСтрокиКоллекции1 = НомерСтрокиКоллекции1 + 1;
		КонецЦикла;
		
		КоличествоСтрокКоллекции1 = НомерСтрокиКоллекции1;
		
		// Отдельно подсчитаем количество строк второй коллекции
		КоличествоСтрокКоллекции2 = 0;
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			КоличествоСтрокКоллекции2 = КоличествоСтрокКоллекции2 + 1;
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй
		Если КоличествоСтрокКоллекции1 = 0 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
			КоличествоСтрокКоллекции2 = 0;
		КонецЕсли;
		
		// Количество строк не должно отличаться
		Если КоличествоСтрокКоллекции1 <> КоличествоСтрокКоллекции2 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	Иначе
		
		// Проверяем идентичность состава одинаковых строк без учета их последовательности
		
		// Строки отбора накапливаем по первой коллекции для того, чтобы:
		//  - повторно не искать одинаковые строки,
		//  - убедиться, что во второй коллекции ни одной такой строки, которой нет в накопленных
		
		СтрокиОтбора = Новый ТаблицаЗначений;
		ПараметрыОтбора = Новый Структура;
		Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
			СтрокиОтбора.Колонки.Добавить(ИмяКолонки);
			ПараметрыОтбора.Вставить(ИмяКолонки);
		КонецЦикла;
		
		ЕстьСтрокиКоллекции1 = Ложь;
		Для Каждого СтрокаОтбора Из КоллекцияСтрок1 Цикл
			
			ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаОтбора);
			Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() > 0 Тогда
				// строку с такими полями уже искали
				Продолжить;
			КонецЕсли;
			ЗаполнитьЗначенияСвойств(СтрокиОтбора.Добавить(), СтрокаОтбора);
			
			// Подсчитаем количество таких строк в первой коллекции
			НайденоСтрокКоллекции1 = 0;
			Для Каждого СтрокаКоллекции1 Из КоллекцияСтрок1 Цикл
				СтрокаПодходит = Истина;
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции1[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
						СтрокаПодходит = Ложь;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если СтрокаПодходит Тогда
					НайденоСтрокКоллекции1 = НайденоСтрокКоллекции1 + 1;
				КонецЕсли;
			КонецЦикла;
			
			// Подсчитаем количество таких строк во второй коллекции
			НайденоСтрокКоллекции2 = 0;
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				СтрокаПодходит = Истина;
				Для Каждого ИмяКолонки Из СравниваемыеКолонки Цикл
					Если СтрокаКоллекции2[ИмяКолонки] <> СтрокаОтбора[ИмяКолонки] Тогда
						СтрокаПодходит = Ложь;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				Если СтрокаПодходит Тогда
					НайденоСтрокКоллекции2 = НайденоСтрокКоллекции2 + 1;
					// Если количество таких строк во второй коллекции превысило количество в первой, 
					// то уже можно сделать вывод, что коллекции не идентичны
					Если НайденоСтрокКоллекции2 > НайденоСтрокКоллекции1 Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			// Количество таких строк не должно отличаться
			Если НайденоСтрокКоллекции1 <> НайденоСтрокКоллекции2 Тогда
				Возврат Ложь;
			КонецЕсли;
			
			ЕстьСтрокиКоллекции1 = Истина;
			
		КонецЦикла;
		
		// Если в первой коллекции не оказалось строк, 
		// то их не должно быть и во второй
		Если Не ЕстьСтрокиКоллекции1 Тогда
			Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
				Возврат Ложь;
			КонецЦикла;
		КонецЕсли;
		
		// Проверим, что во второй коллекции нет ни одной такой строки, которой нет в накопленных
		Для Каждого СтрокаКоллекции2 Из КоллекцияСтрок2 Цикл
			ЗаполнитьЗначенияСвойств(ПараметрыОтбора, СтрокаКоллекции2);
			Если СтрокиОтбора.НайтиСтроки(ПараметрыОтбора).Количество() = 0 Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Сравнивает данные сложной структуры с учетом вложенности.
//
// Параметры:
//  Данные1 - Структура,    ФиксированнаяСтруктура.
//          - Соответствие, ФиксированноеСоответствие.
//          - Массив,       ФиксированныйМассив.
//          - ХранилищеЗначения, ТаблицаЗначений.
//          - Простые типы, которые можно сравнивать на равно,
//            например, Строка, Число, Булево.
//
//  Данные2 - те же типы, что и для параметра Данные1.
//
// Возвращаемое значение:
//  Булево.
//
Функция ДанныеСовпадают(Данные1, Данные2) Экспорт
	
	Если ТипЗнч(Данные1) <> ТипЗнч(Данные2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Данные1) = Тип("Структура")
		ИЛИ ТипЗнч(Данные1) = Тип("ФиксированнаяСтруктура") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			СтароеЗначение = Неопределено;
			
			Если НЕ Данные2.Свойство(КлючИЗначение.Ключ, СтароеЗначение)
				ИЛИ НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
				
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Соответствие")
		ИЛИ ТипЗнч(Данные1) = Тип("ФиксированноеСоответствие") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		КлючиНовогоСоответствия = Новый Соответствие;
		
		Для каждого КлючИЗначение Из Данные1 Цикл
			КлючиНовогоСоответствия.Вставить(КлючИЗначение.Ключ, Истина);
			СтароеЗначение = Данные2.Получить(КлючИЗначение.Ключ);
			
			Если НЕ ДанныеСовпадают(КлючИЗначение.Значение, СтароеЗначение) Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Для каждого КлючИЗначение Из Данные2 Цикл
			Если КлючиНовогоСоответствия[КлючИЗначение.Ключ] = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("Массив")
		ИЛИ ТипЗнч(Данные1) = Тип("ФиксированныйМассив") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Индекс = Данные1.Количество()-1;
		Пока Индекс >= 0 Цикл
			Если НЕ ДанныеСовпадают(Данные1.Получить(Индекс), Данные2.Получить(Индекс)) Тогда
				Возврат Ложь;
			КонецЕсли;
			Индекс = Индекс - 1;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ТаблицаЗначений") Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если Данные1.Колонки.Количество() <> Данные2.Колонки.Количество() Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого Колонка Из Данные1.Колонки Цикл
			Если Данные2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Индекс = Данные1.Количество()-1;
			Пока Индекс >= 0 Цикл
				Если НЕ ДанныеСовпадают(Данные1[Индекс][Колонка.Имя], Данные2[Индекс][Колонка.Имя]) Тогда
					Возврат Ложь;
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли ТипЗнч(Данные1) = Тип("ХранилищеЗначения") Тогда
		
		Если НЕ ДанныеСовпадают(Данные1.Получить(), Данные2.Получить()) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Возврат Истина;
	КонецЕсли;
	
	Возврат Данные1 = Данные2;
	
КонецФункции

// Фиксирует Данные типов Структура, Соответствие, Массив с учетом вложенности.
//
// Параметры:
//  Данные - Структура, Соответствие, Массив, значения которых
//           являются примитивными типами или хранилищем значения.
//
//  ВызыватьИсключение - Булево - начальное значение Истина. Когда установлено
//                       Ложь, тогда в случае наличия нефиксируемых данных исключение не будет
//                       вызвано, при этом данные будут зафиксированы на сколько возможно.
//
// Возвращаемое значение:
//  Фиксированные данные, аналогичные переданным в параметре Данные.
// 
Функция ФиксированныеДанные(Данные, ВызыватьИсключение = Истина) Экспорт
	
	Если ТипЗнч(Данные) = Тип("Массив") Тогда
		Массив = Новый Массив;
		
		Индекс = Данные.Количество() - 1;
		
		Для каждого Значение Из Данные Цикл
			
			Если ТипЗнч(Значение) = Тип("Структура")
				ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
				ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Массив.Добавить(ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Массив.Добавить(Значение);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Новый ФиксированныйМассив(Массив);
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура")
		ИЛИ ТипЗнч(Данные) = Тип("Соответствие") Тогда
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Коллекция = Новый Структура;
		Иначе
			Коллекция = Новый Соответствие;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные Цикл
			Значение = КлючИЗначение.Значение;
			
			Если ТипЗнч(Значение) = Тип("Структура")
				ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
				ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Коллекция.Вставить(
				КлючИЗначение.Ключ, ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Коллекция.Вставить(КлючИЗначение.Ключ, Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Возврат Новый ФиксированнаяСтруктура(Коллекция);
		Иначе
			Возврат Новый ФиксированноеСоответствие(Коллекция);
		КонецЕсли;
		
	ИначеЕсли ВызыватьИсключение Тогда
		ПроверкаФиксированностиДанных(Данные);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

// Создает копию объекта XDTO.
//
// Параметры:
//  Фабрика - ФабрикаXDTO - фабрика, которой создан исходный объект
//  Объект - ОбъектXDTO - объект, копию которого требуется создать
//
// Возвращаемое значение:
//  ОбъектXDTO - копия исходного объекта XDTO
Функция СкопироватьXDTO(Знач Фабрика, Знач Объект) Экспорт
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Фабрика.ЗаписатьXML(Запись, Объект, , , , НазначениеТипаXML.Явное);
	
	XMLПредставление = Запись.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(XMLПредставление);
	
	Возврат Фабрика.ПрочитатьXML(Чтение, Объект.Тип());
	
КонецФункции

// Возвращает XML представление типа XDTO.
//
// Параметры:
//  ТипXDTO - ТипОбъектаXDTO, ТипЗначенияXDTO - тип XDTO для которого требуется получить
//   XML представление
//
// Возвращаемое значение:
//  Строка - XML представление типа XDTO
//
Функция ПредставлениеТипаXDTO(ТипXDTO) Экспорт
	
	Возврат СериализаторXDTO.XMLСтрока(Новый РасширенноеИмяXML(ТипXDTO.URIПространстваИмен, ТипXDTO.Имя))
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Функция УровеньСобытияПоПредставлению(ПредставлениеУровня)
	Если ПредставлениеУровня = "Информация" Тогда
		Возврат УровеньЖурналаРегистрации.Информация;
	ИначеЕсли ПредставлениеУровня = "Ошибка" Тогда
		Возврат УровеньЖурналаРегистрации.Ошибка;
	ИначеЕсли ПредставлениеУровня = "Предупреждение" Тогда
		Возврат УровеньЖурналаРегистрации.Предупреждение; 
	ИначеЕсли ПредставлениеУровня = "Примечание" Тогда
		Возврат УровеньЖурналаРегистрации.Примечание;
	КонецЕсли;	
КонецФункции

Функция УровниСобытияЖурналаРегистрацииПоСтроке(СписокУровней)
	МассивНазванийУровней = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СписокУровней);
	МассивУровней = Новый Массив;
	Для Каждого Название Из МассивНазванийУровней Цикл
		МассивУровней.Добавить(УровеньСобытияПоПредставлению(Название));
	КонецЦикла;
	Возврат МассивУровней;
КонецФункции

Процедура НоваяСтрокаКоллекцииОбъектовМетаданных(Имя, Синоним, Картинка, КартинкаОбъекта, Таб)
	
	НоваяСтрока = Таб.Добавить();
	НоваяСтрока.Имя               = Имя;
	НоваяСтрока.Синоним           = Синоним;
	НоваяСтрока.Картинка          = Картинка;
	НоваяСтрока.КартинкаОбъекта   = КартинкаОбъекта;
	
КонецПроцедуры

Функция ИмяКоллекции(ПолноеИмя)
	
	ПозицияТочки = Найти(ПолноеИмя, ".");
	
	Если ПозицияТочки > 0 Тогда
		Возврат Лев(ПолноеИмя, ПозицияТочки - 1);
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

Процедура ПроверкаФиксированностиДанных(Данные, ДанныеВЗначенииФиксированныхТипов = Ложь)
	
	ТипДанных = ТипЗнч(Данные);
	
	Если ТипДанных = Тип("ХранилищеЗначения")
		ИЛИ ТипДанных = Тип("ФиксированныйМассив")
		ИЛИ ТипДанных = Тип("ФиксированнаяСтруктура")
		ИЛИ ТипДанных = Тип("ФиксированноеСоответствие") Тогда
		
		Возврат;
	КонецЕсли;
	
	Если ДанныеВЗначенииФиксированныхТипов Тогда
		
		Если ТипДанных = Тип("Булево")
			ИЛИ ТипДанных = Тип("Строка")
			ИЛИ ТипДанных = Тип("Число")
			ИЛИ ТипДанных = Тип("Дата")
			ИЛИ ТипДанных = Тип("Неопределено")
			ИЛИ ТипДанных = Тип("Null")
			ИЛИ ТипДанных = Тип("Тип")
			ИЛИ ТипДанных = Тип("ХранилищеЗначения")
			ИЛИ ЭтоСсылка(ТипДанных) Тогда
			
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	НСтр("ru = 'Ошибка в функции ФиксированныеДанные общего модуля ОбщегоНазначения.
	|Данные типа ""%1"" не могут быть зафиксированы.'"),
	Строка(ТипДанных) );
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
//  Сохранение и чтение настроек

// Передает с клиента на сервер для записи массив настроек 
//(массив структур с полями Объект Настройка Значение)
Процедура ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур) Экспорт
	Для Каждого Элемент Из МассивСтруктур Цикл
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, Элемент.Настройка, Элемент.Значение);
	КонецЦикла;
КонецПроцедуры

// Передает с клиента на сервер для записи массив настроек 
//(массив структур с полями Объект Настройка Значение) и обновляет повторно используемые значения
Процедура ХранилищеОбщихНастроекСохранитьМассивИОбновитьПовторноИспользуемыеЗначения(МассивСтруктур) Экспорт
	
	Для Каждого Элемент Из МассивСтруктур Цикл
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, Элемент.Настройка, Элемент.Значение);
	КонецЦикла;
	
	ОбновитьПовторноИспользуемыеЗначения();
	
КонецПроцедуры

// Передает с клиента на сервер для записи настройку
Процедура ХранилищеОбщихНастроекСохранить(Объект, Настройка, Значение) Экспорт
	ХранилищеОбщихНастроек.Сохранить(Объект, Настройка, Значение);
КонецПроцедуры

// Передает с клиента на сервер для записи настройку и обновляет повторно используемые значения
Процедура ХранилищеОбщихНастроекСохранитьИОбновитьПовторноИспользуемыеЗначения(Объект, Настройка, Значение) Экспорт
	ХранилищеОбщихНастроек.Сохранить(Объект, Настройка, Значение);
	ОбновитьПовторноИспользуемыеЗначения();
КонецПроцедуры

// Передает с клиента на сервер для записи
Функция ХранилищеОбщихНастроекЗагрузить(Объект, Настройка) Экспорт
	Возврат ХранилищеОбщихНастроек.Загрузить(Объект, Настройка);
КонецФункции



// Функция возвращает значение экспортных переменных модуля приложений из параметра сеанса
// Необходмо для возможности создания объектов на сервере
Функция ПолучитьЗначениеПеременной(ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	Иначе
		// Ищем значение в структуре
		НайденноеЗначение = Неопределено;
		Если Кэш.Свойство(ИмяПараметра, НайденноеЗначение) Тогда
			Возврат НайденноеЗначение;
		КонецЕсли;
	КонецЕсли;
	
	// Значение в КЭШе не нашли, получим значение из БД
	Если ВРег(ИмяПараметра) = ВРег("глТекущийПользователь") Тогда
		НайденноеЗначение = ПараметрыСеанса.ТекущийПользователь;
	Иначе
		СтрокаИсключения = "Невозможно обработать параметр " + """" + ИмяПараметра + """" + " для получения значения";
		ВызватьИсключение СтрокаИсключения;
	КонецЕсли;
	
	Кэш.Вставить(ИмяПараметра, НайденноеЗначение);
	КэшИзменен = Истина;
	
	Возврат НайденноеЗначение;
	
КонецФункции

Процедура УстановитьЗначениеПеременной(ИмяПараметра, Кэш, ЗначениеПараметра, ОбновлятьВоВсехКэшах = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	КонецЕсли;
	
	Если Кэш.Свойство(ИмяПараметра) Тогда
		Кэш.Вставить(ИмяПараметра, ЗначениеПараметра);
	КонецЕсли;
	
	#Если Клиент ИЛИ ВнешнееСоединение Тогда
		Если ОбновлятьВоВсехКэшах Тогда
			Кэш = ПараметрыСеанса.ОбщиеЗначения.Получить();
			Кэш.Вставить(ИмяПараметра, ЗначениеПараметра);
			ПараметрыСеанса.ОбщиеЗначения = Новый ХранилищеЗначения(Кэш);
		КонецЕсли;
	#КонецЕсли
	
КонецПроцедуры

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт
	
	Если ЗнакЧисла = Неопределено Тогда
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
	Иначе
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;
	
	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);
	
КонецФункции // ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт
	
	Возврат Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная));
	
КонецФункции // ПолучитьОписаниеТиповСтроки()	 





////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ

// Функция возвращает имя табличной части, к которой принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Строка - имя табличной части, как оно задано в конфигураторе
//
Функция ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт
	
	Возврат Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;
	
КонецФункции // ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()

// Функция возвращает метаданные документа, которому принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Метаданные - метаданные документа, как оно задано в конфигураторе
//
Функция ПолучитьМетаданныеДокументаПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт
	
	Возврат Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Родитель();
	
КонецФункции // ПолучитьМетаданныеДокументаПоСсылкеНаСтроку()


//МЦТ

// Проверить легальность получения обновления.
//
// Параметры
//  ТекущаяВерсияИБ  - Строка - номер версии ИБ.
//
// Возвращаемое значение:
//   Булево   - Истина, если проверка завершилась успешно.
//
Функция ПроверитьЛегальностьПолученияОбновления(Знач ТекущаяВерсияИБ) Экспорт
	
	#Если Клиент Тогда
		
		
		Если ПланыОбмена.ГлавныйУзел() <> Неопределено Тогда
			Возврат Истина;
		КонецЕсли;
		
		Если ТекущаяВерсияИБ <> Метаданные.Версия И ТекущаяВерсияИБ <> "" Тогда
			Форма = Обработки.ЛегальностьПолученияОбновлений.ПолучитьФорму();
			Форма.ПоказыватьПредупреждениеОПерезапуске = Истина;
			Результат = Форма.ОткрытьМодально();
			Если Результат <> Истина Тогда
				ЗавершитьРаботуСистемы(Ложь);
				Возврат Ложь;
			КонецЕсли; 
		КонецЕсли;
	#КонецЕсли
	Возврат Истина;
	
КонецФункции

// Функция преобразует строку к множественному числу
//
// Параметры: 
//  Слово1 - форма слова в ед числе      ("шкаф")
//  Слово2 - форма слова для числит 2-4  ("шкафа")
//  Слово3 - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - целое число
//
// Возвращаемое значение:
//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
//
// Описание:
//  Предназначена для формирования "правильной" подписи к числительным
//
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, ЦелоеЧисло) Экспорт
	
	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ


// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	Иначе
		Возврат Новый (ЗаданныйТип);
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

// Определяет заполнено ли переданное значение
// В качестве значения, допускается передавать только значение с примитивным типом(Булево, Дата, Строка, Число, Null, Неопределено),
// с типом "Режим проведения документа" или ссылочным типом.
//
// Параметры: 
//  Значение - значение, заполенение которого надо проверить
//
// Возвращаемое значение:
//  Истина - значение не заполнено, ложь - иначе.
//
Функция ЗначениеНЕЗаполнено(Значение) Экспорт
	
	Результат = Ложь;
	ТипЗначения = ТипЗнч(Значение);
	
	// Сначала примитивные типы
	Если Значение = Неопределено Тогда
		Результат = Истина;
	ИначеЕсли Значение = NULL Тогда
		Результат = Истина;
	ИначеЕсли ТипЗначения = Тип("Строка") Тогда
		Если СокрЛП(Значение) = "" Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Число") Тогда
		Если Значение = 0 Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		Если Значение = Дата('00010101') Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Булево") Тогда
		Результат = Ложь; // Булево будем считать не пустым
		
		//Отдельное определение, так как конструкторов данного типа не существует	
	ИначеЕсли ТипЗначения = Тип("РежимПроведенияДокумента") Тогда
		Если Значение = РежимПроведенияДокумента.Неоперативный или Значение = РежимПроведенияДокумента.Оперативный тогда
			Результат = Ложь;
		КонецЕсли;
		
		// Для остальных будем считать значение пустым, если оно равно
		// дефолтному значению своего типа
	Иначе
		Попытка
			Если Значение = Новый(ТипЗначения) Тогда
				Результат = Истина;
			КонецЕсли; 
		Исключение
			Результат = Ложь;
		КонецПопытки;
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции // НЕ ЗначениеЗаполнено()

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт
	
	Если МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 
	
КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли табличная часть документа с переданным именем.
//
// Параметры: 
//  ИмяТабЧасти - строковое имя искомой табличной части,
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьТабЧастьДокумента(ИмяТабЧасти, МетаданныеДокумента) Экспорт
	
	Если МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 
	
КонецФункции // ЕстьТабЧастьДокумента()

// Позволяет определить есть ли среди реквизитов шапки отчета
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита     - строковое имя искомого реквизита, 
//  МетаданныеОтчета - метаданные отчета, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитОтчета(ИмяРеквизита, МетаданныеОтчета) Экспорт
	
	Если МетаданныеОтчета.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 
	
КонецФункции // ЕстьРеквизитОтчета()

// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт
	
	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
	Если ТабЧасть = Неопределено Тогда // Нет такой таб. части в документе
		Возврат Ложь;
	Иначе
		Если ТабЧасть.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
			Возврат Ложь;
		Иначе
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции // ЕстьРеквизитТабЧастиДокумента()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Истина;
	КонецЕсли;
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	Длина = СтрДлина(СтрокаПроверки);
	
	Для а = 1 По Длина Цикл
		Если Найти("0123456789", Сред(СтрокаПроверки, а, 1)) = 0 Тогда
			Возврат Истина;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// функция определяет есть ли хотя бы одна не цифра в строке
Функция ЕстьНеЦифрыВСтроке(Знач СтрокаПроверки) Экспорт
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Истина;
		КонецЕсли; 
	КонецЦикла; 
	
	Возврат Ложь;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ


// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт
	
	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));
	
КонецФункции	// ПолучитьОписаниеТиповДаты() 

// Служебная функция - возвращает принадлежность объекта метаданных определенному классу
// 
// Параметры:
//	Класс  - класс
//	Объект - объект метаданных
// 
Функция ПринадлежностьКлассуМетаданных(Класс, Объект) Экспорт
	Для Каждого МДОбъект Из Метаданные[Класс] Цикл
		Если МДОбъект = Объект Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции // ПринадлежностьКлассуМетаданных()

// Служебная функция, предназначенная для получения описания типов набора записей по объекту метаданных
// Параметры:
//	Объект - объект метаданных
//
// Возвращаемое значение:
// Описание типов с единственным типом набора записей
//
Функция ПолучитьОписаниеТиповНабораЗаписей(Объект) Экспорт
	
	Массив = Новый Массив;
	Если ПринадлежностьКлассуМетаданных("РегистрыРасчета", Объект) Тогда
		Массив.Добавить(Тип("РегистрРасчетаНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыБухгалтерии", Объект) Тогда
		Массив.Добавить(Тип("РегистрБухгалтерииНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыНакопления", Объект) Тогда
		Массив.Добавить(Тип("РегистрНакопленияНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыСведений", Объект) Тогда
		Массив.Добавить(Тип("РегистрСведенийНаборЗаписей."+Объект.Имя));
	КонецЕсли;
	Возврат Новый ОписаниеТипов(Массив);
	
КонецФункции  // ПолучитьОписаниеТиповНабораЗаписей()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ


// Сравнивает два массива однотипных значений (кроме коллекций значений)
//
// Параметры: 
//  ПервыйМассив,ВторойМассив - сравниваемые массивы
//
// Возвращаемое значение:
//  булево.
//
Функция МассивыИдентичны(ПервыйМассив,ВторойМассив) Экспорт
	
	ЭлементовМассива = ПервыйМассив.Количество();
	МассивыСовпадают = (ЭлементовМассива = ВторойМассив.Количество()); 
	
	Если МассивыСовпадают Тогда
		Для Сч = 1 По ЭлементовМассива Цикл
			Если ПервыйМассив[Сч-1] <> ВторойМассив[Сч-1] Тогда
				Возврат Ложь
			КонецЕсли;
		КонецЦикла; 		
	КонецЕсли;
	
	Возврат МассивыСовпадают
	
КонецФункции // МассивыИдентичны()

// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1
Функция ВернутьИндексВМассиве(МассивДанные, Элемент) Экспорт 
	
	Если МассивДанные = Неопределено Тогда
		Возврат -1;
	КонецЕсли;
	
	Для ИндексЭлемента = 0 По МассивДанные.ВГраница() Цикл
		
		Если  (МассивДанные[ИндексЭлемента] = Элемент) Тогда
			Возврат ИндексЭлемента;
		КонецЕсли;	
		
	КонецЦикла;
	
	// не нашли элемент
	Возврат -1;
	
КонецФункции

//Удалает повторяющиеся элементы массива.
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМасссиве = Новый Соответствие; 
		БылоНеопределено = Ложь;
		
		КолвоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл 
			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента = ТипЗнч(ЭлементМассива); 
			Если ЭлементМассива = Неопределено Тогда
				Если БылоНеопределено или НеИспользоватьНеопределено Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				Продолжить;
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) Тогда
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМасссиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМасссиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

// Удаление из массива пустых элементов
//
// Параметры:
//   МассивЭлементов - Массив
//
Процедура УдалитьНеЗаполненныеЭлементыМассива(МассивЭлементов) Экспорт
	
	Колво = МассивЭлементов.Количество();
	Для н=1 По Колво Цикл
		Если НЕ ЗначениеЗаполнено(МассивЭлементов[Колво-н]) Тогда
			МассивЭлементов.Удалить(Колво-н);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
//  ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УНИВЕРСАЛЬНЫМИ КОЛЛЕКЦИЯМИ ЗНАЧЕНИЙ


// Создает копию переданного массива, структуры или соответствия
//
// Параметры:
//  КоллекцияИсходная: тип Массив, Структура, Соответствие - исходная коллекция
// Возвращаемое значение:
//  КоллекцияКопия:  тип Массив, Структура, Соответствие - копия исходной коллекции
//
Функция СкопироватьУниверсальнуюКоллекцию(КоллекцияИсходная) Экспорт
	
	Если ТипЗнч(КоллекцияИсходная)=Тип("Массив") Тогда
		
		КоллекцияКопия=Новый Массив;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Добавить(Элемент);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Структура") Тогда
		
		КоллекцияКопия=Новый Структура;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия; 
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Соответствие") Тогда
		
		КоллекцияКопия=Новый Соответствие;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	Иначе
		
		Сообщить("Неверный тип универсальной коллекции для копирования");
		Возврат Неопределено
		
	КонецЕсли;
	
КонецФункции // СкопироватьУниверсальнуюКоллекцию()

// Отбирает из переданной таблицы строки по заданным критериям.
//
// Параметры:
//  Источник - ТаблицаЗначений, РезультатЗапроса, ОбластьЯчеекТабличногоДокумента. Таблица-источник.
//  СтруктураКритериев - Структура. Названия отборов и значения, по которым нужно отобрать строки.
//  СтруктураСложныхКритериев - Структура. Если свойство передано, то значение содержит вид сравнения.
//
// Возвращаемое значение:
//  РезультатЗапроса - таблица с нужными строками.
//
Функция ОтобратьСтрокиПоКритериям(Источник, СтруктураКритериев, СтруктураСложныхКритериев = Неопределено) Экспорт
	
	Перем ВидСравненияСложный;
	
	Если СтруктураСложныхКритериев = Неопределено Тогда
		СтруктураСложныхКритериев = Новый Структура;
	КонецЕсли;
	
	ПостроительЗапроса = Новый ПостроительЗапроса;
	ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(Источник);
	
	Для Каждого Критерий Из СтруктураКритериев Цикл
		НовыйОтбор = ПостроительЗапроса.Отбор.Добавить(Критерий.Ключ);
		
		СтруктураСложныхКритериев.Свойство(Критерий.Ключ, ВидСравненияСложный);
		
		Если ВидСравненияСложный = Неопределено Тогда
			НовыйОтбор.Установить(Критерий.Значение);
		Иначе
			НовыйОтбор.Использование = Истина;
			НовыйОтбор.ВидСравнения = ВидСравненияСложный;
			НовыйОтбор.Значение = Критерий.Значение;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПостроительЗапроса.Результат;
	
КонецФункции // ОтобратьСтрокиПоКритериям()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ НАСТРОЙКИ ПОРЯДКА ЭЛЕМЕНТОВ СПРАВОЧНИКА


// Вспомогательная функция для определнения условий запроса в механизме
// изменения порядка следования элементов. Ставит условия на родителя и владельца
//
// Параметры
//  Элемент - СправочникСсылка, для которого необходимо изменить порядок
//  Запрос - Запрос, в который дописываем условия
// 
//  Возвращаемое значение:
//   Строка - условие запроса
// 
Функция ПолучитьДополнениеЗапроса(Элемент, Запрос, БезПервогоИ = Ложь)
	
	ТекстЗапроса = "";
	
	Если Элемент.Метаданные().Иерархический = Истина Тогда
		Запрос.УстановитьПараметр("ТекущийРодитель", Элемент.Родитель);
		Если НЕ БезПервогоИ Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Родитель = &ТекущийРодитель
		|";
	КонецЕсли; 
	
	Если Элемент.Метаданные().Владельцы.Количество() > 0 Тогда
		Запрос.УстановитьПараметр("ТекущийВладелец", Элемент.Владелец);
		Если НЕ (ПустаяСтрока(ТекстЗапроса) И БезПервогоИ) Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Владелец = &ТекущийВладелец
		|";
	КонецЕсли; 
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Возвращает значение порядка для нового элемента справочника.
//
// Параметры
//  ЭлементОбъект - СправочникОбъект - новый объект
//
// Возвращаемое значение:
//   Число - новый порядок
//
Функция НазначитьНовыйПорядок(ЭлементОбъект)
	
	ИмяТаблицы = ЭлементОбъект.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	СправочникПорядка.Порядок
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка";
	
	ДополнениеЗапроса = ПолучитьДополнениеЗапроса(ЭлементОбъект, Запрос, Истина);
	
	Если НЕ ПустаяСтрока(ДополнениеЗапроса) Тогда
		Запрос.Текст = Запрос.Текст + "
		|ГДЕ
		|" + ДополнениеЗапроса + "
		|";
	КонецЕсли; 
	
	Запрос.Текст = Запрос.Текст + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок УБЫВ
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат (Выборка.Порядок + 1)
	КонецЕсли; 
	
КонецФункции

// Процедура вызывается перед записью объекта, для которого необходимо
// контролировать порядок элементов.
// 
// Параметры
//  Отказ - Булево, отказ от записи объекта
//  ЭтотОбъект - СправочникОбъект
//  КонтролироватьПорядок - Булево, контролировать порядок при записи объекта или нет
//
Процедура ПередЗаписьюОбъектаПорядка(Отказ, ЭтотОбъект, КонтролироватьПорядок) Экспорт
	
	Если ЭтотОбъект.ЭтоНовый() Тогда
		ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
	Иначе
		Если ЭтотОбъект.Ссылка.Родитель <> ЭтотОбъект.Родитель ИЛИ ЭтотОбъект.Ссылка.Владелец <> ЭтотОбъект.Владелец Тогда
			ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
		КонецЕсли;
	КонецЕсли;
	
	Если КонтролироватьПорядок Тогда
		
		ИмяТаблицы = ЭтотОбъект.Метаданные().Имя;
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ЭтотОбъект.Порядок);
		
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Порядок
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок = &ТекущийПорядок
		|";
		
		Если НЕ ЭтотОбъект.ЭтоНовый() Тогда
			Запрос.УстановитьПараметр("ТекущаяСсылка", ЭтотОбъект.Ссылка);
			Запрос.Текст = Запрос.Текст + "
			|И
			|	СправочникПорядка.Ссылка <> &ТекущаяСсылка
			|";
		КонецЕсли; 
		
		Запрос.Текст = Запрос.Текст + ПолучитьДополнениеЗапроса(ЭтотОбъект, Запрос);
		
		Если НЕ Запрос.Выполнить().Пустой() Тогда
			Отказ = Истина;
			#Если Клиент Тогда
				Сообщить("Не уникальный порядок элемента справочника.");
			#КонецЕсли
		КонецЕсли;
		
	КонецЕсли; 
	
КонецПроцедуры

// Процедура изменяет порядок следования объектов с настраиваемым из ВЯ
// порядком следования.
// 
// Параметры:
//  ЭлементСсылка - СправочникСсылка, элемент для которого необходимо изменить порядок
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
Процедура ИзменитьПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг = Истина) Экспорт
	
	ЭлементЗамены = ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг);
	
	Если ЭлементЗамены = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НовыйПорядокЗамены   = ЭлементЗамены.Порядок;
	НовыйПорядокЭлемента = ЭлементСсылка.Порядок;
	
	Если НаправлениеПорядка = "Вверх" Тогда
		Если НовыйПорядокЗамены < НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены + 1;
		КонецЕсли; 
	Иначе
		Если НовыйПорядокЗамены > НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены - 1;
		КонецЕсли;
	КонецЕсли;
	
	НачатьТранзакцию();
	
	ФиксироватьТранзакцию = Истина;
	
	Если НовыйПорядокЗамены <> ЭлементЗамены.Порядок Тогда
		ОбъектЗамены = ЭлементЗамены.ПолучитьОбъект();
		ОбъектЗамены.Порядок = НовыйПорядокЗамены;
		ОбъектЗамены.КонтролироватьПорядок = Ложь;
		Попытка
			ОбъектЗамены.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли; 
	
	Если ФиксироватьТранзакцию Тогда
		ОбъектЭлемента = ЭлементСсылка.ПолучитьОбъект();
		ОбъектЭлемента.Порядок = НовыйПорядокЭлемента;
		Попытка
			ОбъектЭлемента.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Если ФиксироватьТранзакцию Тогда
		ЗафиксироватьТранзакцию();
	Иначе
		ОтменитьТранзакцию();
	КонецЕсли; 
	
КонецПроцедуры

// Функция определяет элемент справочника, с которым необходимо
// произвести "рокировку" текущего элемента
//
// Параметры
//  ЭлементСсылка - СпраовочникСсылка, элемент для изменения порядка
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
// Возвращаемое значение:
//   СправочникСсылка
//
Функция ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг)
	
	ТекущийПорядок = ЭлементСсылка.Порядок;
	
	ИмяТаблицы = ЭлементСсылка.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	СправочникПорядка.Ссылка
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
	|ГДЕ
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "<", ">") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
		
	ИначеЕсли ЦиклическийСдвиг Тогда
		// Текущий элемент или первый (при движении вверх)
		// или последний (при движении вниз)
		// или вообще единственный
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
		
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Ссылка
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", ">", "<") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
		|УПОРЯДОЧИТЬ ПО
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
		|";
		
		РезультатЗапроса = Запрос.Выполнить();
		
		Если РезультатЗапроса.Пустой() Тогда
			Возврат Неопределено;
		Иначе
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			Возврат Выборка.Ссылка;
		КонецЕсли; 
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Формирует сообщение при ошибках проведения документов.
//
// Параметры: 
//  ТекстСообщения - Исходный текст, выводимого сообщения,
//  Отказ          - Флаг отказа в проведении докумета,
//  Заголовок      - Заголовок начала серии сообщений об ошибках проведения (не обязательный)
//
Процедура ОшибкаПриПроведении(ТекстСообщения, Отказ, Заголовок="") Экспорт
	
	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок);
	
КонецПроцедуры // ОшибкаПриПроведении()

// Формирует строку представления документа для сообщений при проведении.
//
// Параметры:
//  СтруктураШапкиДокумента - структура шапки документа.
//
// Возвращаемое значение
//  Строка с представлением документа.
//
Функция ПредставлениеДокументаПриПроведении(СтруктураШапкиДокумента) Экспорт
	
	Если СтруктураШапкиДокумента.Свойство("ВидОперации") Тогда
		ВидОперацииСтр = " (" + СтруктураШапкиДокумента.ВидОперации + ")";
	Иначе
		ВидОперацииСтр = "";
	КонецЕсли;
	
	Возврат "Проведение документа: " + СтруктураШапкиДокумента.ПредставлениеДокумента + ВидОперацииСтр;
	
КонецФункции // ПредставлениеДокументаПриПроведении()

// Проверяет принадлежность документа к видам учета
//
// Параметры: 
//  СтруктураШапкиДокумента - структура, содержащая реквизиты шапки документа
//  Отказ                   - флаг отказа в проведении.
//  Заголовок               - строка, заголовок сообщения об ошибке проведения.
//  МожетБытьТолькоНалоговый- строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь) Экспорт
	
	Перем Упр, Бух;
	
	ЕстьУпр = СтруктураШапкиДокумента.Свойство("ОтражатьВУправленческомУчете", Упр);
	ЕстьБух = СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете", Бух);
	
	Если ЕстьУпр ИЛИ ЕстьБух Тогда
		Если Упр <> Истина И Бух <> Истина  Тогда
			СообщитьОбОшибке("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"" и (или)  ""Бухгалтерский"".", Отказ, Заголовок);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

#Если Клиент Тогда
	
	// Процедура возвращает паспортные данные физлица в виде строки
	//
	// Параметры: 
	//  ФизЛицо - ссылка на элемент справочника "Физические лица",по которму необходимо
	//            получить паспортные данные.
	//
	// Возвращаемое значение:
	//  Строка с данными об удостоверении личности физичского лица
	//
	Функция ПолучитьПаспорныеДанныеСтрокой(ФизЛицо) Экспорт
		
		СтруктураПаспортныхДанных	= РегистрыСведений.ПаспортныеДанныеФизЛиц.ПолучитьПоследнее(РабочаяДата, Новый Структура("ФизЛицо",ФизЛицо));
		ВидДокумента				= СтруктураПаспортныхДанных.ДокументВид;
		Серия						= СтруктураПаспортныхДанных.ДокументСерия;
		Номер						= СтруктураПаспортныхДанных.ДокументНомер;
		ДатаВыдачи					= СтруктураПаспортныхДанных.ДокументДатаВыдачи;
		КемВыдан					= СтруктураПаспортныхДанных.ДокументКемВыдан;
		
		Если НЕ (НЕ ЗначениеЗаполнено(ДатаВыдачи)
			И НЕ ЗначениеЗаполнено(ВидДокумента)
			И НЕ ЗначениеЗаполнено(Серия + Номер + КемВыдан)) Тогда
			
			Возврат ?(ВидДокумента.Пустая(),"","" + ВидДокумента + ", ") 
			+ "Серия: " + Серия + ", № " + Номер 
			+ ", Выдан: " + Формат(ДатаВыдачи,"ДФ='дд ММММ гггг'") + " года, " 
			+ КемВыдан;				
		Иначе
			Возврат "Отсутствуют данные об удостоверении личности."
		КонецЕсли;
		
	КонецФункции // ПолучитьПаспорныеДанныеСтрокой()
	
#КонецЕсли

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ


// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт
	
	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;
	
КонецФункции // ПолучитьСписокЭлементовПеречисления()

// Предназначена для получения имени элемента перечисления по значению.
//
// Параметры:
//	Элемент перечисления.
//
// Возвращаемое значение:
//	Строка - имя элемента перечисления в метаданных.
//
Функция ПолучитьИмяЭлементаПеречисленияПоЗначению(ЗначениеПеречисления) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ЗначениеПеречисления) Тогда
		Возврат "";
	КонецЕсли;
	
	МетаданныеЗначения = ЗначениеПеречисления.Метаданные(); 
	ИмяЗначения = МетаданныеЗначения.ЗначенияПеречисления.Получить(Перечисления[МетаданныеЗначения.Имя].Индекс(ЗначениеПеречисления)).Имя;
	
	Возврат ИмяЗначения;
	
	
КонецФункции // ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()

////////////////////////////////////////////////////////////////////////////////
// ОБЩИЕ ПРОЦЕДУРЫ ЗАПОЛНЕНИЯ ДОКУМЕНТОВ


// Процедура предназначена для заполнения общих реквизитов документов,
// котрые необходимо заполнять в лбом случае, не зависимо от того, введен ли документ копированием, 
// на основании или "обычным" способом.
//
// Параметры:
//  ДокументОбъект                 - объект редактируемого документа,
//  ТекПользователь                - ссылка на справочник, определяет текущего пользователя  
//
Процедура ЗаполнитьОбязательныеРеквизитыШапкиНовогоДокумента(ДокументОбъект, ТекПользователь) Экспорт
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	//Если ЕстьРеквизитДокумента("Ответственный", МетаданныеДокумента) Тогда
	//  ДокументОбъект.Ответственный = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойОтветственный");
	//КонецЕсли;
	
КонецПроцедуры // ЗаполнитьОбязательныеРеквизитыШапкиНовогоДокумента()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ


// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	// Заполним значения в совпадающих колонках.
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл
		
		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);
		
	КонецЦикла;
	
КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

// Проверяет наличие требуемых данных в источнике и Формирует таблицу значений
//
// Параметры
//  Источник  – ТаблицаЗначений или ТабличнаяЧасть или КоллекцияСтрокДереваЗначений с исходными данными
//
//  Реквизиты – структура – Структура реквизитов. 
//							Ключ 		- Наименование колонки в источнике
//							Значение    - Наименование колонки в получаемой ТЗ
//							Если значение опущено - приравнивается ключу.
//	ПолучитьНомерСтрокиДокумента - булево
//	                        Используется только при выгрузке из табличной части документа.
//							В формируемой таблице создает новую колонку "НомерСтрокиДокумента"
//								и заполняет её реальными номерами строк
//
//  КоллекцияКолонокДереваЗначений - только для коллекции строк дерева значений.
// Возвращаемое значение:
//  Таблица значений или Неопределено (если не хватает реквизитов)
//
Функция СформироватьТаблицуЗначений(Источник,Реквизиты=Неопределено,ПолучитьНомерСтрокиДокумента = ложь,ФормироватьОтстутствующиеКолонки=Ложь,КоллекцияКолонокДереваЗначений=Неопределено) экспорт
	
	ЭтоТаблицаЗначений=(ТипЗнч(Источник)= тип("ТаблицаЗначений"));
	ЭтоСтрокиДереваЗначений=(ТипЗнч(Источник)= тип("КоллекцияСтрокДереваЗначений"));
	Если ЭтоСтрокиДереваЗначений и КоллекцияКолонокДереваЗначений = Неопределено тогда
		Возврат Неопределено;
	Конецесли;
	
	Если НЕ ЗначениеЗаполнено(Реквизиты) тогда
		Если ЭтоТаблицаЗначений тогда
			НоваяТЗ = Источник.Скопировать();
			Возврат НоваяТЗ;
		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			Реквизиты = Новый Структура();
			Для каждого Колонка из КоллекцияКолонокДереваЗначений цикл
				Реквизиты.Вставить(Колонка.Имя);
			КонецЦикла;
		Иначе
			НоваяТЗ = Источник.Выгрузить();
			Возврат НоваяТЗ;
		КонецЕслИ;
	Конецесли;
	
	Если не ЭтоТаблицаЗначений  и не ЭтоСтрокиДереваЗначений тогда
		РеквизитыТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(Источник)).Реквизиты;
	Конецесли;
	
	НоваяТЗ= Новый ТаблицаЗначений();
	
	Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
		НоваяТЗ.Колонки.Добавить("НомерСтрокиДокумента",ПолучитьОписаниеТиповЧисла(5,0));
	КонецЕсли;
	
	Пока НоваяТЗ.Количество()<Источник.Количество() Цикл
		Строка = НоваяТЗ.Добавить();
		Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
			Строка.НомерСтрокиДокумента = НоваяТЗ.Количество();
		КонецЕсли;
	КонецЦикла;
	
	Для каждого ТекРеквизит из Реквизиты Цикл
		ИскомыйРеквизит = ТекРеквизит.Ключ;
		НовыйРеквизит 	= ?(ТекРеквизит.Значение = Неопределено,ТекРеквизит.Ключ,ТекРеквизит.Значение);
		Если ЭтоТаблицаЗначений тогда
			ИсточникКолонка = Источник.Колонки.Найти(ИскомыйРеквизит);
		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			ИсточникКолонка = КоллекцияКолонокДереваЗначений.Найти(ИскомыйРеквизит);
		Иначе
			ИсточникКолонка = РеквизитыТабличнойЧасти.Найти(ИскомыйРеквизит);
		Конецесли;
		Если ИсточникКолонка= неопределено тогда
			//недостаточно реквизитов
			Если ФормироватьОтстутствующиеКолонки тогда
				НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			Иначе
				Возврат Неопределено;
			КонецЕсли;	
		Иначе
			НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			НоваяТЗ.ЗагрузитьКолонку(Источник.ВыгрузитьКолонку(ИскомыйРеквизит),НовыйРеквизит);
		Конецесли;
	КонецЦикла;
	
	Возврат НоваяТЗ;
КонецФункции // СформироватьТаблицуОплаты()

Процедура ДополнитьКолонкиТаблицыЗначений(ТаблицаБазовая,ТаблицаДополнений) Экспорт
	
	Для каждого Колонка из ТаблицаДополнений.Колонки Цикл
		
		Если Не(ТаблицаБазовая.Колонки.Найти(Колонка.Имя) = Неопределено) тогда
			//Колонка уже есть
			Продолжить;
		КонецЕсли;
		
		ТаблицаБазовая.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,Колонка.Заголовок,Колонка.Ширина);
		
	КонецЦикла;
	
КонецПроцедуры

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт
	
	ВалютаРегламентированногоУчета = Константы.ВалютаУчета.Получить();
	
	СтруктураШапкиДокумента = Новый Структура;
	СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Дата", ДокументОбъект.Дата);
	СтруктураШапкиДокумента.Вставить("Номер",  ДокументОбъект.Номер);
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	СтруктураШапкиДокумента.Вставить("ВидДокумента",  МетаданныеДокумента.Имя);
	СтруктураШапкиДокумента.Вставить("ПредставлениеВидаДокумента",  МетаданныеДокумента.Представление());
	СтруктураШапкиДокумента.Вставить("ПредставлениеДокумента", СокрЛП(ДокументОбъект));
	
	ИмяДокумента = МетаданныеДокумента.Имя;
	Для каждого Реквизит из МетаданныеДокумента.Реквизиты Цикл
		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
	КонецЦикла;
	СтруктураШапкиДокумента.Вставить("ВидДокумента",  ИмяДокумента);
	
	//Отображение данных о валютах
	СтруктураШапкиДокумента.Вставить("ВалютаРегламентированногоУчета", ВалютаРегламентированногоУчета);	
	
	Если СтруктураШапкиДокумента.Свойство("ВалютаДокумента") Тогда
		СтруктураШапкиДокумента.Вставить("КурсДокумента",      ЗаполнениеДокументов.КурсДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));
		СтруктураШапкиДокумента.Вставить("КратностьДокумента", ЗаполнениеДокументов.КратностьДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));
		
	КонецЕсли;
	
	
	//Отображение обязательных данных о договоре
	Если СтруктураШапкиДокумента.Свойство("ДоговорКонтрагента") Тогда
		
		Если ТипЗнч(СтруктураШапкиДокумента.ДоговорКонтрагента) = Тип("СправочникСсылка.ДоговорыКонтрагентов") тогда
			СтруктураШапкиДокумента.Вставить("ВедениеВзаиморасчетов",    СтруктураШапкиДокумента.ДоговорКонтрагента.ВедениеВзаиморасчетов);
			СтруктураШапкиДокумента.Вставить("ВалютаВзаиморасчетов",     СтруктураШапкиДокумента.ДоговорКонтрагента.ВалютаВзаиморасчетов);
			СтруктураШапкиДокумента.Вставить("Внешнеэкономический",      СтруктураШапкиДокумента.ДоговорКонтрагента.Внешнеэкономический);
		КонецЕсли;
		
	КонецЕсли;	
	
	Возврат СтруктураШапкиДокумента;
	
КонецФункции // СформироватьСтруктуруШапкиДокумента()

// Формирует структуру дерева значений, содержащего имена полей, которые
// нужно заполнить в запросе по шапке документа.
//
// Параметры: 
//  Нет.
//
// Возвращаемое значение:
//  Дерево значений.
//
Функция СформироватьДеревоПолейЗапросаПоШапке()  Экспорт
	
	ДеревоПолейЗапросаПоШапке = Новый ДеревоЗначений;
	
	ОписаниеТиповСтрока = ОбщегоНазначения.ПолучитьОписаниеТиповСтроки(100);
	
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Объект"   , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Поле"     , ОписаниеТиповСтрока);
	ДеревоПолейЗапросаПоШапке.Колонки.Добавить("Псевдоним", ОписаниеТиповСтрока);
	
	Возврат ДеревоПолейЗапросаПоШапке;
	
КонецФункции // СформироватьДеревоПолейЗапросаПоШапке()

// Вставляет строку в дерево полей запроса по шапке, если ее там еще нет,
// если есть, то ничего не делает.
//
// Параметры:
//  ДеревоПолейЗапросаПоШапке - дерево значений, содержащего имена полей, 
//                              которые нужно заполнить в запросе по шапке документа, 
//  ИмяОбъекта                - строка, имя объекта (справочник, регистр и т.д.), 
//  ИмяПоля                   - строка, имя поля объекта,
//  ИмяПсевдонима             - строка, имя псевдонима в запросе поля объекта (необязательный).
//
Процедура ДобавитьСтрокуВДеревоПолейЗапросаПоШапке(ДеревоПолейЗапросаПоШапке, ИмяОбъекта, ИмяПоля, ИмяПсевдонима = Неопределено) Экспорт
	
	// Поищем нужную строку.
	// Вначале ищем объект.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти(ИмяОбъекта, "Объект");
	
	Если СтрокаОбъекта = Неопределено Тогда // нужно добавить.
		
		СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Добавить();
		СтрокаОбъекта.Объект    = ИмяОбъекта;
		СтрокаОбъекта.Поле      = ИмяПоля;
		СтрокаОбъекта.Псевдоним = ИмяПсевдонима;
		
		
	КонецЕсли;
	
	// Ищем поле.
	СтрокаПоля = СтрокаОбъекта.Строки. Найти(ИмяПоля,"Поле");
	
	Если СтрокаПоля = Неопределено Тогда // нужно добавить
		
		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();
		
		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;
		
	КонецЕсли;
	
	// Ищем псевдоним.
	СтрокаПоля = СтрокаОбъекта.Строки.Найти( ИмяПсевдонима, "Псевдоним");
	
	Если СтрокаПоля = Неопределено Тогда // нужно добавить
		
		СтрокаПоля = СтрокаОбъекта.Строки.Добавить();
		
		СтрокаПоля.Поле      = ИмяПоля;
		СтрокаПоля.Псевдоним = ИмяПсевдонима;
		
	КонецЕсли;
	
КонецПроцедуры // ДобавитьСтрокуВДеревоПолейЗапросаПоШапке()

// По переданной структуре полей формирует запрос по табличной части документа.
//
// Параметры: 
//  ДокументОбъект        - объект проводимого документа, 
//  ИмяТабличнойЧасти     - строка, имя табличной части,
//  СтруктураПолей        - структура, ключ структуры содержит псевдоним поля запроса, значение - строку запроса,
//  СтруктураСложныхПолей - структура, ключ структуры содержит псевдоним поля запроса, значение - строку запроса,
//                          необязательный параметр, служит для передачи конструкций типа "ВЫБОР" и т.д.
//
// Возвращаемое значение:
//  Результат запроса.
//
Функция СформироватьЗапросПоТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, СтруктураПолей,
	СтруктураПростыхПолей = Неопределено,
	СтруктураСложныхПолей = Неопределено) Экспорт
	
	Запрос = Новый Запрос;
	
	ТекстЗапроса = "";
	
	ДокументМетаданные = ДокументОбъект.Метаданные();
	
	Для Каждого Реквизит Из СтруктураПолей Цикл
		
		ТекстЗапроса  = ТекстЗапроса + ",
		|Док." + Реквизит.Значение + 
		?(НЕ ЗначениеЗаполнено(Реквизит.Ключ), "", " КАК " + СокрЛП(Реквизит.Ключ));
		
	КонецЦикла;
	
	ТекстСоединение="";
	
	Запрос = Новый Запрос;
	
	Если ТипЗнч(СтруктураПростыхПолей) = Тип("Структура") Тогда // Добавим к запросу конструкции.
		НомерПараметра = 0;
		Для Каждого Элемент Из СтруктураПростыхПолей Цикл
			Если НЕ ЗначениеЗаполнено(Элемент.Ключ) Тогда
				Продолжить;
			КонецЕсли;
			НомерПараметра = НомерПараметра + 1;
			Если ВРЕГ(Элемент.Ключ) = "ПРОЕКТ" Тогда
				ТекстЗапроса  = ТекстЗапроса + ",
				| " + Элемент.Значение + 
				" КАК " + СокрЛП(Элемент.Ключ);
			Иначе	
				ТекстЗапроса  = ТекстЗапроса + ",
				| &ПараметрЗапроса" + НомерПараметра + " КАК " + СокрЛП(Элемент.Ключ);
				Запрос.УстановитьПараметр("ПараметрЗапроса" + НомерПараметра, Элемент.Значение);
			КонецЕсли;
			
		КонецЦикла;
		
		Если СтруктураПростыхПолей.Свойство("Проект") Тогда
			
			ТекстСоединение="
			|ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.УстановкаПроектовДляНоменклатуры.СрезПоследних(&ДатаДок, НоменклатураПроекта В (ВЫБРАТЬ Номенклатура ИЗ Документ." + ДокументМетаданные.Имя + "."+ СокрЛП(ИмяТабличнойЧасти) + " ГДЕ Ссылка = &ДокументСсылка)) КАК ПроектыНоменклатуры
			|ПО Док.Номенклатура=ПроектыНоменклатуры.НоменклатураПроекта";
			
			Запрос.УстановитьПараметр("ДатаДок",ДокументОбъект.Дата);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ТипЗнч(СтруктураСложныхПолей) = Тип("Структура") Тогда // Добавим к запросу конструкции.
		
		Для Каждого Элемент Из СтруктураСложныхПолей Цикл
			
			ТекстЗапроса  = ТекстЗапроса + ",
			| " + Элемент.Значение + 
			" КАК " + СокрЛП(Элемент.Ключ);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Запрос.Текст = "ВЫБРАТЬ 
	| Док.НомерСтроки " + ТекстЗапроса + "
	| ИЗ 
	|      Документ." + ДокументМетаданные.Имя + "."+ СокрЛП(ИмяТабличнойЧасти) + 
	" КАК Док"+ТекстСоединение+" 
	|     ГДЕ Док.Ссылка = &ДокументСсылка";
	
	
	// Установим параметры запроса.
	Запрос.УстановитьПараметр("ДокументСсылка" , ДокументОбъект.Ссылка);
	
	Если ДокументОбъект[ИмяТабличнойЧасти].Количество() = 0 Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ГДЕ Док.Ссылка = &ДокументСсылка", "ГДЕ ЛОЖЬ");
	КонецЕсли;
	
	Возврат Запрос.Выполнить();
	
КонецФункции // СформироватьЗапросПоТабличнойЧасти()

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений               - набор движений регистра,
//  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
//  реквизитов составного типа, которые могут содержать пустые ссылки.
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено,
	ПустыеКолонкиСоставногоТипа = Неопределено, ЗаполнитьПериод = истина) Экспорт
	
	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
		ПустыеКолонкиСоставногоТипа = Новый Структура;
	КонецЕсли;
	
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если (МетаИзм.Тип.Типы().Количество() > 1)
			И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
		Если (МетаРек.Тип.Типы().Количество() > 1)
			И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРек.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если (МетаРес.Тип.Типы().Количество() > 1)
			И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРес.Имя);
		КонецЕсли;
	КонецЦикла;
	
	// Откопируем остальные колонки (структура таблиц совпадает).
	ПерваяКолонка = Истина;
	МассивСтрок   = Новый Массив(ТаблицаДвижений.Количество());
	ЕстьПериод    = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;
	Для каждого Колонка Из ТаблицаДвижений.Колонки Цикл
		
		ИмяКолонки = Колонка.Имя;
		Если ИмяКолонки <> "Период"
			И ИмяКолонки <> "Активность"
			И ИмяКолонки <> "НомерСтроки"
			И ИмяКолонки <> ""
			И ?(ИмяКолонки = "ВидДвижения", ВидДвижения = Неопределено, Истина)
			И ИмяКолонки <> "МоментВремени" Тогда
			
			Если ИзмеренияСостТипа.Свойство(ИмяКолонки) Тогда
				ФлагКолонкиСостТипа = Истина;
			Иначе
				ФлагКолонкиСостТипа = Ложь;
			КонецЕсли;
			
			Индекс = 0;
			Для каждого СтрокаТаблицы Из ТаблицаДвижений Цикл
				
				Если ПерваяКолонка Тогда
					
					Если ВидДвижения = ВидДвиженияНакопления.Приход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьПриход();
					ИначеЕсли ВидДвижения = ВидДвиженияНакопления.Расход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьРасход();
					Иначе
						СтрокаДвижения = НаборДвижений.Добавить(); // Для оборотных регистров
					КонецЕсли;
					
					МассивСтрок[Индекс] = СтрокаДвижения;
					СтрокаДвижения.Период = НаборДвижений.мПериод;
					Если не ЗаполнитьПериод и ЕстьПериод И НЕ СтрокаТаблицы.Период = '00010101' Тогда
						СтрокаДвижения.Период = СтрокаТаблицы.Период;
					Иначе
						СтрокаДвижения.Период = НаборДвижений.мПериод;
					КонецЕсли; 
					
				Иначе
					
					СтрокаДвижения = МассивСтрок[Индекс];
					
				КонецЕсли;
				
				Индекс = Индекс + 1;
				
				ЗначКолонки = СтрокаТаблицы[ИмяКолонки];
				Если ФлагКолонкиСостТипа Тогда
					
					Очистить = Ложь;
					Если ТипЗнч(ЗначКолонки) = Тип("Число")Тогда
						Если ЗначКолонки = 0 Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Строка") Тогда
						Если ЗначКолонки = "" Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Дата") Тогда
						Если ЗначКолонки = '00010101000000' Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ЗначКолонки = Неопределено Или ЗначКолонки.Пустая() Тогда
						Очистить = Истина;
					КонецЕсли;
					
					Если Очистить Тогда
						СтрокаДвижения[ИмяКолонки] = Неопределено;
					Иначе
						СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
					КонецЕсли;
				Иначе
					СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
				КонецЕсли;
				
			КонецЦикла;
			
			ПерваяКолонка = Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Процедура сворачивает движения по регистру накопления
//
Процедура СвернутьТаблицуДвиженийРегистраНакопления(НаборДвижений, ТабДвижений = Неопределено, УдалятьПустыеДвижения = Ложь) Экспорт
	
	Если ТипЗнч(НаборДвижений) = Тип("Строка") Тогда
		МетаРег = Метаданные.РегистрыНакопления[НаборДвижений];
		ТаблицаДвижений = ТабДвижений;
	Иначе
		МетаРег = НаборДвижений.Метаданные();
		Если ТабДвижений = Неопределено Тогда
			ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
		Иначе
			ТаблицаДвижений = ТабДвижений;
		КонецЕсли;
	КонецЕсли;
	
	
	Если ТаблицаДвижений = Неопределено ИЛИ ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Измерения = "Период,Регистратор,Активность";
	Если МетаРег.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
		Измерения = Измерения + ",ВидДвижения";
	КонецЕсли;
	
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Измерения = Измерения + "," + МетаИзм.Имя;
	КонецЦикла;
	Для Каждого МетаИзм Из МетаРег.Реквизиты Цикл
		Измерения = Измерения + "," + МетаИзм.Имя;
	КонецЦикла;
	
	Ресурсы = "";
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Ресурсы = Ресурсы + МетаРес.Имя + ",";
	КонецЦикла;
	
	ТаблицаДвижений.Свернуть(Измерения, Ресурсы);
	
	Если УдалятьПустыеДвижения Тогда
		
		СтруктРесурсы   = Новый Структура(Ресурсы);
		МассивПустСтрок = Новый Массив;
		СтруктПоиска    = Новый Структура;
		
		Для Каждого РесурсКлюч Из СтруктРесурсы Цикл
			СтруктПоиска.Вставить( РесурсКлюч.Ключ, 0);
		КонецЦикла;
		
		МассивПустСтрок = ТаблицаДвижений.НайтиСтроки(СтруктПоиска);
		Для К = 0 По МассивПустСтрок.ВГраница() Цикл
			ТаблицаДвижений.Удалить(МассивПустСтрок[К]);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры // СвернутьТаблицуДвиженийРегистраНакопления()

// Получить движение(набор записей) для документа-объекта
//
// Параметры
//  Объект  – 	ДокументОбъект – Документ. для которого производится поиск движения
//  ТипДвижения  – Регистр<...>Менеджер – менеджер регистра, движение по которому пытаемся сформировать
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей   – набор записей для объекта
//
Функция ПолучитьДвижение(Объект, ТипДвижения, Сообщать=Ложь) Экспорт
	Движение = неопределено;
	Для каждого ТекДвижение из Объект.Движения цикл
		Если ТипЗнч(ТипДвижения.СоздатьНаборЗаписей()) = ТипЗнч(ТекДвижение) тогда
			Движение=ТекДвижение;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Сообщать и Движение = неопределено тогда
		СообщитьОбОшибке("Требуется подключение """+ТипЗНЧ(Объект)+""" к формированиям движения по регистру """+ТипЗнч(ТипДвижения)+"""!");
	КонецЕсли;
	Возврат Движение;
КонецФункции // ПолучитьДвижение()

// Получить набор записей по регистру по ссылке на документ
//
// Параметры
//  Ссылка  		– ДокументСсылка		– Ссылка на документ, для которого производится поиск движений по регистру (набора записей)
//  РегистрДвижения – Регистр<...>Менеджер	– менеджер регистра, движение по которому пытаемся обнаружить
//  ПрочитатьЗаписи - Булево 				- Прочитать существующий набор записей для документа (если документ может формировать движения по указанному регистру).
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей – Набор записей по регистру с отбором по документу,
//	 Неопределено 				в случае если документ не может формировать движений по регистру.
//
Функция ПолучитьНаборЗаписейПоСсылке(Ссылка, РегистрДвижения, ПрочитатьЗаписи = Ложь, Сообщать=Ложь) Экспорт
	Движения = неопределено;
	Если Ссылка.Метаданные().Движения.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(РегистрДвижения))) тогда
		Движения = РегистрДвижения.СоздатьНаборЗаписей();
		Движения.Отбор.Регистратор.Установить(Ссылка);
		Если ПрочитатьЗаписи тогда
			Движения.Прочитать();
		КонецЕсли;
	ИначеЕсли Сообщать тогда
		СообщитьОбОшибке("Требуется подключение документа """+Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).Представление()+""" к формированию движений по регистру """+
		СтрЗаменить(Лев(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":"))," менеджер","")+Сред(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":")+1)+
		"""!");
	КонецЕсли;
	
	Возврат Движения;
КонецФункции // ПолучитьДвижение()

// Процедура переименовывает колонку таблицы значений, с сохранением истории переименований для возможности последующего "отката"
//
//	Параметры:
//		- ТабЗначений - таблица значений в которой производится переименование колонок
//		- ТабИмен - таблица с историей переименований. Новые сведения о переименованных колонках добавляются сюда и возвращаются в вызвавшую процедуру
//		- ТекИмяКолонки - имя колонки которую надо переименовать
//		- НовоеИмяКолонки - новое имя колонки. Если параметр не задан, новое имя присваивается автоматически
//
Процедура ПереименоватьКолонкуТаблицыЗначений(ТабЗначений, ТабИмен, Знач ТекИмяКолонки, Знач НовоеИмяКолонки = "") Экспорт
	
	Если ТабИмен = Неопределено Тогда
		ТабИмен = Новый ТаблицаЗначений;
		ТабИмен.Колонки.Добавить("НовИмя", Новый ОписаниеТипов("Строка"));
		ТабИмен.Колонки.Добавить("ТекИмя",   Новый ОписаниеТипов("Строка"));
	КонецЕсли;
	
	ТекКолонка = ТабЗначений.Колонки.Найти(ТекИмяКолонки);
	Если ПустаяСтрока(НовоеИмяКолонки) Тогда
		// Генерируем новое имя для старой колонки, гарантируя что оно будет уникальным
		Индекс = 1;
		Пока Истина Цикл
			НовоеИмяКолонки = "_" + Строка(Индекс) + "_" + ТекИмяКолонки;
			Если ТабЗначений.Колонки.Найти(НовоеИмяКолонки) = Неопределено Тогда
				Прервать;
			КонецЕсли;
			Индекс = Индекс + 1;
		КонецЦикла;
		// После выхода из цикла в переменной НовоеИмяКолонки должны получить новое имя колонки,
	Иначе
		// проверим, что нового имя колонки еще нет в таблице, если есть 
		// переименуем его в новое уникальное имя и добавим в таблицу имен
		Если ТабЗначений.Колонки.Найти(НовоеИмяКолонки) <> Неопределено Тогда
			НовоеИмяНовойКолонки = "";
			Индекс = 1;
			Пока Истина Цикл
				НовоеИмяНовойКолонки = "_" + Строка(Индекс) + "_" + НовоеИмяКолонки;
				Если ТабЗначений.Колонки.Найти(НовоеИмяНовойКолонки) = Неопределено Тогда
					Прервать;
				КонецЕсли;
				Индекс = Индекс + 1;
			КонецЦикла;
			// После выхода из цикла в переменной НовоеИмяНовойКолонки должны получить новое имя, 
			// в которое можно переименовать НовоеИмяКолонки, переименуем его и добавим в таблицу имен
			ТабЗначений.Колонки[НовоеИмяКолонки].Имя = НовоеИмяНовойКолонки;
			// Сохраним имя колонки в таб. имен
			НоваяСтрока = ТабИмен.Добавить();
			НоваяСтрока.НовИмя = НовоеИмяНовойКолонки;
			НоваяСтрока.ТекИмя = НовоеИмяКолонки;
		КонецЕсли;
	КонецЕсли;
	
	// Переименуем колонку
	ТабЗначений.Колонки[ТекИмяКолонки].Имя = НовоеИмяКолонки;
	
	// Сохраним имя колонки в таб. имен
	НоваяСтрока = ТабИмен.Добавить();
	НоваяСтрока.НовИмя = НовоеИмяКолонки;
	НоваяСтрока.ТекИмя = ТекИмяКолонки;
	
КонецПроцедуры // ПереименоватьКолонкуТаблицыЗначений()

// Процедура восстанавливает имена колонок таблицы значений, сохраненные в процедуре ПереименоватьКолонкуТаблицыЗначений()
//
//	Параметры:
//		- ТабЗначений - таблица значений в которой производится переименование колонок
//		- ТабИмен - таблица с историей переименований, таблица создается и заполняется в процедуре ПереименоватьКолонкуТаблицыЗначений()
//
Процедура ВосстановитьИменаКолонокТаблицыЗначений(ТабЗначений, ТабИмен) Экспорт
	
	К = ТабИмен.Количество() - 1;
	Пока К >= 0 Цикл
		ТекСтрока = ТабИмен[К];
		ТабЗначений.Колонки[ТекСтрока.НовИмя].Имя = ТекСтрока.ТекИмя;
		К = К - 1;
	КонецЦикла;
	
	ТабИмен.Очистить();
	
КонецПроцедуры // ВосстановитьИменаКолонокТаблицыЗначений()

////////////////////////////////////////////////////////////////////////////////
// МАТЕМАТИКА


Функция ШестнадцатиричноеВДесятичное(Источник) Экспорт
	
	Результат = 0;
	
	Для Поз = 1 По СтрДлина(Источник) Цикл
		ТекКод = КодСимвола(Источник, Поз);
		
		Если ТекКод >= КодСимвола("0") И ТекКод <= КодСимвола("9") Тогда
			ТекКод = ТекКод - КодСимвола("0");
		ИначеЕсли ТекКод >= КодСимвола("a") И ТекКод <= КодСимвола("f") Тогда
			ТекКод = ТекКод +10 - КодСимвола("a");
		ИначеЕсли ТекКод >= КодСимвола("A") И ТекКод <= КодСимвола("F") Тогда
			ТекКод = ТекКод +10 - КодСимвола("A");
		КонецЕсли;
		
		Результат = Результат * 16 + ТекКод;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ДесятичноеВШестнадцатиричное(Источник) Экспорт
	
	ШеснадцатиричныеСимволы = "0123456789ABCDEF";
	
	Если Источник < 0 Тогда
		Возврат "00";
	КонецЕсли;
	Если Источник > 255 Тогда
		Возврат "FF";
	КонецЕсли;
	
	ПервыйСимвол	= Цел(Источник / 16) + 1;
	ВтройСимвол		= Источник % 16;
	
	Возврат Сред(ШеснадцатиричныеСимволы, ПервыйСимвол, 1) + Сред(ШеснадцатиричныеСимволы, ВтройСимвол, 1);
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОЧИХ ПОДСИСТЕМ, НЕ ИМЕЮЩИХ СВОИХ ОБЩИХ МОДУЛЕЙ


// Позволяет просматривать веб-страницы в обработке Обозреватель  
//
// Параметры
//  АдресСтраницы  – Строка – адрес просматриваемой страницы
//
// Если передается пустая строка, то в обработке Обозреватель 
// просматривается веб-страница конфигурации
// 
Процедура ПоказатьВебСтраницу(АдресСтраницы) Экспорт
	
	Обозреватель = Обработки.Обозреватель.Создать();
	
	Форма = Обозреватель.ПолучитьФорму();
	Форма.СтартоваяСтраница = АдресСтраницы;
	
	Форма.Открыть();
	
КонецПроцедуры

// Стандартная для данной конфигурации функция форматирования сумм
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт
	
	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
	?(НЕ ЗначениеЗаполнено(ЧН), "", ";" + "ЧН=" + ЧН) +
	?(НЕ ЗначениеЗаполнено(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если ЗначениеЗаполнено(Валюта) Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;
	
	Возврат РезультирующаяСтрока;
	
КонецФункции // ФорматСумм()

// Возвращает рабочую дату
//
// Возвращаемое значение:
//   Дата - рабочая дата
//
Функция ПолучитьРабочуюДату() Экспорт
	
	#Если Клиент Тогда
		Дата = РабочаяДата;
	#Иначе
		Дата = ТекущаяДата();
	#КонецЕсли
	
	Возврат Дата;
	
КонецФункции // ПолучитьРабочуюДату()

// Возвращает строку, описывающую период, определяемый переданными
// датой и периодичностью.
//
// Параметры
//  ДатаВПериоде:Дата - дата из периода
//  Периодичность: Строка - строка, определяющая периодичность
//
// Возвращаемое значение:
//   СтрокаПериод: строка   – представление периода для вывода в отчетах
//
Функция ПолучитьПериодСтрокой(ДатаВПериоде,Периодичность) Экспорт
	
	Если Периодичность = "Год" Тогда
		ФорматДаты = "ДФ = ""гггг """"г.""""""";
	ИначеЕсли Периодичность = "Квартал" Тогда
		ФорматДаты = "ДФ = ""к"""" квартал"""" гггг """"г.""""""";
	ИначеЕсли Периодичность = "Месяц" Тогда
		ФорматДаты = "ДФ = ""ММММ гггг """"г.""""""";
	ИначеЕсли Периодичность = "Неделя" Тогда
		ФорматДаты = "ДФ = """"""Неделя с"""" дд.ММ.гггг """"""";
	ИначеЕсли Периодичность = "День" Тогда
		ФорматДаты = "ДФ = ""дд.ММ.гггг """"г.""""""";
	Иначе
		ФорматДаты = "";
	КонецЕсли;
	
	СтрокаПериод = "" + Формат(ДатаВПериоде, ФорматДаты);
	Если Периодичность = "Неделя" И ТипЗнч(ДатаВПериоде) = Тип("Дата") Тогда
		СтрокаПериод = СтрокаПериод + Формат(КонецНедели(ДатаВПериоде), "ДФ = """""" по """" дд.ММ.гггг """"г.""""""");
	КонецЕсли;
	
	Возврат СтрокаПериод;
	
КонецФункции // ПолучитьПериодСтрокой()

// Функция возвращает структуру с параметрами учетной политики (налоговый учет)
//
Функция ПолучитьПараметрыУчетнойПолитикиНалоговыйУчет(Знач КонДата, Отказ,Организация) Экспорт
	
	СтруктураУчПолитика = Новый Структура;
	Если НЕ ЗначениеЗаполнено(Организация) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;
		
	ИначеЕсли НЕ ЗначениеЗаполнено(КонДата) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;	
		
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	УчетнаяПолитикаСрезПоследних.*
	|ИЗ
	|	РегистрСведений.УчетнаяПолитикаНалоговыйУчет.СрезПоследних(&КонДата, Организация = &Организация) КАК УчетнаяПолитикаСрезПоследних";	
	
	Запрос.УстановитьПараметр("КонДата", КонДата);
	Запрос.УстановитьПараметр("Организация", Организация);
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		СообщитьОбОшибке("Не заполнен регистр сведений ""Учетная политика (налоговый учет)"" для организации """+Организация+"""на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
		
	Иначе
		
		РезультатЗапроса = РезультатЗапроса.Выгрузить();
		
		Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
			СтруктураУчПолитика.Вставить(Колонка.Имя, РезультатЗапроса[0][Колонка.Имя]);
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат СтруктураУчПолитика;
	
КонецФункции // ПолучитьПараметрыУчетнойПолитикиНалоговыйУчет()


// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//  ИсхСумма   - распределяемая сумма
//  МассивКоэф - массив коэффициентов распределения
//  Точность   - точность округления при распределении. Необязателен.
//
//Возвращает:
//  МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//               суммы в соответствии с весом коэффициента (из массива коэффициентов)
//               В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//               или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина) Экспорт
	
	Если МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		
		МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);
		
		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач = МодульЧисла;
			ИндексМакс = К;
		КонецЕсли;
		
		СуммаКоэф = СуммаКоэф + МассивКоэф[К];
		
	КонецЦикла;
	
	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСумм = Новый Массив(МассивКоэф.Количество());
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		РаспрСумма = РаспрСумма + МассивСумм[К];
	КонецЦикла;
	
	// Погрешности округления отнесем на коэффицент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;
	
	Возврат МассивСумм;
	
КонецФункции // РаспределитьПропорционально()

// Возвращает головную организацию для заданной организации
// Если для организации реквизит ГоловнаяОрганизация не заполнен 
// это значит, что сама организация является голвной
//
// Параметры
//  Организация – СправочникСсылка.Организации
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   СправочникСсылка.Организации
//
Функция ГоловнаяОрганизация(Организация) Экспорт
	
	Если Организация.Пустая() ИЛИ Организация.ГоловнаяОрганизация.Пустая() Тогда
		Возврат Организация;
		
	Иначе
		Возврат Организация.ГоловнаяОрганизация;
		
	КонецЕсли;
	
КонецФункции // ГоловнаяОрганизация()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ИНТЕРНЕТ-ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Получаем из полного номера версии конфигурации номер релиза без номера сборки.
//
// Параметры
//  НомерВерсии  – Строка – полный номер версии
//
// Возвращаемое значение:
//  Строка – номер релиза без номера сборки
//
Функция ПолучитьНомерРелиза(НомерВерсии) Экспорт
	
	КоличествоТочек = 0;
	ДлинаОписанияНомераРелиза = 0;
	
	Для х = 1 По СтрДлина(НомерВерсии) Цикл
		
		Если Сред(НомерВерсии, х, 1) = "." Тогда
			КоличествоТочек = КоличествоТочек + 1;
		КонецЕсли;
		
		Если КоличествоТочек = 3 Тогда
			ДлинаОписанияНомераРелиза = х - 1;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Лев(НомерВерсии, ДлинаОписанияНомераРелиза);
	
КонецФункции // ПолучитьНомерРелиза()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ


// Функнция проверяет заполнения обязательных параметров для отправки сообщения
//  в отдел технической поддержки.
//
// Параметры
//  ТаблицаДанных - Таблица значений
//
// Возвращаемое значение:
//   Булево - результат корректости проверки
//
Функция ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(ТаблицаДанных, ПубликоватьСообщения = Истина) Экспорт
	
	ЗначениеПроверки = Истина;
	СтрокаЗаголовкаОшибки = "Не заполнены настройки для отправки сообщения.";
	
	СписокИменОбязательныхРеквизитов = Новый СписокЗначений;
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтправителя");
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресCервераSMTP");
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_ПортSMTP");
	СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");
	СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");
	
	Для каждого СтрокаРаздела Из ТаблицаДанных Цикл
		Для каждого ЭлементЗначения Из СтрокаРаздела.ДанныеРаздела Цикл
			Если СписокИменОбязательныхРеквизитов.НайтиПоЗначению(ЭлементЗначения.Ключ) <> Неопределено И НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
				Если ПубликоватьСообщения Тогда
					СообщитьОбОшибке("Не указан """ + Лев(ЭлементЗначения.Значение[0], (СтрДлина(ЭлементЗначения.Значение[0]) - 1)) + """.",, СтрокаЗаголовкаОшибки);
				КонецЕсли; 
				ЗначениеПроверки = Ложь;
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
	Возврат ЗначениеПроверки;
	
КонецФункции // ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()

// Процедура формирует таблицу значений со структурой для заполнения данными
// с информацией обращения в отдел технической поддержки
//
// Параметры:
//  ТаблицаДанных - таблица значений для заполнения
//  ФормаНастройкиПараметров - общая форма настройки параметров для отправки в отдел технической поддержки
//
Процедура ЗаполнитьСтруктуруДанныхНастройкиОбращенияВОтделТехподдержкиПоУмолчанию(ТаблицаДанных, ФормаНастройкиПараметров = Неопределено) Экспорт
	
	// Структура данных - таблица значений:
	//  Колонки:
	//   ИмяРездела
	//   ПредставлениеРаздела
	//   ДанныеРаздела
	
	// Структура данных раздела
	//  Ключ - Имя значения настройки, как оно задано в форме настройки параметров обращения
	//  Значение - Массив значений
	// 
	// Массив значений:
	//  [0] - Представление наименования параметра для печати
	//  [1] - Значение параметра
	
	Если ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений") Тогда
		ТаблицаДанных = Новый ТаблицаЗначений;
	КонецЕсли;
	
	Если ТаблицаДанных.Колонки.Количество() = 0 Тогда
		ТаблицаДанных.Колонки.Добавить("ИндексСортировки"    , Новый ОписаниеТипов("Число"));
		ТаблицаДанных.Колонки.Добавить("ИмяРаздела"          , Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ПредставлениеРаздела", Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ДанныеРаздела"       , Новый ОписаниеТипов("Структура"));
	КонецЕсли; 
	ТаблицаДанных.Индексы.Добавить("ИмяРаздела");
	
	Если ФормаНастройкиПараметров = Неопределено Тогда
		ФормаНастройкиПараметров = ПолучитьОбщуюФорму("НастройкаПараметровОбращенияВОтделТехническойПоддержки");
	КонецЕсли;
	
	Для каждого ЭлементФормы Из ФормаНастройкиПараметров.ЭлементыФормы Цикл
		
		Если ТипЗнч(ЭлементФормы) <> Тип("ПолеВвода")
			И ТипЗнч(ЭлементФормы) <> Тип("ПолеВыбора")
			И ТипЗнч(ЭлементФормы) <> Тип("Флажок") Тогда
			Продолжить;
		КонецЕсли;
		
		ПозицияРазделителяРаздела = Найти(ЭлементФормы.Имя, "_");
		Если ПозицияРазделителяРаздела = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяРаздела = Сред(ЭлементФормы.Имя, 1, (ПозицияРазделителяРаздела - 1));
		СтрокаРаздела = ТаблицаДанных.Найти(ИмяРаздела, "ИмяРаздела");
		Если СтрокаРаздела = Неопределено Тогда
			СтрокаРаздела = ТаблицаДанных.Добавить();
			СтрокаРаздела.ИмяРаздела           = ИмяРаздела;
			Попытка
				СтрокаРаздела.ПредставлениеРаздела = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела].Заголовок;
				СтрокаРаздела.ИндексСортировки     = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы.Индекс(ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела]);
			Исключение
				СтрокаРаздела.ПредставлениеРаздела = ИмяРаздела;
			КонецПопытки;
		КонецЕсли;
		
		МассивЗначений = Новый Массив;
		Попытка
			Если ТипЗнч(ЭлементФормы) = Тип("Флажок") Тогда
				МассивЗначений.Добавить((ЭлементФормы.Заголовок + ":"));
			Иначе
				МассивЗначений.Добавить(ФормаНастройкиПараметров.ЭлементыФормы["Надпись_" + ЭлементФормы.Имя].Заголовок);
			КонецЕсли; 
		Исключение
			МассивЗначений.Добавить(ЭлементФормы.Имя);
		КонецПопытки;
		МассивЗначений.Добавить("");
		
		СтрокаРаздела.ДанныеРаздела.Вставить(ЭлементФормы.Имя, МассивЗначений);
		
	КонецЦикла;
	
	ТаблицаДанных.Сортировать("ИндексСортировки ВОЗР");
	
КонецПроцедуры

// Функция формирует текст сообщения на линию техподдержки
//
// Параметры
//  НЕТ
//
// Возвращаемое значение:
//   Текст сообщения
//
Функция ПолучитьТекстСообщенияВОтделТехническойПоддержки() Экспорт
	
	ТекстВозврата = "";
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "============ Сведения об использовании ПП 1С:Предприятие 8 ============";
	
	ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();
	
	// Сформируем обязательный информационный раздел
	
	СистемИнфо = Новый СистемнаяИнформация;
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8: " + СистемИнфо.ВерсияПриложения;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия конфигурации: "       + Метаданные.Версия;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;
	
	НомерСтрокиРаздела = 1;
	
	Если ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицыРаздела Из ТаблицаДанных Цикл
			
			СтрокаРаздела = "";
			
			Если СтрокаТаблицыРаздела.ИмяРаздела = "ПараметрыОтправкиЭлектронногоСообщения" Тогда
				Продолжить;
			КонецЕсли;
			
			Для каждого ЭлементЗначения Из СтрокаТаблицыРаздела.ДанныеРаздела Цикл
				Если НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
					Продолжить;
				КонецЕсли; 
				СтрокаРаздела = СтрокаРаздела + Символы.ПС + ЭлементЗначения.Значение[0] + " " + ?(ТипЗнч(ЭлементЗначения.Значение[1]) = Тип("Булево"), ?(ЭлементЗначения.Значение[1], "Да", "Нет"), ЭлементЗначения.Значение[1]);
			КонецЦикла; 
			
			Если НЕ ЗначениеЗаполнено(СтрокаРаздела) Тогда
				Продолжить;
			КонецЕсли;
			
			НомерСтрокиРаздела = НомерСтрокиРаздела + 1;
			
			СтрокаРаздела = Строка(НомерСтрокиРаздела) + ". " + ВРег(СтрокаТаблицыРаздела.ПредставлениеРаздела) + СтрокаРаздела;
			
			ТекстВозврата = ТекстВозврата + Символы.ПС;
			ТекстВозврата = ТекстВозврата + Символы.ПС + СтрокаРаздела;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ТекстВозврата;
	
КонецФункции // ПолучитьТекстСообщенияВОтделТехническойПоддержки()

Функция ПолучитьОсновнойДоговорКонтрагента(Контрагент) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	ДоговорыКонтрагентов.Ссылка КАК ДоступныйДоговорКонтрагента,
	|	ДоговорыКонтрагентов.Наименование КАК ДоступныйДоговорКонтрагентаНаименование
	|ИЗ
	|	Справочник.ДоговорыКонтрагентов КАК ДоговорыКонтрагентов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
	|		ПО (Контрагенты.Ссылка = &Контрагент)
	|			И Контрагенты.ОсновнойДоговорКонтрагента = ДоговорыКонтрагентов.Ссылка
	|ГДЕ
	|	ДоговорыКонтрагентов.Владелец = &Контрагент
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВЫБОР
	|		КОГДА Контрагенты.ОсновнойДоговорКонтрагента ЕСТЬ NULL 
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ";
	
	Запрос.УстановитьПараметр("Контрагент", Контрагент);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ДоступныйДоговорКонтрагента;		
	Иначе
		Возврат Справочники.ДоговорыКонтрагентов.ПустаяСсылка();		
	КонецЕсли;	
	
КонецФункции

Функция ПолучитьОсновноеКонтактноеЛицоКонтрагента(Контрагент) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	КонтактныеЛицаКонтрагентов.Ссылка КАК ДоступноеКонтактноеЛицоКонтрагента
	|ИЗ
	|	Справочник.КонтактныеЛицаКонтрагентов КАК КонтактныеЛицаКонтрагентов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
	|		ПО (Контрагенты.Ссылка = &Контрагент)
	|			И Контрагенты.ОсновноеКонтактноеЛицо = КонтактныеЛицаКонтрагентов.Ссылка
	|ГДЕ
	|	КонтактныеЛицаКонтрагентов.Владелец = &Контрагент
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВЫБОР
	|		КОГДА Контрагенты.ОсновноеКонтактноеЛицо ЕСТЬ NULL 
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ";
	
	Запрос.УстановитьПараметр("Контрагент", Контрагент);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ДоступноеКонтактноеЛицоКонтрагента;		
	Иначе
		Возврат Справочники.КонтактныеЛицаКонтрагентов.ПустаяСсылка();		
	КонецЕсли;	
	
КонецФункции

// Функция дополняет структуру шапки документа положениями учетной политики.
//
Процедура ДополнитьПоложениямиУчетнойПолитики(СтруктураШапкиДокумента, КонДата, Отказ, Организация, Учет = "Нал", СтруктураПолейУчетнойПолитикиНУ = неопределено) Экспорт
	СтруктураУП = ПолучитьПараметрыУчетнойПолитики(КонДата, Отказ, Организация, Учет);
	
	Для каждого ПараметрУП Из СтруктураУП Цикл
		Если (ТипЗнч(СтруктураПолейУчетнойПолитикиНУ) = Тип("Структура"))
			И НЕ (СтруктураПолейУчетнойПолитикиНУ.Количество() = 0) Тогда
			// Заполнение определенными полями
			Если СтруктураПолейУчетнойПолитикиНУ.Свойство(ПараметрУП.Ключ) Тогда
				Если НЕ ЗначениеЗаполнено(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ]) Тогда
					СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);
				Иначе
					СтруктураШапкиДокумента.Вставить(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ],ПараметрУП.Значение);
				КонецЕсли; 
			КонецЕсли; 
		Иначе	
			// Дополняем всеми параметрами учетной политики
			СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);  
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры // ДополнитьПоложениямиУчетнойПолитики()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ


Процедура УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, ПроверятьДвижения = Ложь)Экспорт
	
	// получение списка последовательностей в которых зарегистрирован документ
	Если ПроверятьДвижения Тогда
		ТаблицаРегистраций = ОпределитьНаличиеРегистрацииДокументаВПоследовательности(ДокументОбъект);
	КонецЕсли;      
	КоллекцияПоследовательностей = ДокументОбъект.ПринадлежностьПоследовательностям;
	Для Каждого НаборЗаписейРегистрацииВПоследовательности ИЗ КоллекцияПоследовательностей Цикл
		Если (НаборЗаписейРегистрацииВПоследовательности.Количество() > 0)
			ИЛИ (ПроверятьДвижения И (НЕ ТаблицаРегистраций.Найти(НаборЗаписейРегистрацииВПоследовательности.Метаданные().Имя,"Имя") = Неопределено)) Тогда
			НаборЗаписейРегистрацииВПоследовательности.Очистить();
			
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры//УдалитьРегистрациюДокументаВПоследовательностях

Функция ОпределитьНаличиеРегистрацииДокументаВПоследовательности(ДокументОбъект) Экспорт
	ТекстЗапроса = "";	
	
	Для Каждого Последовательность ИЗ ДокументОбъект.ПринадлежностьПоследовательностям Цикл
		// в запросе получаем имена последовательностей, в которых документ зарегистрирован
		ТекстЗапроса = ТекстЗапроса + "
		|" + ?(ТекстЗапроса = "", "", "ОБЪЕДИНИТЬ ВСЕ ") + "
		|ВЫБРАТЬ """ + Последовательность.Метаданные().Имя 
		+  """ КАК Имя ИЗ " + Последовательность.Метаданные().ПолноеИмя()  
		+ " ГДЕ Регистратор = &Регистратор";
		
	КонецЦикла;
	
	Если ТекстЗапроса = "" Тогда
		Возврат Новый ТаблицаЗначений();
	Иначе
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.УстановитьПараметр("Регистратор", ДокументОбъект.Ссылка);
		ТаблицаЗапроса = Запрос.Выполнить().Выгрузить();	
		Возврат ТаблицаЗапроса;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ПРЕОБРАЗОВАНИЯ ЗНАЧЕНИЙ


// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции // глРазложить

Функция РазложитьЧислоВСтроку(Значение,Длина,ЛидирующиеНули=Ложь) Экспорт
	
	ФорматнаяСтрока = "ЧЦ="+Строка(Длина)+"; ЧДЦ=0; ЧГ=0";
	Если ЛидирующиеНули Тогда
		Строка0 = "0";
		Для Сч = 2 по Длина Цикл
			Строка0 = Строка0+"0";
		Конеццикла;
		ФорматнаяСтрока = ФорматнаяСтрока + "; ЧН="+Строка0+"; ЧВН=";
	Иначе
		ФорматнаяСтрока = ФорматнаяСтрока + "; ЧН=0";
	КонецЕсли;
	
	Результат = Формат(Значение,ФорматнаяСтрока);
	
	Если НЕ ЛидирующиеНули Тогда
		
		Пока СтрДлина(Результат) < Длина Цикл
			Результат = " "+Результат;
		КонецЦикла;	
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ВЫБОРКИ ДАННЫХ 


// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
//  либо по переданным строкам.
//  Если передан Объект, то извлеченная из него строка считается совокупностью 
//  Фамилия + Имя + Отчество, разделенными пробелами.
//
// Параметры
//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
//  Фамилия		- фамилия физ. лица.
//  Имя			- имя физ. лица.
//  Отчество	- отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
//  отдельным Фамилии,Имени и Отчеству
//
Функция ФамилияИнициалыФизЛица(Объект = "", Фамилия = " ", Имя = " ", Отчество = " ") Экспорт
	
	ТипОбъекта = ТипЗнч(Объект);
	
	Если ТипОбъекта = Тип("Строка") Тогда
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
	ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") или ТипОбъекта = Тип("СправочникОбъект.ФизическиеЛица") Тогда 
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект.Наименование)," ");
	Иначе
		
		// используем возможно переданные отдельные строки
		Возврат ?(НЕ ПустаяСтрока(Фамилия), 
		Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
		"")
		
	КонецЕсли;
	
	КоличествоПодстрок = ФИО.Количество();
	Фамилия  = ?(КоличествоПодстрок > 0,ФИО[0],"");
	Имя      = ?(КоличествоПодстрок > 1,ФИО[1],"");
	Отчество = ?(КоличествоПодстрок > 2,ФИО[2],"");
	
	Возврат ?(НЕ ПустаяСтрока(Фамилия), 
	Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
	"");
	
КонецФункции

// Функция собирает паспортные данные физ. лица на указанную дату
//
// Параметры: 
//  ФизЛицо.    - физ. лицо, для которго необходимо получить паспортные данные
//  ДатаПериода - дата получения сведений
//
// Возвращаемое значение:
//  Структура с паспортными данными.
//
Функция ПаспортныеДанные(ФизЛицо, ДатаПериода) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ПарФизЛицо",     ФизЛицо);
	Запрос.УстановитьПараметр("ПарДатаПериода", ДатаПериода);
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ДокументВид        КАК Вид,
	|	ДокументСерия      КАК Серия,
	|	ДокументНомер      КАК Номер,
	|	ДокументДатаВыдачи КАК ДатаВыдачи,
	|	ДокументКемВыдан   КАК Выдан
	|ИЗ
	|	РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ПарДатаПериода, ФизЛицо = &ПарФизЛицо)
	|ГДЕ
	|	ФизЛицо = &ПарФизЛицо";
	Шапка = Запрос.Выполнить().Выбрать();
	Шапка.Следующий();
	
	Результат = Новый Структура("Вид, Серия, Номер, ДатаВыдачи, Выдан");
	
	Результат.Вид        = Шапка.Вид;
	Результат.Серия      = Шапка.Серия;
	Результат.Номер      = Шапка.Номер;
	Результат.ДатаВыдачи = Шапка.ДатаВыдачи;
	Результат.Выдан      = Шапка.Выдан;
	
	Возврат Результат;
	
КонецФункции // ПаспортныеДанные()

// Добавлено для печати.
// Функция собирает сведения о 
//
// Параметры:
//  Организация - организация, для которой нужно определить руководящих лиц.
//
Функция ОтветственныеЛица(Организация, ДатаСреза) Экспорт
	
	Результат = Новый Структура("Руководитель, РуководительДолжность, РуководительФИО, РуководительПредставление, 
	|ГлавныйБухгалтер, ГлавныйБухгалтерДолжность, ГлавныйБухгалтерФИО, ГлавныйБухгалтерПредставление, 
	|Кассир, КассирДолжность, КассирФИО, КассирПредставление");
	
	Если Организация <> Неопределено тогда
		
		ЗапросПоЛицам = Новый Запрос();
		ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
		ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
		ЗапросПоЛицам.УстановитьПараметр("ПризнакФизЛица",   Перечисления.ЮрФизЛицо.ФизЛицо);
		
		ЗапросПоЛицам.Текст = "
		|ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ФИОФизЛицСрезПоследних.Фамилия,
		|	ФИОФизЛицСрезПоследних.Имя,
		|	ФИОФизЛицСрезПоследних.Отчество,
		|	ФИОФизЛицСрезПоследних.ФизЛицо КАК ФизическоеЛицо
		|ИЗ
		|	РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо ССЫЛКА Справочник.ФизическиеЛица) КАК ФИОФизЛицСрезПоследних
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Организации КАК Организации
		|		ПО ФИОФизЛицСрезПоследних.ФизЛицо = Организации.ИндивидуальныйПредприниматель
		|			И (Организации.Ссылка = &Организация)
		|			И (Организации.ЮрФизЛицо = &ПризнакФизЛица)
		|";
		
		Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
		
		Пока Руководители.Следующий() Цикл
			
			ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление", "", "", "", "");
			Если НЕ ( НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
				ФИО.Фамилия = Руководители.Фамилия;
			КонецЕсли;
			Если НЕ ( НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
				ФИО.Имя = Руководители.Имя;
			КонецЕсли;
			Если НЕ ( НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
				ФИО.Отчество = Руководители.Отчество;
			КонецЕсли;
			Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
			
			Результат.Руководитель               = Руководители.ФизическоеЛицо;
			Результат.РуководительДолжность      = "";
			Результат.РуководительФИО            = ФИО;
			Результат.РуководительПредставление  = Представление;
			
		КонецЦикла;
		
		ЗапросПоЛицам.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ОтветственныеЛицаОрганизаций.ОтветственноеЛицо,
		|	ОтветственныеЛицаОрганизаций.ФизическоеЛицо,
		|	ОтветственныеЛицаОрганизаций.Должность
		|
		|ПОМЕСТИТЬ ОтветственныеЛицаОрганизацийСрезПоследних
		|
		|ИЗ
		|	РегистрСведений.ОтветственныеЛицаОрганизаций.СрезПоследних(&ДатаСреза, СтруктурнаяЕдиница = &Организация) КАК ОтветственныеЛицаОрганизаций
		|;
		|
		|ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ОтветственныеЛицаОрганизацийСрезПоследних.ОтветственноеЛицо,
		|	ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо,
		|	ОтветственныеЛицаОрганизацийСрезПоследних.Должность,
		|	ФИОФизЛицСрезПоследних.Фамилия,
		|	ФИОФизЛицСрезПоследних.Имя,
		|	ФИОФизЛицСрезПоследних.Отчество
		|ИЗ
		|	ОтветственныеЛицаОрганизацийСрезПоследних КАК ОтветственныеЛицаОрганизацийСрезПоследних
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(
		|				&ДатаСреза, 
		|				ФизЛицо ССЫЛКА Справочник.ФизическиеЛица
		|               И ФизЛицо В (ВЫБРАТЬ ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо ИЗ ОтветственныеЛицаОрганизацийСрезПоследних)
		|		) КАК ФИОФизЛицСрезПоследних
		|		ПО ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо = ФИОФизЛицСрезПоследних.ФизЛицо
		|";
		
		Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
		
		Пока Руководители.Следующий() Цикл
			
			ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление", "", "", "", "");
			Если НЕ ( НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
				ФИО.Фамилия = Руководители.Фамилия;
			КонецЕсли;
			Если НЕ ( НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
				ФИО.Имя = Руководители.Имя;
			КонецЕсли;
			Если НЕ ( НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
				ФИО.Отчество = Руководители.Отчество;
			КонецЕсли;
			Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
			
			Если Руководители.ОтветственноеЛицо      = Перечисления.ОтветственныеЛицаОрганизаций.Руководитель Тогда
				Результат.Руководитель               = Руководители.ФизическоеЛицо;
				Результат.РуководительДолжность      = Руководители.Должность;
				Результат.РуководительФИО            = ФИО;
				Результат.РуководительПредставление  = Представление;
				
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер Тогда
				Результат.ГлавныйБухгалтер           = Руководители.ФизическоеЛицо;
				Результат.ГлавныйБухгалтерДолжность  = Руководители.Должность;
				Результат.ГлавныйБухгалтерФИО        = ФИО;
				Результат.ГлавныйБухгалтерПредставление  = Представление;
				
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.Кассир Тогда
				Результат.Кассир                     = Руководители.ФизическоеЛицо;
				Результат.КассирДолжность      		 = Руководители.Должность;
				Результат.КассирФИО            		 = ФИО;
				Результат.КассирПредставление  = Представление;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Функция собирает сведения о 
//
// Параметры:
//  Контрагент - контрагент, для которой нужно определить руководящих лиц.
//
Функция ОтветственныеЛицаКонтрагента(Контрагент, ДатаСреза) Экспорт
	
	Результат = Новый Структура("Руководитель, РуководительДолжность, РуководительФИО, РуководительПредставление, 
	|ГлавныйБухгалтер, ГлавныйБухгалтерДолжность, ГлавныйБухгалтерФИО, ГлавныйБухгалтерПредставление, 
	|Кассир, КассирДолжность, КассирФИО, КассирПредставление");
	
	Если ЗначениеЗаполнено(Контрагент) тогда
		
		ЗапросПоЛицам = Новый Запрос();
		ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
		ЗапросПоЛицам.УстановитьПараметр("Контрагент", Контрагент);
		ЗапросПоЛицам.УстановитьПараметр("ПризнакФизЛица",   Перечисления.ЮрФизЛицо.ФизЛицо);
		
		ЗапросПоЛицам.Текст = "ВЫБРАТЬ
		|	ФИОФизЛицСрезПоследних.Фамилия,
		|	ФИОФизЛицСрезПоследних.Имя,
		|	ФИОФизЛицСрезПоследних.Отчество,
		|	ФИОФизЛицСрезПоследних.ФизЛицо КАК ФизическоеЛицо
		|ИЗ
		|	РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &Контрагент) КАК ФИОФизЛицСрезПоследних
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
		|		ПО ФИОФизЛицСрезПоследних.ФизЛицо = Контрагенты.Ссылка
		|			И (Контрагенты.ЮрФизЛицо = &ПризнакФизЛица)";
		
		Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
		
		Пока Руководители.Следующий() Цикл
			
			ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление", "", "", "", "");
			Если НЕ ( НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
				ФИО.Фамилия = Руководители.Фамилия;
			КонецЕсли;
			Если НЕ ( НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
				ФИО.Имя = Руководители.Имя;
			КонецЕсли;
			Если НЕ ( НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
				ФИО.Отчество = Руководители.Отчество;
			КонецЕсли;
			Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
			
			Результат.Руководитель               = Руководители.ФизическоеЛицо;
			Результат.РуководительДолжность      = "";
			Результат.РуководительФИО            = ФИО;
			Результат.РуководительПредставление  = Представление;
			
		КонецЦикла;
		
		ЗапросПоЛицам.Текст = 
		"ВЫБРАТЬ
		|	ОтветственныеЛицаКонтрагентовСрезПоследних.ОтветственноеЛицо,
		|	ОтветственныеЛицаКонтрагентовСрезПоследних.КонтактноеЛицо,
		|	ОтветственныеЛицаКонтрагентовСрезПоследних.КонтактноеЛицо.Должность КАК Должность,
		|	ОтветственныеЛицаКонтрагентовСрезПоследних.КонтактноеЛицо.КонтактноеЛицо.Фамилия КАК Фамилия,
		|	ОтветственныеЛицаКонтрагентовСрезПоследних.КонтактноеЛицо.КонтактноеЛицо.Имя КАК Имя,
		|	ОтветственныеЛицаКонтрагентовСрезПоследних.КонтактноеЛицо.КонтактноеЛицо.Отчество КАК Отчество
		|ИЗ
		|	РегистрСведений.ОтветственныеЛицаКонтрагентов.СрезПоследних(&ДатаСреза, Контрагент = &Контрагент) КАК ОтветственныеЛицаКонтрагентовСрезПоследних";
		
		Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
		
		Пока Руководители.Следующий() Цикл
			
			ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление", "", "", "", "");
			Если НЕ ( НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
				ФИО.Фамилия = Руководители.Фамилия;
			КонецЕсли;
			Если НЕ ( НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
				ФИО.Имя = Руководители.Имя;
			КонецЕсли;
			Если НЕ ( НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
				ФИО.Отчество = Руководители.Отчество;
			КонецЕсли;
			Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
			
			Если Руководители.ОтветственноеЛицо      = Перечисления.ОтветственныеЛицаОрганизаций.Руководитель Тогда
				Результат.Руководитель               = Руководители.КонтактноеЛицо;
				Результат.РуководительДолжность      = Руководители.Должность;
				Результат.РуководительФИО            = ФИО;
				Результат.РуководительПредставление  = Представление;
				
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер Тогда
				Результат.ГлавныйБухгалтер           = Руководители.КонтактноеЛицо;
				Результат.ГлавныйБухгалтерДолжность  = Руководители.Должность;
				Результат.ГлавныйБухгалтерФИО        = ФИО;
				Результат.ГлавныйБухгалтерПредставление  = Представление;
				
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.Кассир Тогда
				Результат.Кассир                     = Руководители.КонтактноеЛицо;
				Результат.КассирДолжность      		 = Руководители.Должность;
				Результат.КассирФИО            		 = ФИО;
				Результат.КассирПредставление  = Представление;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Функция собирает сведения о 
//
// Параметры:
//  Организация - организация, для которой нужно определить руководящих лиц.
//
Функция ОтветственныеЛицаОбособленногоПодразделения(ОбособленноеПодразделениеОрганизации, ДатаСреза) Экспорт
	
	Результат = Новый Структура("Руководитель, РуководительДолжность, РуководительФИО, РуководительПредставление, 
	|ГлавныйБухгалтер, ГлавныйБухгалтерФИО, ГлавныйБухгалтерПредставление, 
	|Кассир, КассирФИО, КассирПредставление");
	
	Если ОбособленноеПодразделениеОрганизации <> Неопределено тогда
		
		ЗапросПоЛицам = Новый Запрос();
		ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
		ЗапросПоЛицам.УстановитьПараметр("ОбособленноеПодразделениеОрганизации", ОбособленноеПодразделениеОрганизации);
		
		ЗапросПоЛицам.Текст = 
		"ВЫБРАТЬ
		|	ОтветственныеЛицаОрганизацийСрезПоследних.ОтветственноеЛицо,
		|	ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо,
		|	ОтветственныеЛицаОрганизацийСрезПоследних.Должность,
		|	ФИОФизЛицСрезПоследних.Фамилия,
		|	ФИОФизЛицСрезПоследних.Имя,
		|	ФИОФизЛицСрезПоследних.Отчество
		|ИЗ
		|	РегистрСведений.ОтветственныеЛицаОрганизаций.СрезПоследних(&ДатаСреза, СтруктурнаяЕдиница = &ОбособленноеПодразделениеОрганизации) КАК ОтветственныеЛицаОрганизацийСрезПоследних
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза) КАК ФИОФизЛицСрезПоследних
		|		ПО ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо = ФИОФизЛицСрезПоследних.ФизЛицо";
		Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
		
		Пока Руководители.Следующий() Цикл
			
			ФИО = Новый Структура("Фамилия, Имя, Отчество, Представление", "","","","");
			Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
				ФИО.Фамилия = Руководители.Фамилия;
			КонецЕсли;
			Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
				ФИО.Имя = Руководители.Имя;
			КонецЕсли;
			Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
				ФИО.Отчество = Руководители.Отчество;
			КонецЕсли;
			Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
			
			Если Руководители.ОтветственноеЛицо      = Перечисления.ОтветственныеЛицаОрганизаций.Руководитель Тогда
				Результат.Руководитель               = Руководители.ФизическоеЛицо;
				Результат.РуководительДолжность      = Руководители.Должность;
				Результат.РуководительФИО            = ФИО;
				Результат.РуководительПредставление  = Представление;
				
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер Тогда
				Результат.ГлавныйБухгалтер           = Руководители.ФизическоеЛицо;
				Результат.ГлавныйБухгалтерФИО        = ФИО;
				Результат.ГлавныйБухгалтерПредставление  = Представление;
				
			ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.Кассир Тогда
				Результат.Кассир                     = Руководители.ФизическоеЛицо;
				Результат.КассирФИО            		 = ФИО;
				Результат.КассирПредставление  = Представление;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если НЕ ЗначениеЗаполнено(Результат.Кассир) ИЛИ НЕ ЗначениеЗаполнено(Результат.ГлавныйБухгалтер) ИЛИ НЕ ЗначениеЗаполнено(Результат.Руководитель) Тогда
			// Возможно, нужновзять информацию по организации
			Руководители = ОтветственныеЛица(ОбособленноеПодразделениеОрганизации.Владелец, ДатаСреза);
			
			Если НЕ ЗначениеЗаполнено(Результат.Руководитель) Тогда
				
				Результат.Руководитель               = Руководители.Руководитель;
				Результат.РуководительДолжность      = Руководители.РуководительДолжность;
				Результат.РуководительФИО            = Руководители.РуководительФИО;
				Результат.РуководительПредставление  = Руководители.РуководительПредставление;
				
			КонецЕсли;
			
			Если НЕ ЗначениеЗаполнено(Результат.ГлавныйБухгалтер) Тогда
				
				Результат.ГлавныйБухгалтер           = Руководители.ГлавныйБухгалтер;
				Результат.ГлавныйБухгалтерФИО        = Руководители.ГлавныйБухгалтерФИО;
				Результат.ГлавныйБухгалтерПредставление  = Руководители.ГлавныйБухгалтерПредставление;
				
			КонецЕсли;
			
			Если НЕ ЗначениеЗаполнено(Результат.Кассир) Тогда
				
				Результат.Кассир                     = Руководители.Кассир;
				Результат.КассирФИО            		 = Руководители.КассирФИО;
				Результат.КассирПредставление  		 = Руководители.КассирПредставление;
				
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБРАБОТКИ ПОГРЕШНОСТЕЙ ОКРУГЛЕНИЯ


// Выполняет округление числовых значений с накоплением погрешностей округления, образовавшихся
//		в результате предыдущих вызовов функции
//
// Параметры
//  Число 		– Число. Округляемое значение
//  Точность	– Число. Точность округления
//	Погрешность	- Число. Переменная, в которой накапливается погрешность с предыдущих вызовов
//
// Возвращаемое значение:
//   Число   – округленное значение
//
Функция ОкруглитьСУчетомПогрешности(Число, Точность, Погрешность = 0, 
	СоответствиеПогрешностей = Неопределено, Ключ = Неопределено) Экспорт
	
	Если НЕ СоответствиеПогрешностей = Неопределено И ЗначениеЗаполнено(Ключ) Тогда
		
		// считываем погрешность округления, накопленную ранее при расчетах
		Погрешность = СоответствиеПогрешностей[Ключ];
		// погрешности округления еще нет -- первая сумма
		Если Погрешность = Неопределено Тогда
			Погрешность = 0;
		КонецЕсли;
		// округлим с учетом погрешности
		Округленное = ОкруглитьСУчетомПогрешности(Число, Точность, Погрешность);
		// сохраним погрешность округления
		СоответствиеПогрешностей.Вставить(Ключ, Погрешность);
		
	Иначе
		
		Если Число = 0 Тогда
			Возврат 0;
		КонецЕсли; 
		
		// выравнивание разрядности
		Число = Окр(Число, 27, ?(Число<0, РежимОкругления.Окр15как10, РежимОкругления.Окр15как20));
		
		// сумма с учетом погрешности предыдущих вычислений
		Округляемое = Число + Погрешность;
		
		// для отрицательного числа меняем направление округления, чтобы избежать ошибки Окр(-0.5) = -1
		Округленное	= Окр(Округляемое, Точность, ?(Округляемое<0, РежимОкругления.Окр15как10, РежимОкругления.Окр15как20));
		
		// рассчитаем новую погрешность округления
		Погрешность	= Округляемое - Округленное;
		
	КонецЕсли;
	
	Возврат Округленное;
	
КонецФункции // ОкруглитьСУчетомПогрешности()

//Возвращает схему налогообложения Организации на Дату
Функция ПолучитьСхемуНалогообложения(Дата,Организация) Экспорт
	
	УчетнаяПолитикаНУ = РегистрыСведений.УчетнаяПолитикаНалоговыйУчет.ПолучитьПоследнее(Дата, Новый Структура("Организация", Организация));
	Если ЗначениеЗаполнено(УчетнаяПолитикаНУ.СхемаНалогообложения) Тогда
		Возврат УчетнаяПолитикаНУ.СхемаНалогообложения;
	Иначе
		Возврат Справочники.СхемыНалогообложения.НеПлательщик;
	КонецЕсли; 
	
КонецФункции // ПолучитьСхемуНалогообложения()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБНОВЛЕНИЯ КОНФИГУРАЦИИ


Функция ВопросДаНет(ТекстВопроса) Экспорт
	
	#Если Клиент Тогда
		
		КодВозврата = Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Нет);
		
		Возврат (КодВозврата = КодВозвратаДиалога.Да);
		
	#Иначе
		
		Возврат Истина;
		
	#КонецЕсли
	
КонецФункции // ВопросДаНет()

Процедура ПредупреждениеОбОшибке(ТекстСообщения) Экспорт
	
	#Если Клиент Тогда
		
		Предупреждение(ТекстСообщения);
		
	#Иначе
		
		ВызватьИсключение(ТекстСообщения);
		
	#КонецЕсли
	
КонецПроцедуры // ПредупреждениеОбОшибке()

Процедура ЗапуститьПрограмму(ПутьКПрограмме, РабочийКаталог = Неопределено) Экспорт
	
	#Если Клиент Тогда
		
		ЗапуститьПриложение(ПутьКПрограмме, РабочийКаталог);
		
	#КонецЕсли
	
КонецПроцедуры // ЗапуститьПрограмму()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С СТРУКТУРАМИ


Функция ВыгрузитьСтруктуруВСтроку(Структура,ПоЗначениям = Ложь,СтруктураПроверки = Неопределено) Экспорт
	
	НеПроверять = (СтруктураПроверки = Неопределено);
	НоваяСтрока = "";
	
	Для каждого Колонка из Структура Цикл
		
		Если НеПроверять тогда
			НоваяСтрока = НоваяСтрока + ?(НЕ ЗначениеЗаполнено(Колонка.Значение)или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)+",";
			
		ИначеЕсли СтруктураПроверки.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение) или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)) тогда
			НоваяСтрока = НоваяСтрока + ?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+",";
			
		Иначе
			//Нет в проверке!
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если ЗначениеЗаполнено(НоваяСтрока) Тогда
		НоваяСтрока = Лев(НоваяСтрока,СтрДлина(НоваяСтрока)-1);
	КонецЕсли;
	
	Возврат НоваяСтрока;
	
КонецФункции // ВыгрузитьСтруктуруВСтроку

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДАННЫМИ ФИЗЛИЦ


// Функция возвращает совокупность данных о физических лицах в виде таблицы
// значений. В совокупность данных входит ФИО, должность в заданной 
// организации, паспортные данные и др.
//
// Параметры:
//  Организация  - СправочникСсылка.Организации - организация, по которой
//                 определяется должность и подразделение работника(ов)
//  ФизЛицо      - СправочникСсылка.ФизическиеЛица или Массив - физическое лицо
//                 или список физ. лиц, по которым возвращается совокупность 
//                 данных
//  ДатаСреза    - Дата - дата, на которую считываются данные
//
// Возвращаемое значение:
//  ТаблицаЗначений - Таблица с совокупностью данных о физическом лице. 
//                  Колонки: возвращаемой таблицы:
//                  - Фамилия
//                  - Имя
//                  - Отчетсво
//                  - Представление (Фамилия И.О.)
//                  - Подразделение
//                  - ДокументВид
//                  - ДокументСерия
//                  - ДокументНомер
//                  - ДокументДатаВыдачи
//                  - ДокументКемВыдан
//
Функция ДанныеФизЛиц(Организация, ФизЛицо, ДатаСреза) Экспорт
	
	ТабРезультат = Новый ТаблицаЗначений();
	ТабРезультат.Колонки.Добавить("Фамилия");
	ТабРезультат.Колонки.Добавить("Имя");
	ТабРезультат.Колонки.Добавить("Отчество");
	ТабРезультат.Колонки.Добавить("Представление");
	ТабРезультат.Колонки.Добавить("ТабельныйНомер");
	ТабРезультат.Колонки.Добавить("Должность");
	ТабРезультат.Колонки.Добавить("ПодразделениеОрганизации");
	ТабРезультат.Колонки.Добавить("ДокументВид");
	ТабРезультат.Колонки.Добавить("ДокументСерия");
	ТабРезультат.Колонки.Добавить("ДокументНомер");
	ТабРезультат.Колонки.Добавить("ДокументДатаВыдачи");
	ТабРезультат.Колонки.Добавить("ДокументКемВыдан");
	
	ЗапросПоЛицам = Новый Запрос();
	ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
	ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
	ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
	ЗапросПоЛицам.УстановитьПараметр("ОсновноеМестоРаботы", Перечисления.ВидыЗанятостиВОрганизации.ОсновноеМестоРаботы);
	ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ
	|	ФИОФизЛицСрезПоследних.Фамилия,
	|	ФИОФизЛицСрезПоследних.Имя,
	|	ФИОФизЛицСрезПоследних.Отчество,
	|	РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
	|	РаботникиОрганизацийСрезПоследних.Должность,
	|	РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан,
	|	ВЫБОР
	|		КОГДА РаботникиОрганизацийСрезПоследних.Сотрудник.ВидЗанятости = &ОсновноеМестоРаботы
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ КАК Предпочтение
	|
	|ИЗ
	|	РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В(&ФизЛицо)) КАК ФИОФизЛицСрезПоследних
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В(&ФизЛицо)) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|		ПО ФИОФизЛицСрезПоследних.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.РаботникиОрганизаций.СрезПоследних(&ДатаСреза, Сотрудник.ФизЛицо В(&ФизЛицо) И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	|		ПО ФИОФизЛицСрезПоследних.ФизЛицо = РаботникиОрганизацийСрезПоследних.Сотрудник.Физлицо
	|	УПОРЯДОЧИТЬ ПО Предпочтение УБЫВ";
	
	Данные = ЗапросПоЛицам.Выполнить().Выбрать();
	
	Пока Данные.Следующий() Цикл
		
		Результат = ТабРезультат.Добавить();
		
		Результат.Фамилия       			= Данные.Фамилия;
		Результат.Имя      					= Данные.Имя;
		Результат.Отчество      			= Данные.Отчество;
		Результат.Представление 			= ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество);
		
		Результат.ТабельныйНомер  			= Данные.ТабельныйНомер;
		Результат.Должность      			= Данные.Должность;
		Результат.ПодразделениеОрганизации  = Данные.ПодразделениеОрганизации;
		
		Результат.ДокументВид        		= Данные.ДокументВид;
		Результат.ДокументСерия      		= Данные.ДокументСерия;
		Результат.ДокументНомер      		= Данные.ДокументНомер;
		Результат.ДокументДатаВыдачи 		= Данные.ДокументДатаВыдачи;
		Результат.ДокументКемВыдан      	= Данные.ДокументКемВыдан;
		
	КонецЦикла;
	
	Возврат ТабРезультат;
	
КонецФункции // ДанныеФизЛиц

// Функция возвращает совокупность данных о физическом лице в виде структуры, 
// В совокупность данных входит ФИО, должность в заданной организации, 
// паспортные данные и др.
//
// Параметры:
//  Организация  - СправочникСсылка.Организации - организация, по которой
//                 определяется должность и подразделение работника
//  ФизЛицо      - СправочникСсылка.ФизическиеЛица - физическое лицо,
//                 по которому возвращается совокупность данных
//  ДатаСреза    - Дата - дата, на которую считываются данные
//
// Возвращаемое значение:
//  Структура    - Структура с совокупностью данных о физическом лице:
//                 - Фамилия
//                 - Имя
//                 - Отчетсво
//                 - Представление (Фамилия И.О.)
//                 - Подразделение
//                 - ДокументВид
//                 - ДокументСерия
//                 - ДокументНомер
//                 - ДокументДатаВыдачи
//                 - ДокументКемВыдан
//
Функция ДанныеФизЛица(Организация, ФизЛицо, ДатаСреза) Экспорт
	
	Результат = Новый Структура("Фамилия, Имя, Отчество, Представление, 
	|ТабельныйНомер, Должность, ПодразделениеОрганизации, 
	|ДокументВид, ДокументСерия, ДокументНомер,  
	|ДокументДатаВыдачи, ДокументКемВыдан");
	
	ЗапросПоЛицам = Новый Запрос();
	ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
	ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
	ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
	ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ
	|	ФИОФизЛицСрезПоследних.Фамилия,
	|	ФИОФизЛицСрезПоследних.Имя,
	|	ФИОФизЛицСрезПоследних.Отчество,
	|	РаботникиОрганизацийСрезПоследних.ТабельныйНомер,
	|	РаботникиОрганизацийСрезПоследних.Должность,
	|	РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан
	|ИЗ
	|	(ВЫБРАТЬ Ссылка КАК ФизЛицо ИЗ Справочник.ФизическиеЛица ГДЕ Ссылка = &ФизЛицо) КАК ФизЛица
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ФИОФизЛицСрезПоследних
	|	ПО ФизЛица.ФизЛицо = ФИОФизЛицСрезПоследних.ФизЛицо
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|	ПО ФизЛица.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо
	|	ЛЕВОЕ СОЕДИНЕНИЕ 
	|		(ВЫБРАТЬ ПЕРВЫЕ 1
	|			РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
	|			РаботникиОрганизацийСрезПоследних.Сотрудник.ФизЛицо КАК ФизЛицо,
	|			РаботникиОрганизацийСрезПоследних.Должность КАК Должность,
	|			РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации КАК ПодразделениеОрганизации
	|		ИЗ
	|			РегистрСведений.РаботникиОрганизаций.СрезПоследних(&ДатаСреза,	Сотрудник.ФизЛицо = &ФизЛицо И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	|		ГДЕ
	|			РаботникиОрганизацийСрезПоследних.ПричинаИзмененияСостояния <> ЗНАЧЕНИЕ(Перечисление.ПричиныИзмененияСостояния.Увольнение)
	|		УПОРЯДОЧИТЬ ПО
	|		ВЫБОР
	|			КОГДА РаботникиОрганизацийСрезПоследних.Сотрудник.ВидЗанятости = ЗНАЧЕНИЕ(Перечисление.ВидыЗанятостиВОрганизации.ОсновноеМестоРаботы) 
	|				ТОГДА 0
	|		ИНАЧЕ 1	
	|		КОНЕЦ
	|		) КАК РаботникиОрганизацийСрезПоследних
	|	ПО ФизЛица.ФизЛицо = РаботникиОрганизацийСрезПоследних.Физлицо
	|";
	
	Данные = ЗапросПоЛицам.Выполнить().Выбрать();
	Данные.Следующий();
	
	Результат.Фамилия       			= Данные.Фамилия;
	Результат.Имя      					= Данные.Имя;
	Результат.Отчество      			= Данные.Отчество;
	Результат.Представление 			= ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество);
	
	Результат.ТабельныйНомер  			= Данные.ТабельныйНомер;
	Результат.Должность      			= Данные.Должность;
	Результат.ПодразделениеОрганизации  = Данные.ПодразделениеОрганизации;
	
	Результат.ДокументВид        		= Данные.ДокументВид;
	Результат.ДокументСерия      		= Данные.ДокументСерия;
	Результат.ДокументНомер      		= Данные.ДокументНомер;
	Результат.ДокументДатаВыдачи 		= Данные.ДокументДатаВыдачи;
	Результат.ДокументКемВыдан      	= Данные.ДокументКемВыдан;
	
	Возврат Результат;
	
КонецФункции // ДанныеФизЛица


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

Процедура ПроверитьНомерНалоговогоДокумента(Документ) Экспорт
	
	// поддерживаем особый порядок нумерации налоговых накладных
	// при изменении даты документа возможно потребуется изменение=очистка номера
	
	Если НЕ ЗначениеЗаполнено(Документ.Ссылка) Тогда
		// это новый документ, номер еще не присвоен или задан вручную
		Возврат;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Документ.Номер) Тогда
		Возврат;
	КонецЕсли;
	
	ЗапросСтарыеДанные = Новый Запрос();
	ЗапросСтарыеДанные.Текст = "ВЫБРАТЬ
	|	НалоговыйДокумент.Дата,
	|	НалоговыйДокумент.ВидОперации,
	|	НалоговыйДокумент.СпецРежимНалогообложения,
	|	НалоговыйДокумент.ОбособленноеПодразделение КАК Филиал,
	|	НалоговыйДокумент.Организация
	|ИЗ
	|	Документ.НалоговаяНакладная КАК НалоговыйДокумент
	|ГДЕ
	|	НалоговыйДокумент.Ссылка = &Ссылка";
	ЗапросСтарыеДанные.УстановитьПараметр("Ссылка",    Документ.Ссылка);
	
	Если ТипЗнч(Документ) = Тип("ДокументОбъект.Приложение2КНалоговойНакладной") Тогда
		ЗапросСтарыеДанные.Текст = СтрЗаменить(ЗапросСтарыеДанные.Текст,"Документ.НалоговаяНакладная", "Документ.Приложение2КНалоговойНакладной");
		ЗапросСтарыеДанные.Текст = СтрЗаменить(ЗапросСтарыеДанные.Текст,"НалоговыйДокумент.ОбособленноеПодразделение", "ЕстьNULL(НалоговыйДокумент.НалоговаяНакладная.ОбособленноеПодразделение, ЗНАЧЕНИЕ(Справочник.ОбособленныеПодразделенияОрганизаций.ПустаяСсылка))");
	КонецЕсли;
	
	СтарыеДанные = ЗапросСтарыеДанные.Выполнить().Выбрать();
	СтарыеДанные.Следующий();
	
	СтараяУчетнаяПолитика = РегистрыСведений.УчетнаяПолитикаНалоговыйУчет.СрезПоследних(СтарыеДанные.Дата, Новый Структура("Организация", СтарыеДанные.Организация));
	НоваяУчетнаяПолитика  = РегистрыСведений.УчетнаяПолитикаНалоговыйУчет.СрезПоследних(Документ.Дата, 	 Новый Структура("Организация", Документ.Организация));
	
	Если  СтараяУчетнаяПолитика.Количество() > 0
		И НоваяУчетнаяПолитика.Количество() > 0 Тогда
		
		Если СтараяУчетнаяПолитика[0].ВестиРаздельнуюНумерациюНалоговыхДокументов <> НоваяУчетнаяПолитика[0].ВестиРаздельнуюНумерациюНалоговыхДокументов
			ИЛИ СтараяУчетнаяПолитика[0].ВестиМесячнуюНумерациюНалоговыхДокументов <> НоваяУчетнаяПолитика[0].ВестиМесячнуюНумерациюНалоговыхДокументов
			ИЛИ СтараяУчетнаяПолитика[0].ВестиДневнуюНумерациюНалоговыхДокументов <> НоваяУчетнаяПолитика[0].ВестиДневнуюНумерациюНалоговыхДокументов
			Тогда
			
			Документ.Номер = "";
			
		ИначеЕсли НоваяУчетнаяПолитика[0].ВестиМесячнуюНумерациюНалоговыхДокументов 
			И НачалоМесяца(СтарыеДанные.Дата) <> НачалоМесяца(Документ.Дата) Тогда
			
			Документ.Номер = "";
			
		ИначеЕсли НоваяУчетнаяПолитика[0].ВестиДневнуюНумерациюНалоговыхДокументов 
			И НачалоДня(СтарыеДанные.Дата) <> НачалоДня(Документ.Дата) Тогда
			
			Документ.Номер = "";
			
			
		КонецЕсли;
		
	КонецЕсли;	
	
	Если НЕ СтарыеДанные.ВидОперации = Документ.ВидОперации
		И ((СтарыеДанные.ВидОперации = Перечисления.ВидыОперацийНалоговаяНакладная.НеНДСОперации ИЛИ СтарыеДанные.ВидОперации = Перечисления.ВидыОперацийПриложение2КНалоговойНакладной.НеНДСОперацииВозврат ИЛИ СтарыеДанные.ВидОперации = Перечисления.ВидыОперацийПриложение2КНалоговойНакладной.НеНДСОперацииКорректировка)
		ИЛИ(Документ.ВидОперации = Перечисления.ВидыОперацийНалоговаяНакладная.НеНДСОперации ИЛИ Документ.ВидОперации = Перечисления.ВидыОперацийПриложение2КНалоговойНакладной.НеНДСОперацииВозврат ИЛИ Документ.ВидОперации = Перечисления.ВидыОперацийПриложение2КНалоговойНакладной.НеНДСОперацииКорректировка))
		И (НоваяУчетнаяПолитика[0].ВестиРаздельнуюНумерациюНалоговыхДокументовПоНеНДСОперациям = Истина
		ИЛИ СтараяУчетнаяПолитика[0].ВестиРаздельнуюНумерациюНалоговыхДокументовПоНеНДСОперациям = Истина) Тогда
		
		Документ.Номер = "";
		
	КонецЕсли;
	
	Если НЕ СтарыеДанные.СпецРежимНалогообложения = Документ.СпецРежимНалогообложения
		И (НоваяУчетнаяПолитика[0].ВестиРаздельнуюНумерациюНалоговыхДокументовПоСпецРежимам = Истина
		ИЛИ СтараяУчетнаяПолитика[0].ВестиРаздельнуюНумерациюНалоговыхДокументовПоСпецРежимам = Истина) Тогда
		
		Документ.Номер = "";
		
	КонецЕсли;
	
	ТекФилиал = ?(ТипЗнч(Документ) = Тип("ДокументОбъект.Приложение2КНалоговойНакладной"), Документ.НалоговаяНакладная.ОбособленноеПодразделение, Документ.ОбособленноеПодразделение);
	Если НЕ СтарыеДанные.Филиал = ТекФилиал
		И (НоваяУчетнаяПолитика[0].ВестиНумерациюНалоговыхДокументовБезУчетаОбособленныхПодразделений = Ложь
		ИЛИ СтараяУчетнаяПолитика[0].ВестиНумерациюНалоговыхДокументовБезУчетаОбособленныхПодразделений = Ложь) Тогда
		
		Документ.Номер = "";
		
	КонецЕсли;
	
	
КонецПроцедуры

Функция ПолучитьДневнойПрефиксНалоговыхДокументов(Дата)
	
	// номер дня с лидирующим нулем
	Возврат "Д" + Формат(День(Дата), "ЧЦ=2; ЧВН=");	
	
КонецФункции

Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
	
	Если ПараметрыСеанса.ИспользованиеРИБ
		ИЛИ ПараметрыСеанса.НаличиеОбменаСРозничнойТорговлей Тогда
		Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;
	КонецЕсли;
	
КонецПроцедуры

Процедура СообщитьИнформацияОПрефиксации() Экспорт
	
	Сообщить("Для задействования механизма установки префиксов объектов необходимо установить константу ""Префикс узла для распределенной информационной базы"" 
	| и перезапустить текущий сеанс работы 1С:Предприятия.");
	Сообщить("Текущее значение префикса: " + ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы);
	
КонецПроцедуры

Процедура ДобавитьПрефиксОрганизации(ДокументОбъект, Префикс) Экспорт
	
	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	Если Не ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
		Или НЕ ЗначениеЗаполнено(ДокументОбъект.Организация.Префикс) Тогда
		
		Префикс = "";
		
	Иначе
		
		Префикс = ДокументОбъект.Организация.Префикс;
		
	КонецЕсли;
	
Конецпроцедуры

Процедура ПриУстановкеНовогоКодаСправочникаПриУстановкеНовогоКода(Источник, СтандартнаяОбработка, Префикс) Экспорт
	
	ДобавитьПрефиксУзла(Префикс);
	
КонецПроцедуры

Процедура ПриУстановкеКодаПВХПриУстановкеНовогоКода(Источник, СтандартнаяОбработка, Префикс) Экспорт
	
	ДобавитьПрефиксУзла(Префикс);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПИСИ НАБОРА КОНСТАНТ


// Записывает набор констант, сравнивая его с эталонным набором
// Записываются только те константы, которые были изменены относительно эталонного набора
//
// Параметры: 
//  НаборКонстант  - Набор констант
//  ЭталонныйНабор - Эталонный набор констант
//  Модифицированность - Устанавливается в истину, если операция выполнена успешно
//
// Возвращаемое значение:
//  Истина - операция выполнена, ложь - иначе.
//
Функция ЗаписатьНаборКонстант(НаборКонстант, ЭталонныйНабор, Модифицированность = Истина) Экспорт
	
	ЗаписываемыеКонстанты = "";
	Для каждого Константа Из Метаданные.Константы Цикл
		
		ИмяКонстанты = Константа.Имя;
		
		ЗначениеНабора    = ЗначениеВСтрокуВнутр(НаборКонстант[ИмяКонстанты]);
		ЭталонноеЗначение = ЗначениеВСтрокуВнутр(ЭталонныйНабор[ИмяКонстанты]);
		
		Если Не ЗначениеНабора = ЭталонноеЗначение Тогда
			
			ТекущееЗначение   = ЗначениеВСтрокуВнутр(Константы[ИмяКонстанты].Получить());
			
			Если Не ЗначениеНабора = ТекущееЗначение Тогда
				ЗаписываемыеКонстанты = ЗаписываемыеКонстанты + ?(ПустаяСтрока(ЗаписываемыеКонстанты), "", ", ") + ИмяКонстанты;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(ЗаписываемыеКонстанты) Тогда
		
		ЗаписываемыйНабор = Константы.СоздатьНабор(ЗаписываемыеКонстанты);
		ЗаполнитьЗначенияСвойств(ЗаписываемыйНабор, НаборКонстант, ЗаписываемыеКонстанты);
		
		Попытка
			ЗаписываемыйНабор.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			Возврат Ложь;
		КонецПопытки;
		
		НаборКонстант.Прочитать();
		ЗаполнитьЗначенияСвойств(ЭталонныйНабор, НаборКонстант);
		
	КонецЕсли; 
	
	Модифицированность = Ложь;
	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СЧЕТАМИ И СУБКОНТО


// Эта функция возвращает информацию о счете из переданного соответсвия
// Если в соответствии не найдена информация о счете - она подготавливается и 
// помещается в соответсвие
// Применяется для работы с формами в которых активно требуется получать 
// информащцию о счетах, например, при выводе строки табличного поля
//
// Параметры:      
//	СведенияОСчетах - соответсвие у котрого в качестве ключа - ПланСчетовСсылка, а 
//  				  в качестве значения - структура из 4-х элементов
//					  КоличествоСубконто - число
//                    ТипСубконто1 - описание типа
//                    ТипСубконто2 - описание типа
//                    ТипСубконто3 - описание типа
//					  ВидСубконто1Представление - представление вида субконто
//					  ВидСубконто2Представление - представление вида субконто
//					  ВидСубконто3Представление - представление вида субконто
//
//	Счет - ПланСчетовСсылка
//
// Возвращаемое значение:
//  Описанная выше структура
//
Функция ПолучитьСведенияОСчете(СведенияОСчетах, Счет) Экспорт
	
	СведенияОСчете = СведенияОСчетах[Счет];
	
	Если СведенияОСчете = Неопределено Тогда
		
		СведенияОСчете = Новый Структура("КоличествоСубконто, ВидСубконто1, ВидСубконто2, ВидСубконто3, ТипСубконто1, ТипСубконто2, ТипСубконто3, ВидСубконто1Представление, ВидСубконто2Представление, ВидСубконто3Представление");
		
		СведенияОСчете.КоличествоСубконто = Счет.ВидыСубконто.Количество();
		
		Если СведенияОСчете.КоличествоСубконто > 0 Тогда
			
			ВидСубконто = Счет.ВидыСубконто[0].ВидСубконто;
			
			СведенияОСчете.ВидСубконто1              = ВидСубконто;
			СведенияОСчете.ТипСубконто1              = ВидСубконто.ТипЗначения;
			СведенияОСчете.ВидСубконто1Представление = ВидСубконто.Наименование;
			
		КонецЕсли;
		
		Если СведенияОСчете.КоличествоСубконто > 1 Тогда
			
			ВидСубконто = Счет.ВидыСубконто[1].ВидСубконто;
			
			СведенияОСчете.ВидСубконто2              = ВидСубконто;
			СведенияОСчете.ТипСубконто2              = ВидСубконто.ТипЗначения;
			СведенияОСчете.ВидСубконто2Представление = ВидСубконто.Наименование;
			
		КонецЕсли;
		
		Если СведенияОСчете.КоличествоСубконто > 2 Тогда
			
			ВидСубконто = Счет.ВидыСубконто[2].ВидСубконто;
			
			СведенияОСчете.ВидСубконто3              = ВидСубконто;
			СведенияОСчете.ТипСубконто3              = ВидСубконто.ТипЗначения;
			СведенияОСчете.ВидСубконто3Представление = ВидСубконто.Наименование;
			
		КонецЕсли;
		
		СведенияОСчетах[Счет] = СведенияОСчете;
		
	КонецЕсли;
	
	Возврат СведенияОСчете;
	
КонецФункции  // ПолучитьСведенияОСчете

// Выполняет в табличном поле приведение значений субконто к типу, соответствующему счету
// сведения о счете передаются через параметр СведенияОСчете
// используется для табличных полей, содержащих колонки типа Счет и соответствующие ему субконто
//
// Параметры:
//	ТабличноеПоле 	- табличное поле 
//  ДтКт 			- строка "Дт", "Кт" или "" - часть имени колонки табличного поля
// 					для колонок табличного поля поддерживаются имена 
//					типа СубконтоДт1, СубконтоКт1, Субконто1...
//  СведенияОСчете 	- структура
//					  КоличествоСубконто - число
//                    ТипСубконто1 - описание типа
//                    ТипСубконто2 - описание типа
//                    ТипСубконто3 - описание типа
//					  ВидСубконто1Представление - представление вида субконто - в данной процедуре не используется
//					  ВидСубконто2Представление - представление вида субконто - в данной процедуре не используется
//					  ВидСубконто3Представление - представление вида субконто - в данной процедуре не используется
//
Процедура ПривестиЗначениеСубконто(ТабличноеПоле, ДтКт, СведенияОСчете) Экспорт
	
	Для СчетчикСубконто = 1 По 3 Цикл
		
		Если СведенияОСчете.КоличествоСубконто >= СчетчикСубконто Тогда
			ТабличноеПоле.ТекущиеДанные["Субконто"+ДтКт+СчетчикСубконто] = СведенияОСчете["ТипСубконто"+СчетчикСубконто].ПривестиЗначение(ТабличноеПоле.ТекущиеДанные["Субконто"+ДтКт+СчетчикСубконто]);
			
		Иначе
			ТабличноеПоле.ТекущиеДанные["Субконто"+ДтКт+СчетчикСубконто] = Неопределено;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры   // ПривестиЗначениеСубконто

// Назначает видимость ячейкам строки табличного поля, соответствующим субконто
// в зависимлсти от счета. Сведения о счете передаются через параметр СведенияОСчете
// Используется для табличных полей, содержащих колонки типа Счет и соответствующие ему субконто
// при выводе строки
//
// Параметры:
//	ОформлениеСтроки 	- оформление строки
//  ДтКт 				- строка "Дт", "Кт" или "" - часть имени колонки табличного поля
// 						для колонок табличного поля поддерживаются имена 
//						типа СубконтоДт1, СубконтоКт1, Субконто1...
//  СведенияОСчете 		- структура
//					  	КоличествоСубконто - число
//                    	ТипСубконто1 - описание типа
//                    	ТипСубконто2 - описание типа
//                    	ТипСубконто3 - описание типа
//					    ВидСубконто1Представление - представление вида субконто - в данной процедуре не используется
//					    ВидСубконто2Представление - представление вида субконто - в данной процедуре не используется
//					    ВидСубконто3Представление - представление вида субконто - в данной процедуре не используется
//
Процедура НазначитьВидимостьСубконто(ОформлениеСтроки, ДтКт, СведенияОСчете) Экспорт
	
	Для СчетчикСубконто = 1 По 3 Цикл
		ОформлениеСтроки.Ячейки["Субконто"+ДтКт+СчетчикСубконто].Видимость = СведенияОСчете.КоличествоСубконто >= СчетчикСубконто;
		ОформлениеСтроки.Ячейки["Субконто"+ДтКт+СчетчикСубконто].ТолькоПросмотр = НЕ СведенияОСчете.КоличествоСубконто >= СчетчикСубконто;
	КонецЦикла;
	
КонецПроцедуры

// Функция применяется при необходимости получить сведения об учетной политике организации.
//
// Параметры:
// Учет - строка. Определяет регистр сведений, из которого будут получены данные:
//   "НалоговыйУчет" или "БухгалтерскийУчет".
//
// Возвращаемое значение - таблица значений. Таблица, каждая строка которой 
//  соответствует записи регистра. 
//
Функция СоздатьКЭШУчетнойПолитики(Учет) Экспорт
	
	Запрос = Новый Запрос();
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	*
	|ИЗ
	|	РегистрСведений.УчетнаяПолитика" + Учет +" КАК УчетнаяПолитика" + Учет;
	
	УчетнаяПолитика = Запрос.Выполнить().Выгрузить();
	УчетнаяПолитика.Сортировать("Период");
	
	Возврат УчетнаяПолитика;
	
КонецФункции

// Функция возвращает структуру с параметрами учетной политики на заданную дату.
//
Функция ПолучитьПараметрыУчетнойПолитики(КонДата, Отказ, Организация = Неопределено, Учет = "Упр", СообщатьОбОшибке = Истина) Экспорт
	
	СтруктураУчПолитика = Новый Структура;
	
	
	Если  Учет = "Упр" Тогда
		// учетная политика упр. учета
		
		Запрос = Новый Запрос;
		Запрос.Текст = "
		|ВЫБРАТЬ
		|	*
		|ИЗ
		|	РегистрСведений.УчетнаяПолитика.СрезПоследних(&КонДата) КАК УчетнаяПолитикаСрезПоследних";	
		
		Запрос.УстановитьПараметр("КонДата", КонДата);
		РезультатЗапроса = Запрос.Выполнить();
		
		Если РезультатЗапроса.Пустой() Тогда
			Если СообщатьОбОшибке Тогда
				СообщитьОбОшибке("Не заполнен регистр сведений ""Учетная политика"" на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
			КонецЕсли;
		Иначе
			
			РезультатЗапроса = РезультатЗапроса.Выгрузить();
			
			Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
				СтруктураУчПолитика.Вставить(Колонка.Имя, РезультатЗапроса[0][Колонка.Имя]);
			КонецЦикла;
			
		КонецЕсли;
		
		Возврат СтруктураУчПолитика;
		
	КонецЕсли;
	
	// политика налогового или бухгалтерского учета
	Если Учет = "Нал" Тогда
		// заполним структуру "пустыми значениями"
		СтруктураУчПолитика.Вставить("СхемаНалогообложения",  Справочники.СхемыНалогообложения.НеПлательщик);
		СтруктураУчПолитика.Вставить("ЕстьНалогНаПрибыль"	, Ложь);
		СтруктураУчПолитика.Вставить("ЕстьНалогНаПрибыльДо2015"	, Ложь);
		СтруктураУчПолитика.Вставить("ЕстьНалогНаПрибыльС2015"	, Ложь);
		СтруктураУчПолитика.Вставить("ЕстьНДС"				, Ложь);
		СтруктураУчПолитика.Вставить("ЕстьЕдиныйНалог"		, Ложь);
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Организация) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;	
		
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(КонДата) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;	
		
	КонецЕсли;
	
	Если Учет = "Нал" Тогда
		УчетнаяПолитика = ПараметрыСеанса.УчетнаяПолитикаПоНалоговомуУчету.Получить();
		
	Иначе
		УчетнаяПолитика = ПараметрыСеанса.УчетнаяПолитикаПоБухгалтерскомуУчету.Получить();
	КонецЕсли; 
	
	УчетнаяПолитикаОрганизации = УчетнаяПолитика.НайтиСтроки(Новый Структура("Организация", Организация));
	
	Если УчетнаяПолитикаОрганизации.Количество() = 0 Тогда
		Отказ = Истина;
		Если Учет = "Нал" Тогда
			ТекТекстСообщения = Локализация.СтрШаблон("Не указаны параметры учетной политики налогового учета (¤1¤) на ¤2¤", СокрЛП(Организация), Формат(КонДата, "ДФ=дд.ММ.гггг"));
		Иначе
			ТекТекстСообщения = Локализация.СтрШаблон("Не указаны параметры учетной политики бухгалтерского учета (¤1¤) на ¤2¤", СокрЛП(Организация), Формат(КонДата, "ДФ=дд.ММ.гггг"));
		КонецЕсли;	
		Если СообщатьОбОшибке Тогда
			СообщитьОбОшибке(ТекТекстСообщения, Отказ);
		КонецЕсли;
		Возврат СтруктураУчПолитика;	
	Иначе
		
		Номер = 0;
		ФлагОтказа = Истина;
		Для НомерСтроки = 1 По УчетнаяПолитикаОрганизации.Количество() Цикл
			
			Строка = УчетнаяПолитикаОрганизации.Получить(НомерСтроки - 1);
			Если Строка.Период <= КонДата Тогда
				Номер = НомерСтроки;
				ФлагОтказа = Ложь;
				
			Иначе 
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если Номер <> 0 Тогда
			Строка = УчетнаяПолитикаОрганизации.Получить(Номер - 1);
			Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
				СтруктураУчПолитика.Вставить(Колонка.Имя, Строка[Колонка.Имя]);
				Если Колонка.Имя = "СхемаНалогообложения" Тогда
					СхемаНалогообложения = Строка[Колонка.Имя];
					СтруктураУчПолитика.Вставить("ЕстьНалогНаПрибыль"	, СхемаНалогообложения.НалогНаПрибыль);
					СтруктураУчПолитика.Вставить("ЕстьНалогНаПрибыльДо2015"	, СхемаНалогообложения.НалогНаПрибыль);
					СтруктураУчПолитика.Вставить("ЕстьНалогНаПрибыльС2015"	, СхемаНалогообложения.НалогНаПрибыль);
					СтруктураУчПолитика.Вставить("ЕстьНДС"				, СхемаНалогообложения.НДС);
					СтруктураУчПолитика.Вставить("ЕстьЕдиныйНалог"		, СхемаНалогообложения.ЕдиныйНалог);
				КонецЕсли; 
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если  ФлагОтказа = Истина Тогда
		
		Если Учет = "Нал" Тогда
			ТекТекстСообщения = Локализация.СтрШаблон("Не указаны параметры учетной политики налогового учета (¤1¤) на ¤2¤", СокрЛП(Организация), Формат(КонДата, "ДФ=дд.ММ.гггг"));
		Иначе
			ТекТекстСообщения = Локализация.СтрШаблон("Не указаны параметры учетной политики бухгалтерского учета (¤1¤) на ¤2¤", СокрЛП(Организация), Формат(КонДата, "ДФ=дд.ММ.гггг"));
		КонецЕсли;	
		
		Если СообщатьОбОшибке Тогда
			СообщитьОбОшибке(ТекТекстСообщения, Отказ);
		КонецЕсли;
		
	КонецЕсли; 
	
	Возврат СтруктураУчПолитика;
	
КонецФункции // ПолучитьПараметрыУчетнойПолитики()

// Получает параметр учетной политики (налоговый учет) для заданной организации на заданную дату
//
// Параметры:
//	ИмяПараметра        - строка, имя запрашиваемого параметра учетной политики,
//	Организация         - ссылка на элемент справочника "Организации", для которого надо получить параметры,
//	Дата                - дата, на которую надо получить параметры, если не заполнено, то берется рабочая дата,
//	СтруктураПараметров - структура, содержащая все параметры учетной политики.
//
// Возвращаемое значение:
//	Значение учетной политики
//
Функция УчетнаяПолитикаНалоговыйУчет(Знач КонДата, Отказ, Организация) Экспорт
	
	// Если дата не заполнена, возьмем рабочую дату
	Если НЕ ЗначениеЗаполнено(КонДата) Тогда
		КонДата = ПолучитьРабочуюДату();
	КонецЕсли;
	
	Возврат ПолучитьПараметрыУчетнойПолитики(КонДата, Отказ, Организация, "Нал");
	
КонецФункции // УчетнаяПолитикаНалоговыйУчет()

// Добавляет записи из таблицы движений в набор записей
//
//Процедура ДобавитьСтрокиВНаборЗаписей(НаборЗаписей, Таблица) Экспорт
//	
//	НаборМетаданные = НаборЗаписей.Метаданные();
//	
//	Регистратор = НаборЗаписей.Отбор.Регистратор.Значение;
//	
//	Период = Неопределено;
//	
//	Для Каждого Строка Из Таблица Цикл
//		
//		Запись = НаборЗаписей.Добавить();
//		
//		ЗаполнитьЗначенияСвойств(Запись,Строка);
//		
//		Запись.Активность = Истина;
//		
//		Если Запись.Период = '00010101' Тогда
//			
//			Если Период = Неопределено Тогда
//			
//				СтруктураРеквизитовДокумента = Новый Структура("Дата");
//				УправлениеЗапасамиПартионныйУчет.ПолучитьРеквизитыОбъекта(Регистратор, СтруктураРеквизитовДокумента);
//				
//				Период = СтруктураРеквизитовДокумента.Дата;
//			
//			КонецЕсли;
//			
//			Запись.Период = Период;
//			
//		КонецЕсли;
//		
//	КонецЦикла;

//КонецПроцедуры

// Функция возвращает остаток по счету бухгалтерского учета
// Возвращаемое значение - таблица значений в развороте по аналитике с учетом фильтра
Функция ПолучитьОстатокПоСчету(Организация, Период, Счет, Валюта = Неопределено, Субконто1 = Неопределено, Субконто2 = Неопределено, Субконто3 = Неопределено, ЗнакФильтрПоОстаткам = 0) Экспорт
	
	ВидПланаСчетов = Счет.Метаданные().Имя;
	
	Субконто    = Новый Массив(3);
	Субконто[0] = Субконто1;
	Субконто[1] = Субконто2;
	Субконто[2] = Субконто3;
	
	ФильтрПоСубконто = "";
	
	Для Каждого ТекВидСубконто Из Счет.ВидыСубконто Цикл
		Если НЕ ТекВидСубконто.ТолькоОбороты И НЕ Субконто[ТекВидСубконто.НомерСтроки-1] = Неопределено Тогда
			ФильтрПоСубконто = ФильтрПоСубконто + " И Субконто" + ТекВидСубконто.НомерСтроки + " = &Субконто" + ТекВидСубконто.НомерСтроки;
		КонецЕсли;
	КонецЦикла;
	
	ВыбиратьВалюту			= (не Счет.Метаданные().ПризнакиУчета.Найти("Валютный")= Неопределено);
	ВыбиратьВалютнуюСумму	= (не Метаданные.РегистрыБухгалтерии[ВидПланаСчетов].Ресурсы.Найти("ВалютнаяСумма")= Неопределено);
	ОтборПоОрганизации		= (не Метаданные.РегистрыБухгалтерии[ВидПланаСчетов].Измерения.Найти("Организация")= Неопределено);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Период"      , Период);
	Запрос.УстановитьПараметр("Счет"        , Счет);
	Запрос.УстановитьПараметр("Организация" , Организация);
	Запрос.УстановитьПараметр("Субконто1"   , Субконто[0]);
	Запрос.УстановитьПараметр("Субконто2"   , Субконто[1]);
	Запрос.УстановитьПараметр("Субконто3"   , Субконто[2]);
	Запрос.УстановитьПараметр("Валюта"      , Валюта);
	ВидыСубконто = Счет.ВидыСубконто.ВыгрузитьКолонку("ВидСубконто");
	Запрос.УстановитьПараметр("ВидыСубконто", ВидыСубконто);
	ЗнакОстатков = ?(ТипЗнч(ЗнакФильтрПоОстаткам) = Тип("Число"), ЗнакФильтрПоОстаткам, 0);
	Запрос.УстановитьПараметр("Множитель", ?(ЗнакОстатков < 0, -1, 1));
	
	КоличествоСубконто = ВидыСубконто.Количество();
	
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	Счет,"
	+ ?(КоличествоСубконто > 0, " 
	|	Субконто1,", "НЕОПРЕДЕЛЕНО КАК Субконто1,")
	+ ?(КоличествоСубконто > 1, " 
	|	Субконто2,", "НЕОПРЕДЕЛЕНО КАК Субконто2,")
	+ ?(КоличествоСубконто > 2, " 
	|	Субконто3,", "НЕОПРЕДЕЛЕНО КАК Субконто3,")
	+ "
	|	ЕСТЬNULL(СуммаОстаток, 0) * &Множитель КАК СуммаОстаток"
	+ ?(ВыбиратьВалюту, ", 
	|	ЕСТЬNULL(Валюта, НЕОПРЕДЕЛЕНО) КАК Валюта", "")
	+ ?(ВыбиратьВалютнуюСумму, ", 
	|	ЕСТЬNULL(ВалютнаяСуммаОстаток, 0)  * &Множитель КАК ВалютнаяСуммаОстаток", ",
	|	ЕСТЬNULL(СуммаОстаток, 0)  * &Множитель КАК ВалютнаяСуммаОстаток")
	+ "
	|ИЗ
	|	РегистрБухгалтерии." + ВидПланаСчетов + ".Остатки(&Период, Счет = &Счет, &ВидыСубконто, #Фильтр#) КАК Остатки"
	+ ?(ЗнакОстатков <> 0, "
	|
	|ГДЕ
	|	"
	+ ?(НЕ ЗначениеЗаполнено(Валюта), 
	"ЕСТЬNULL(Остатки.СуммаОстаток, 0) * &Множитель > 0", "ЕСТЬNULL(Остатки.ВалютнаяСуммаОстаток, 0) * &Множитель > 0"), "")
	+ "
	|
	|ДЛЯ ИЗМЕНЕНИЯ
	|
	|УПОРЯДОЧИТЬ ПО
	|	Счет,
	|	Субконто1,
	|	Субконто2,
	|	Субконто3"
	+ ?(ВыбиратьВалюту,",
	|	Валюта","");
	
	Фильтр = "";
	Если ОтборПоОрганизации Тогда
		Фильтр = Фильтр + " И Организация = &Организация";
	КонецЕсли;
	ОтборПоВалюте = Счет.Валютный И ЗначениеЗаполнено(Валюта);
	Если ОтборПоВалюте Тогда
		Фильтр = Фильтр + " И Валюта = &Валюта";
	КонецЕсли;
	Фильтр = Фильтр + ФильтрПоСубконто;
	Если Не ПустаяСтрока(Фильтр) Тогда // Убираем первое "И"
		Фильтр = Сред(Фильтр, 3);
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "#Фильтр#", Фильтр);	
	//МЦТ
	ИспользоватьУправляемыеБлокировки = Истина;
	Если ИспользоватьУправляемыеБлокировки Тогда
		
		Если ТипЗнч(Период) = Тип("Граница") Тогда
			ПериодДляБлокировки = Период.Значение.Дата;
		ИначеЕсли ТипЗнч(Период) = Тип("МоментВремени") Тогда
			ПериодДляБлокировки = Период.Дата;
		Иначе	
			ПериодДляБлокировки = Период;
		КонецЕсли; 
		
		СтруктураПараметров = Новый Структура(
		"ТипТаблицы, ИмяТаблицы", 
		"РегистрБухгалтерии", ВидПланаСчетов);
		
		ЗначенияБлокировки = Новый Соответствие;
		ЗначенияБлокировки.Вставить("Период", Новый Диапазон(, ПериодДляБлокировки));
		ЗначенияБлокировки.Вставить("Счет", Счет); 
		ЗначенияБлокировки.Вставить("Организация", Организация); 
		Если ОтборПоВалюте Тогда
			ЗначенияБлокировки.Вставить("Валюта", Валюта); 
		КонецЕсли;
		Для Каждого ТекВидСубконто Из Счет.ВидыСубконто Цикл
			Если НЕ ТекВидСубконто.ТолькоОбороты И НЕ Субконто[ТекВидСубконто.НомерСтроки-1] = Неопределено Тогда
				ЗначенияБлокировки.Вставить(ТекВидСубконто.ВидСубконто, Субконто[ТекВидСубконто.НомерСтроки-1]); 
			КонецЕсли;
		КонецЦикла;
		
		ОбщегоНазначения.УстановитьУправляемуюБлокировку(СтруктураПараметров, ЗначенияБлокировки);
		
	КонецЕсли;
	
	Остатки = Запрос.Выполнить().Выгрузить();
	
	Возврат Остатки;
	
КонецФункции // ПолучитьОстатокПоСчету()

// Процедура устанавливает субконто на счете. Если такое субконто на счете
// отсутствует, то ничего не делается.
//
// Параметры:
//		Счет - Счет, к которому относится субконто
//      Субконто - набор субконто
//		Номер или имя установливаемого субконто
//      Значение субконто - значение устанавливаемого субконто
//
Процедура УстановитьСубконто(Счет, Субконто, ИмяСубконто, ЗначениеСубконто, Сообщать = Ложь, Заголовок = "", ВидыСубконтоСчета = Неопределено) Экспорт
	
	Если Счет = Неопределено ИЛИ Счет.Пустая() Тогда
		Возврат;
	КонецЕсли;
	
	Если ВидыСубконтоСчета = Неопределено Тогда
		ВидыСубконтоСчета = Счет.ВидыСубконто;
	КонецЕсли; 
	
	Если ТипЗнч(ИмяСубконто) = Тип("Число") Тогда
		
		Если ИмяСубконто > ВидыСубконтоСчета.Количество() Тогда
			Возврат;
		КонецЕсли;
		
		ВидСубк = ВидыСубконтоСчета[ИмяСубконто - 1].ВидСубконто;
		
	Иначе
		
		ВидСубк = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные[ИмяСубконто];
		
		Если ВидыСубконтоСчета.Найти(ВидСубк) = Неопределено Тогда
			Если Сообщать тогда
				СообщитьОбОшибке(Локализация.СтрШаблон("Вид субконто <¤1¤> для счета ""¤2¤ (¤3¤)"" не определен.", ВидСубк, Счет.Код, Счет.Наименование),, Заголовок );
			КонецЕсли;
			Возврат;
		КонецЕсли;
		
	КонецЕсли;
	
	Если ВидСубк.ТипЗначения.СодержитТип(ТипЗнч(ЗначениеСубконто)) Тогда
		Субконто.Вставить(ВидСубк, ЗначениеСубконто);
		
	ИначеЕсли Сообщать тогда
		СообщитьОбОшибке(Локализация.СтрШаблон("Неверное значение ""¤1¤"" для вида субконто <¤2¤>", ЗначениеСубконто, ВидСубк),, Заголовок);
		
	КонецЕсли;
	
КонецПроцедуры // УстановитьСубконто()

Функция ОпределитьВидСубконтоПоСчету(Счет, КэшВидовСубконтоПоСчетам) Экспорт
	Если Счет = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	
	Если КэшВидовСубконтоПоСчетам = Неопределено Тогда
		КэшВидовСубконтоПоСчетам = Новый Соответствие;
	КонецЕсли; 
	
	ВидыСубконтоПоСчету = КэшВидовСубконтоПоСчетам[Счет];
	Если ВидыСубконтоПоСчету = Неопределено Тогда
		ВидыСубконтоПоСчету = Счет.ВидыСубконто;
		КэшВидовСубконтоПоСчетам.Вставить(Счет, ВидыСубконтоПоСчету);
	КонецЕсли; 
	
	Возврат ВидыСубконтоПоСчету;
	
КонецФункции

Функция ПолучитьНалоговоеНазначениеИзСубконтоСчетаЗатрат(СчетЗатрат, ЗначенияСубконто) Экспорт
	
	
	НалоговоеНазначение = Справочники.НалоговыеНазначенияАктивовИЗатрат.ПустаяСсылка();
	
	Если ЗначениеЗаполнено(СчетЗатрат) Тогда
		
		Сч = 0;
		
		Для каждого ВидСубконто Из СчетЗатрат.ВидыСубконто Цикл
			
			Если ВидСубконто.ВидСубконто.ТипЗначения.СодержитТип(Тип("СправочникСсылка.НалоговыеНазначенияАктивовИЗатрат")) Тогда
				
				Если ЗначениеЗаполнено(ЗначенияСубконто[Сч]) Тогда
					
					НалоговоеНазначение = ЗначенияСубконто[Сч];
					Прервать;
					
				КонецЕсли;
				
			ИначеЕсли ВидСубконто.ВидСубконто.ТипЗначения.СодержитТип(Тип("СправочникСсылка.НоменклатурныеГруппы")) Тогда
				
				Если ЗначениеЗаполнено(ЗначенияСубконто[Сч]) Тогда
					
					НалоговоеНазначение = ЗначенияСубконто[Сч].НалоговоеНазначениеВПроизводстве;
					Прервать;
					
				КонецЕсли;
				
			ИначеЕсли ВидСубконто.ВидСубконто.ТипЗначения.СодержитТип(Тип("СправочникСсылка.ОбъектыСтроительства")) Тогда
				
				Если ЗначениеЗаполнено(ЗначенияСубконто[Сч]) Тогда
					
					НалоговоеНазначение = ЗначенияСубконто[Сч].НалоговоеНазначение;
					Прервать;
					
				КонецЕсли;
				
			КонецЕсли;
			
			Сч = Сч+1;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат НалоговоеНазначение;
	
КонецФункции

// Процедура устанавливает субконто на счете по виду субконто. Если такое субконто на счете
// отсутствует, то ничего не делается.
//
// Параметры:
//		Счет - Счет, к которому относится субконто
//      Субконто - набор субконто
//		Номер или имя установливаемого субконто
//      Значение субконто - значение устанавливаемого субконто
//
Процедура УстановитьСубконтоПоВидуСубконто(Счет, Субконто, ВидСубконто, ЗначениеСубконто, Сообщать = Ложь, Заголовок = "") Экспорт
	
	Если Счет = Неопределено ИЛИ Счет.Пустая() Тогда
		Возврат;
	КонецЕсли;
	
	Если Счет.ВидыСубконто.Найти(ВидСубконто) = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ВидСубконто.ТипЗначения.СодержитТип(ТипЗнч(ЗначениеСубконто)) Тогда
		Субконто.Вставить(ВидСубконто, ЗначениеСубконто);
		
	ИначеЕсли Сообщать тогда
		СообщитьОбОшибке(Локализация.СтрШаблон("Неверное значение ""¤1¤"" для вида субконто <¤2¤>", ЗначениеСубконто, ВидСубконто),, Заголовок);
		
	КонецЕсли;
	
КонецПроцедуры // УстановитьСубконто()

// Проверяет заполнена ли аналитика счета затрат в документе
Процедура ПроверитьЗаполнениеАналитикиЗатрат(ДокументОбъект, Отказ, Заголовок) Экспорт
	
	Если ДокументОбъект.Метаданные().Реквизиты.Найти("СчетЗатрат") = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТекущийСчет = ДокументОбъект["СчетЗатрат"];
	Если НЕ ЗначениеЗаполнено(ТекущийСчет) Тогда
		Возврат;
	КонецЕсли;
	
	
	КоличествоСубконтоСчета = ТекущийСчет.ВидыСубконто.Количество();
	
	Для Индекс = 1 по КоличествоСубконтоСчета Цикл
		
		
		Если НЕ ЗначениеЗаполнено(ДокументОбъект["Субконто"+Строка(Индекс)]) Тогда
			
			СтрокаСообщения = "Не заполнено значение субконто """ + ТекущийСчет.ВидыСубконто[Индекс-1].ВидСубконто.Наименование +"""!";
			
			ОшибкаПриПроведении(СтрокаСообщения, Отказ, Заголовок);
			
		КонецЕсли;
	КонецЦикла;
	
	
КонецПроцедуры

// Проверяет заполнена ли аналитика затрат в табличной части документа
//Процедура ПроверитьЗаполнениеАналитикиЗатратТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, Отказ, Заголовок, СтруктураНаименованийРеквизитов = Неопределено) Экспорт
//	
//	ТабличнаяЧасть      = ДокументОбъект[ИмяТабличнойЧасти];
//	МетаданныеРеквизиты = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты;
//	
//	ОтражатьВУУ = ДокументОбъект.ОтражатьВУправленческомУчете;
//	ОтражатьВБУ = ДокументОбъект.ОтражатьВБухгалтерскомУчете;
//	
//	ИмяРеквизитаСчетЗатрат 				= ?(СтруктураНаименованийРеквизитов = Неопределено, "СчетЗатрат", СтруктураНаименованийРеквизитов.СчетЗатрат);
//	ИмяРеквизитаСтатьяЗатрат 			= ?(СтруктураНаименованийРеквизитов = Неопределено, "СтатьяЗатрат", СтруктураНаименованийРеквизитов.СтатьяЗатрат);
//	ИмяРеквизитаПодразделение 			= ?(СтруктураНаименованийРеквизитов = Неопределено, "Подразделение", СтруктураНаименованийРеквизитов.Подразделение);
//	ИмяРеквизитаПодразделениеОрганизации= ?(СтруктураНаименованийРеквизитов = Неопределено, "ПодразделениеОрганизации", СтруктураНаименованийРеквизитов.ПодразделениеОрганизации);
//	ИмяРеквизитаОбъектСтроительства 	= ?(СтруктураНаименованийРеквизитов = Неопределено, "ОбъектСтроительства", СтруктураНаименованийРеквизитов.ОбъектСтроительства);	
//		
//	ПредставлениеТабличнойЧасти = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Представление();
//	
//	КэшСчетов = Новый Соответствие;
//	
//	// Цикл по строкам табличной части.
//	Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл
//		
//		СтрокаНачалаСообщенияОбОшибке = Локализация.СтрШаблон("В строке номер ""¤1¤"" табличной части ""¤2¤"": ", СокрЛП(СтрокаТаблицы.НомерСтроки), ПредставлениеТабличнойЧасти);
//		
//		ПроверятьПодразделение 				= Ложь;
//		ПроверятьПодразделениеОрганизации 	= Ложь;
//		ПроверятьСтатьяЗатрат  				= Ложь;
//		ПроверятьОбъектСтроительства 		= Ложь;
//		ПроверятьСубконто 					= Ложь;
//		
//		Если ОтражатьВУУ Тогда
//			
//			ХарактерЗатрат = СтрокаТаблицы[ИмяРеквизитаСтатьяЗатрат].ХарактерЗатрат;
//			
//			Если НЕ ЗначениеЗаполнено(ХарактерЗатрат) Тогда
//				СтрокаСообщения = "не заполнен характер затрат для статьи затрат";
//				ОшибкаПриПроведении(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
//			КонецЕсли; 
//			
//			ПроверятьСтатьяЗатрат  = Истина;
//			ПроверятьПодразделение = Истина;
//			
//			Если ХарактерЗатрат = Перечисления.ХарактерЗатрат.ВложенияВоВнеоборотныеАктивы Тогда	
//				ПроверятьОбъектСтроительства = Истина;
//			КонецЕсли; 
//		КонецЕсли;	
//			
//		Если ОтражатьВБУ Тогда
//			
//			ТекущийСчет = СтрокаТаблицы[ИмяРеквизитаСчетЗатрат];
//			Если НЕ ЗначениеЗаполнено(ТекущийСчет) Тогда
//				ХарактерЗатратБУ = Неопределено;
//			Иначе
//				ХарактерЗатратБУ = УправлениеПроизводством.ПолучитьХарактерЗатратПоСчетуЗатрат(ТекущийСчет, Неопределено);
//			КонецЕсли;
//			
//			Если ХарактерЗатратБУ = Перечисления.ХарактерЗатрат.АдминистративныеРасходы Тогда
//				ПроверятьПодразделениеОрганизации = Истина;
//				ПроверятьСтатьяЗатрат  = Истина;
//			ИначеЕсли ХарактерЗатратБУ = Перечисления.ХарактерЗатрат.БракВПроизводстве Тогда
//				ПроверятьПодразделениеОрганизации = Истина;
//				ПроверятьСтатьяЗатрат  = Истина;
//			ИначеЕсли ХарактерЗатратБУ = Перечисления.ХарактерЗатрат.ВложенияВоВнеоборотныеАктивы Тогда	
//				ПроверятьПодразделениеОрганизации = Истина;
//				ПроверятьСтатьяЗатрат  = Истина;
//				ПроверятьОбъектСтроительства = Истина;
//			ИначеЕсли ХарактерЗатратБУ = Перечисления.ХарактерЗатрат.ОбщепроизводственныеРасходы Тогда
//				ПроверятьПодразделениеОрганизации = Истина;
//				ПроверятьСтатьяЗатрат  = Истина; 
//			ИначеЕсли ХарактерЗатратБУ = Перечисления.ХарактерЗатрат.ПроизводственныеРасходы Тогда
//				ПроверятьПодразделениеОрганизации = Истина;
//				ПроверятьСтатьяЗатрат  = Истина;
//			ИначеЕсли ХарактерЗатратБУ = Перечисления.ХарактерЗатрат.Прочие Тогда	
//				ПроверятьСубконто = Истина;
//			ИначеЕсли ХарактерЗатратБУ = Перечисления.ХарактерЗатрат.ПрочиеОперационныеРасходы Тогда	
//				ПроверятьСубконто = Истина;
//			ИначеЕсли ХарактерЗатратБУ = Перечисления.ХарактерЗатрат.РасходыНаСбыт Тогда
//				ПроверятьПодразделениеОрганизации = Истина;
//				ПроверятьСтатьяЗатрат = Истина;			
//			ИначеЕсли ХарактерЗатратБУ = Перечисления.ХарактерЗатрат.ТранспортноЗаготовительныеРасходы Тогда
//				ПроверятьПодразделениеОрганизации = Истина;
//				ПроверятьСтатьяЗатрат = Истина;			
//			КонецЕсли; 
//			
//		КонецЕсли; 
//		
//		Если ПроверятьПодразделение Тогда
//			Если НЕ ЗначениеЗаполнено(СтрокаТаблицы[ИмяРеквизитаПодразделение]) Тогда
//				СтрокаСообщения = "не заполнено подразделение";
//				ОшибкаПриПроведении(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
//			КонецЕсли; 
//		КонецЕсли; 
//		
//		Если ПроверятьПодразделениеОрганизации Тогда
//			Если НЕ ЗначениеЗаполнено(СтрокаТаблицы[ИмяРеквизитаПодразделениеОрганизации]) Тогда
//				СтрокаСообщения = "не заполнено подразделение оранизации";
//				ОшибкаПриПроведении(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
//			КонецЕсли; 
//		КонецЕсли; 
//		
//		Если ПроверятьСтатьяЗатрат Тогда
//			Если НЕ ЗначениеЗаполнено(СтрокаТаблицы[ИмяРеквизитаСтатьяЗатрат]) Тогда
//				СтрокаСообщения = "не заполнена статья затрат";
//				ОшибкаПриПроведении(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
//			КонецЕсли; 
//		КонецЕсли; 
//		
//		Если ПроверятьОбъектСтроительства Тогда
//			Если НЕ ЗначениеЗаполнено(СтрокаТаблицы[ИмяРеквизитаОбъектСтроительства]) Тогда
//				СтрокаСообщения = "не заполнен объект строительства";
//				ОшибкаПриПроведении(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
//			КонецЕсли; 
//		КонецЕсли; 
//			
//		Если ПроверятьСубконто Тогда
//		
//			КоличествоСубконтоСчета = ТекущийСчет.ВидыСубконто.Количество();
//			КоличествоСубконтоСчета = МИН(3, КоличествоСубконтоСчета);
//			
//			Для Индекс = 1 по КоличествоСубконтоСчета Цикл
//				Если НЕ ЗначениеЗаполнено(СтрокаТаблицы["Субконто"+Строка(Индекс)]) Тогда
//					СтрокаСообщения = "не заполнено значение субконто """ + ТекущийСчет.ВидыСубконто[Индекс-1].ВидСубконто.Наименование +"""!";
//					ОшибкаПриПроведении(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
//				КонецЕсли;
//			КонецЦикла;
//		КонецЕсли;	
//		
//	КонецЦикла;

//	
//КонецПроцедуры

//Процедура ПроверитьСоответствиеАналитикиЗатратНалоговомуНазначению(ДокументОбъект, ИмяТабличнойЧасти, Отказ, Заголовок, ИмяРеквизитаСчетЗатрат = "СчетЗатрат", НоменклатурныеГруппыВТабличнойЧасти = Ложь, Дата = '00010101') Экспорт	
//	
//	ТабличнаяЧасть = ДокументОбъект[ИмяТабличнойЧасти];
//	
//	Если ТабличнаяЧасть.Количество() = 0 Тогда
//		
//		Возврат;
//		
//	КонецЕсли;
//	
//	МетаданныеРеквизиты = ДокументОбъект.Метаданные().Реквизиты;
//	МетаданныеРеквизитыТЧ = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты;
//	
//	СчетЗатратВТабличнойЧасти = Ложь;
//	
//	Если (МетаданныеРеквизиты.Найти(ИмяРеквизитаСчетЗатрат) = Неопределено)Тогда
//		
//		СчетЗатратВТабличнойЧасти = Истина;
//		
//		Если(МетаданныеРеквизитыТЧ.Найти(ИмяРеквизитаСчетЗатрат) = Неопределено) Тогда
//			
//			Возврат;
//			
//		КонецЕсли;
//		
//	КонецЕсли;
//	
//	Если Не СчетЗатратВТабличнойЧасти Тогда
//		
//		РеквизитАналитики = Неопределено;
//			
//		Для Сч = 1 По 3 Цикл
//			
//			Если (МетаданныеРеквизиты.Найти("Субконто" + Сч) <> Неопределено) Тогда
//				
//				ТипСубконто = ТипЗнч(ДокументОбъект["Субконто" + Сч]);
//				
//				Если ТипСубконто = Тип("СправочникСсылка.НалоговыеНазначенияАктивовИЗатрат") Тогда
//					
//					РеквизитАналитики = ДокументОбъект["Субконто" + Сч];
//					Прервать
//					
//				ИначеЕсли ТипСубконто = Тип("СправочникСсылка.НоменклатурныеГруппы") Тогда
//					
//					РеквизитАналитики = ДокументОбъект["Субконто" + Сч].НалоговоеНазначениеВПроизводстве;
//					Прервать
//					
//				ИначеЕсли ТипСубконто = Тип("СправочникСсылка.ОбъектыСтроительства") Тогда
//					
//					РеквизитАналитики = ДокументОбъект["Субконто" + Сч].НалоговоеНазначение;
//					Прервать
//					
//				ИначеЕсли ТипСубконто = Тип("СправочникСсылка.РасходыБудущихПериодов") Тогда
//					
//					ХарактерЗатратРБП = УправлениеПроизводством.ПолучитьХарактерЗатратПоСчетуЗатрат(ДокументОбъект["Субконто" + Сч].СчетБУ, Неопределено);
//					
//					Если    ХарактерЗатратРБП = "Производство"
//						ИЛИ ХарактерЗатратРБП = "Строительство"
//						ИЛИ ХарактерЗатратРБП = "ОПЗ" Тогда
//						
//						РеквизитАналитики = ДокументОбъект["Субконто" + Сч].НалоговоеНазначение;
//						Прервать;
//						
//					КонецЕсли;

//				КонецЕсли;
//				
//			КонецЕсли;
//			
//		КонецЦикла;
//		
//	КонецЕсли;
//	
//	ВТЧЕстьСуточные = НЕ (МетаданныеРеквизитыТЧ.Найти("ЭтоСуточные") = Неопределено);
//	
//	ПредставлениеТабличнойЧасти = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Представление();
//	
//	// Цикл по строкам табличной части.
//	Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл
//		
//		СтрокаНачалаСообщенияОбОшибке = Локализация.СтрШаблон("В строке номер ""¤1¤"" табличной части ""¤2¤"": ", СокрЛП(СтрокаТаблицы.НомерСтроки), ПредставлениеТабличнойЧасти);
//		
//		Если НоменклатурныеГруппыВТабличнойЧасти Тогда
//			
//			РеквизитАналитики = СтрокаТаблицы.НоменклатурнаяГруппа.НалоговоеНазначениеВПроизводстве;
//			
//		ИначеЕсли СчетЗатратВТабличнойЧасти Тогда 
//			
//			РеквизитАналитики = Неопределено;
//			
//			ХарактерЗатратНУ = УправлениеПроизводством.ПолучитьХарактерЗатратПоСчетуЗатрат(СтрокаТаблицы[ИмяРеквизитаСчетЗатрат], Неопределено);
//			
//			Если     ХарактерЗатратНУ = "Строительство" 
//				И НЕ МетаданныеРеквизитыТЧ.Найти("ОбъектСтроительства")=Неопределено Тогда
//				
//				РеквизитАналитики = СтрокаТаблицы.ОбъектСтроительства.НалоговоеНазначение;
//				
//			ИначеЕсли ХарактерЗатратНУ = "Производство" 
//				И НЕ МетаданныеРеквизитыТЧ.Найти("НоменклатурнаяГруппа")=Неопределено Тогда
//				
//				РеквизитАналитики = СтрокаТаблицы.НоменклатурнаяГруппа.НалоговоеНазначениеВПроизводстве;
//				
//			Иначе	
//				
//				Для Сч = 1 По 3 Цикл
//					
//					Если (МетаданныеРеквизитыТЧ.Найти("Субконто" + Сч) <> Неопределено) Тогда
//						
//						ТипСубконто = ТипЗнч(СтрокаТаблицы["Субконто" + Сч]);
//						
//						Если ТипСубконто = Тип("СправочникСсылка.НалоговыеНазначенияАктивовИЗатрат") Тогда
//							
//							РеквизитАналитики = СтрокаТаблицы["Субконто" + Сч];
//							Прервать
//							
//						ИначеЕсли ТипСубконто = Тип("СправочникСсылка.НоменклатурныеГруппы") Тогда
//							
//							РеквизитАналитики = СтрокаТаблицы["Субконто" + Сч].НалоговоеНазначениеВПроизводстве;
//							Прервать
//							
//						ИначеЕсли ТипСубконто = Тип("СправочникСсылка.ОбъектыСтроительства") Тогда
//							
//							РеквизитАналитики = СтрокаТаблицы["Субконто" + Сч].НалоговоеНазначение;
//							Прервать
//							
//						ИначеЕсли ТипСубконто = Тип("СправочникСсылка.РасходыБудущихПериодов") Тогда
//							
//							ХарактерЗатратРБП = УправлениеПроизводством.ПолучитьХарактерЗатратПоСчетуЗатрат(СтрокаТаблицы["Субконто" + Сч].СчетБУ, Неопределено);
//							
//							Если    ХарактерЗатратРБП = "Производство"
//								ИЛИ ХарактерЗатратРБП = "Строительство"
//								ИЛИ ХарактерЗатратРБП = "ОПЗ"
//								Тогда
//								
//								РеквизитАналитики = СтрокаТаблицы["Субконто" + Сч].НалоговоеНазначение;
//								Прервать;
//								
//							КонецЕсли;
//							
//						КонецЕсли;
//						
//					КонецЕсли;
//					
//				КонецЦикла;
//				
//			КонецЕсли;
//			
//		КонецЕсли;
//		
//		Если ВТЧЕстьСуточные Тогда 
//			Если СтрокаТаблицы.ЭтоСуточные Тогда 
//				РеквизитАналитики = Неопределено;
//			КонецЕсли;
//		КонецЕсли;
//		
//		Если РеквизитАналитики = Неопределено Тогда
//			
//			Продолжить;
//			
//		Иначе
//			ХарактерЗатратНУ = УправлениеПроизводством.ПолучитьХарактерЗатратПоСчетуЗатрат(?(СчетЗатратВТабличнойЧасти, СтрокаТаблицы[ИмяРеквизитаСчетЗатрат], ДокументОбъект[ИмяРеквизитаСчетЗатрат]), Неопределено, ДокументОбъект.Дата);
//			
//			НалоговоеНазначение = Неопределено;
//			Если МетаданныеРеквизитыТЧ.Найти("НалоговоеНазначение") <> Неопределено Тогда
//				//Определим налоговое назначени в проводке - из ТЧ
//				НалоговоеНазначение = СтрокаТаблицы.НалоговоеНазначение;
//			Иначе
//				
//				//Определим налоговое назначени в проводке - из Аналитики
//				
//				ХарактерЗатратНУ = Неопределено;
//				НалоговыйУчет.ОпределениеАналитикиНалоговогоУчетаВПроводкахДляЗатрат(СтрокаТаблицы, СтрокаТаблицы.Счет, ХарактерЗатратНУ,
//														       	НалоговоеНазначение,,,,
//																НЕ МетаданныеРеквизитыТЧ.Найти("НоменклатурнаяГруппа")=Неопределено, НЕ МетаданныеРеквизитыТЧ.Найти("ОбъектСтроительства")=Неопределено);
//				Если ХарактерЗатратНУ = "ОПЗ" Тогда
//					НалоговоеНазначение = РеквизитАналитики;				
//				КонецЕсли;
//				
//			КонецЕсли;
//			
//			Если ХарактерЗатратНУ = "ТЗР" Тогда
//				// контроль не нужен, т.к. Налоговое назначение в НГ имеет значение только для производтва
//			ИначеЕсли ХарактерЗатратНУ = "Затраты" ИЛИ ХарактерЗатратНУ = "Прочие" Тогда
//			    // контроль не нужен, т.к. при отнесении на затраты контроль по НДС не осуществляется (деятельность НДС декларируется при отнесении)
//			ИначеЕсли НалоговоеНазначение = Справочники.НалоговыеНазначенияАктивовИЗатрат.НДС_Пропорционально Тогда
//				
//				Если РеквизитАналитики = Справочники.НалоговыеНазначенияАктивовИЗатрат.НДС_НеоблагаемаяНеХозДеятельность Тогда
//					СтрокаСообщения = Локализация.СтрШаблон(НСтр("ru=' Налоговое назначение по НДС <¤1¤> нельзя относить на налоговое назначению затрат по нехоз. деятельности (<¤2¤>)';uk=' Податкове призначення <¤1¤> не можна відносити на податкове призначення витрат по негосп. діяльності (<¤2¤>)'"), НалоговоеНазначение, РеквизитАналитики);
//					ОбщегоНазначения.ОшибкаПриПроведении(СтрокаНачалаСообщенияОбОшибке 
//					                    + Символы.ПС + Символы.Таб + СтрокаСообщения, Отказ, Заголовок);
//				КонецЕсли;
//			
//			ИначеЕсли РеквизитАналитики <> НалоговоеНазначение Тогда
//				
//				СтрокаСообщения = Локализация.СтрШаблон(НСтр("ru=' Налоговое назначение по НДС <¤1¤> не соответствует налоговому назначению затрат <¤2¤>';uk=' Податкове призначення по ПДВ <¤1¤> не відповідає податковому призначенню витрат <¤2¤>'"), НалоговоеНазначение, РеквизитАналитики);
//				ОбщегоНазначения.ОшибкаПриПроведении(СтрокаНачалаСообщенияОбОшибке 
//				                    + Символы.ПС + Символы.Таб + СтрокаСообщения, Отказ, Заголовок);
//				
//			КонецЕсли;
//			
//		КонецЕсли;
//		
//	КонецЦикла;
//	
//КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ ДОКУМЕНТАМИ


// Функция предназначена для формирования массива префиксов.
//
// Возвращаемое значение.
//  Массив префиксов
//
Функция ПолучитьМассивПрефиксовРИБ() Экспорт
	
	МассивПрефиксов = Новый Массив();
	
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ Различные
	|	ПрефиксыИнформационныхБаз.Префикс КАК Префикс
	|ИЗ
	|	РегистрСведений.ПрефиксыИнформационныхБаз КАК ПрефиксыИнформационныхБаз";
	
	ВыборкаУзлов = Запрос.Выполнить().Выбрать();
	Пока ВыборкаУзлов.Следующий() Цикл
		
		Если Не ПустаяСтрока(ВыборкаУзлов.Префикс) Тогда
			
			МассивПрефиксов.Добавить(ВыборкаУзлов.Префикс);
			
		КонецЕсли;
		
	КонецЦикла;	
	
	Возврат МассивПрефиксов;
	
КонецФункции

// Функция предназначена для формирования массива префиксов.
//
// Параметры:
//  Организация - (СправочникСсылка), дял которой нужно получить префиксы.
//
// Возвращаемое значение.
//  Массив префиксов
//
Функция СформироватьМассивПрефиксовДляРИБИОрганизации(Организация) Экспорт
	
	МассивПрефиксов = ПолучитьМассивПрефиксовРИБ();	
	
	Если ЗначениеЗаполнено(Организация) Тогда
		
		Префикс = СокрЛП(Организация.Префикс);
		
		Если Префикс <> "" Тогда
			МассивПрефиксов.Добавить(Префикс);
		КонецЕсли;
		
	КонецЕсли;
	
	Если МассивПрефиксов.Количество() = 0 Тогда
		МассивПрефиксов.Добавить("");
	КонецЕсли;
	
	Возврат МассивПрефиксов;
	
КонецФункции

Функция СформироватьМассивПрефиксовПоОрганизации(Организация) Экспорт
	
	МассивПрефиксов = Новый Массив;
	
	Если ЗначениеЗаполнено(Организация) Тогда
		
		Префикс = СокрЛП(Организация.Префикс);
		
		Если Префикс <> "" Тогда
			
			МассивПрефиксов.Добавить(Префикс);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если МассивПрефиксов.Количество() = 0 Тогда
		
		МассивПрефиксов.Добавить("");
		
	КонецЕсли;
	
	Возврат МассивПрефиксов;
	
КонецФункции

// Функция формирует представление суммы прописью в указанной валюте
//
// Возвращаемое значение:
//  Строка - сумма прописью
//
Функция СформироватьСуммуПрописью(Сумма, Валюта, КодЯзыка = "ru") Экспорт
	
	ПараметрыПрописи = Локализация.ПараметрыПрописи(Валюта, КодЯзыка); 
	Если ПараметрыПрописи = "" Тогда
		Возврат ФорматСумм(Сумма);
	Иначе
		Возврат ЧислоПрописью(Сумма,"Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка),ПараметрыПрописи);
	КонецЕсли;
	
КонецФункции // СформироватьСуммуПрописью()

// Функция формирует представление заголовка документа
//
// Возвращаемое значение:
//  Строка - представление номера документа
//
Функция СформироватьЗаголовокДокумента(ДокументОбъект, НазваниеДокумента = "", КодЯзыка = "ru") Экспорт
	
	//Если КодЯзыка = Неопределено Тогда 
	//	КодЯзыка = Локализация.ПолучитьЯзыкФормированияПечатныхФорм(УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(глЗначениеПеременной("глТекущийПользователь"), "РежимФормированияПечатныхФорм"));
	//КонецЕсли;
	
	Возврат "" + НазваниеДокумента + " № " + ПолучитьНомерНаПечать(ДокументОбъект)
	+ НСтр("ru=' от ';uk=' від '",КодЯзыка) + Формат(ДокументОбъект.Дата, "ДФ='дд ММММ гггг';Л="+ Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка))
	+ НСтр("ru=' г.';uk=' р.'",КодЯзыка);
	
КонецФункции // СформироватьЗаголовокДокумента()

Функция СформироватьМассивПрефиксовОбособленныхПодразделенийОрганизации(Организация,МассивПрефиксов = Неопределено) Экспорт
	
	Если МассивПрефиксов = Неопределено Тогда 
		МассивПрефиксов = Новый Массив();
	КонецЕсли;	
	
	Если ЗначениеЗаполнено(Организация) Тогда
		
		ВыборкаОбособленныхПодразделений = Справочники.ОбособленныеПодразделенияОрганизаций.Выбрать(,Организация);
		
		Пока ВыборкаОбособленныхПодразделений.Следующий() Цикл
			ПрефиксНН = СокрЛП(ВыборкаОбособленныхПодразделений.Префикс);
			Если ПрефиксНН <> "" Тогда
				МассивПрефиксов.Добавить(ПрефиксНН);
			КонецЕсли;	
		КонецЦикла;	
		
	КонецЕсли;	
	
	Если МассивПрефиксов.Количество() = 0 Тогда
		МассивПрефиксов.Добавить("");
	КонецЕсли;
	
	Возврат МассивПрефиксов;
	
КонецФункции

Процедура УдалитьПрефиксОбособленногоПодразделенияИзНомера(Документ, МетаданныеДокумента, Номер)
	
	Если МетаданныеДокумента = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если МетаданныеДокумента.Имя = "НалоговаяНакладная" Тогда
		ОбособленноеПодразделение = Документ.ОбособленноеПодразделение;
	ИначеЕсли МетаданныеДокумента.Имя = "Приложение2КНалоговойНакладной" Тогда
		ОбособленноеПодразделение = Документ.НалоговаяНакладная.ОбособленноеПодразделение;
	Иначе
		Возврат;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ОбособленноеПодразделение)
		ИЛИ НЕ ЗначениеЗаполнено(ОбособленноеПодразделение.Префикс) Тогда
		Возврат;
	КонецЕсли;
	
	Префикс = СокрЛП(ОбособленноеПодразделение.Префикс);
	
	// удаляем ведущие нули у префикса
	Пока    Лев(Префикс, 1) = "0" Цикл
		Префикс = Сред(Префикс, 2);	
	КонецЦикла;
	
	// удалим из номера собственно префикс
	Если Лев(Номер, СтрДлина(Префикс)) = Префикс Тогда
		Номер = Сред(Номер, СтрДлина(Префикс) + 1);	
	КонецЕсли;
	
	// теперь удалим ведущие нули из остатка номера
	Пока    Лев(Номер, 1) = "0" Цикл
		Номер = Сред(Номер, 2);	
	КонецЦикла;
	
КонецПроцедуры

Процедура УдалитьНомераДняИзНомера(Документ, МетаданныеДокумента, Номер)
	
	Если МетаданныеДокумента = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ МетаданныеДокумента.Имя = "НалоговаяНакладная" 
		И НЕ МетаданныеДокумента.Имя = "Приложение2КНалоговойНакладной" Тогда
		Возврат;
	КонецЕсли;
	
	ПрефиксДневнойНумерации = ПолучитьДневнойПрефиксНалоговыхДокументов(Документ.Дата);
	
	// удалим из номера префикс дневной нумерации
	Если Лев(Номер, СтрДлина(ПрефиксДневнойНумерации)) = ПрефиксДневнойНумерации Тогда
		Номер = Сред(Номер, СтрДлина(ПрефиксДневнойНумерации) + 1);	
	КонецЕсли;
	
	// теперь удалим ведущие нули из остатка номера
	Пока    Лев(Номер, 1) = "0" Цикл
		Номер = Сред(Номер, 2);	
	КонецЦикла;
	
КонецПроцедуры

// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция ПолучитьНомерНаПечать(Документ, МассивПрефиксов = Неопределено, ПечатьПрефиксовРИБ = Истина) Экспорт
	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;
	
	Номер   = СокрЛП(Документ.Номер);
	ПрефиксДоверенности = "";
	
	МетаданныеДокумента = Неопределено;
	
	ПечатьПрефиксовРИБ = ОбщегоНазначения.ПолучитьЗначениеПеременной("ПечатьПрефиксаРИБ") И ПечатьПрефиксовРИБ;
	Если ПечатьПрефиксовРИБ Тогда
		МассивПрефиксовРИБ = ПолучитьМассивПрефиксовРИБ();
		ПрефиксРИБ = "";
		Для каждого ПрефиксРИБИзМассива Из МассивПрефиксовРИБ Цикл
			Если Найти(Номер, ПрефиксРИБИзМассива)=1 Тогда 
				Номер = Сред(Номер, СтрДлина(ПрефиксРИБИзМассива)+1);
				ПрефиксРИБ = ПрефиксРИБ + ПрефиксРИБИзМассива;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если МассивПрефиксов = Неопределено Тогда
		
		Организация = Неопределено;
		
		Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса")
			ИЛИ ТипЗнч(Документ) = Тип("Структура") Тогда
			
			Организация = Документ.Организация;
			
		Иначе
			
			МетаданныеДокумента = Документ.Метаданные();
			
			Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда
				
				Организация = Документ.Организация;
				
			КонецЕсли;
			
			Если МетаданныеДокумента.Имя = "Доверенность" Тогда
				ПрефиксДоверенности = "Д";
			КонецЕсли;
			
		КонецЕсли;
		
		МассивПрефиксов = СформироватьМассивПрефиксовДляРИБИОрганизации(Организация);
		
		//СформироватьМассивПрефиксовОбособленныхПодразделенийОрганизации(Организация, МассивПрефиксов);
		
		Если ПрефиксДоверенности <> "" Тогда
			МассивПрефиксов.Добавить(ПрефиксДоверенности);
		КонецЕсли;
		
	КонецЕсли;
	
	
	
	Для Каждого ТекущийПрефикс ИЗ МассивПрефиксов Цикл
		
		// удаление префикса из номера документа
		Если Найти(Номер, ТекущийПрефикс)=1 Тогда 
			Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
		КонецЕсли;
		
		// так же, может остаться "минус" впереди
		Если Лев(Номер, 1) = "-" Тогда
			Номер = Сред(Номер, 2);
		КонецЕсли;
		
		// удаление ведущих нулей
		Пока Лев(Номер, 1)="0" Цикл
			Номер = Сред(Номер, 2);
		КонецЦикла;
	КонецЦикла;
	
	Если НЕ МетаданныеДокумента = Неопределено Тогда
		Если МетаданныеДокумента.Имя = "НалоговаяНакладная"
			ИЛИ МетаданныеДокумента.Имя = "Приложение2КНалоговойНакладной" Тогда
			
			УдалитьПрефиксОбособленногоПодразделенияИзНомера(Документ, МетаданныеДокумента, Номер);
			
			МассивПрефиксовНН = Новый Массив();
			
			ТекМесяц = '20000101';
			Для Инд = 1 По 12 Цикл
				МассивПрефиксовНН.Добавить("Н"+ПолучитьМесячныйПрефиксНалоговыхДокументов(ТекМесяц));
				МассивПрефиксовНН.Добавить("П"+ПолучитьМесячныйПрефиксНалоговыхДокументов(ТекМесяц));
				ТекМесяц = ДобавитьМесяц(ТекМесяц, 1);
			КонецЦикла;
			ТекМесяц = '20000101';
			Для Инд = 1 По 12 Цикл
				МассивПрефиксовНН.Добавить(ПолучитьМесячныйПрефиксНалоговыхДокументов(ТекМесяц));
				ТекМесяц = ДобавитьМесяц(ТекМесяц, 1);
			КонецЦикла;
			МассивПрефиксовНН.Добавить("Н");
			МассивПрефиксовНН.Добавить("П");
			МассивПрефиксовНН.Добавить("U");
			МассивПрефиксовНН.Добавить("V");
			МассивПрефиксовНН.Добавить("W");
			
			Для Каждого ТекущийПрефикс ИЗ МассивПрефиксовНН Цикл
				Если Найти(Номер, ТекущийПрефикс)=1 Тогда 
					Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
				КонецЕсли;
				Пока Лев(Номер, 1)="0" Цикл
					Номер = Сред(Номер, 2);
				КонецЦикла;
			КонецЦикла;
			
			
			// для налоговых документов не печатаем префикс базы в любом случе, это противоречит порядку заполнения
			// для исключения коллизий с одинаковостью номеров в разных узлах необходимо исользовать обособленные подразделения
			// для каждого из узлов
			ПечатьПрефиксовРИБ = Ложь;
			
		КонецЕсли;
	КонецЕсли;
	
	УдалитьНомераДняИзНомера(Документ, МетаданныеДокумента, Номер);
	
	Если ПечатьПрефиксовРИБ И ПрефиксРИБ <> "" Тогда
		Номер = ПрефиксРИБ + Номер;
	КонецЕсли;
	
	Возврат Номер;
	
КонецФункции // ПолучитьНомерНаПечать()

// Функция выполняет проверку необходимости проведения документа по разделам учета
Функция ПроводитьДокументПоРазделуУчета(Организация, РазделУчета, Дата) Экспорт
	
	Если Константы.НеИспользоватьДатуАктуальностиУчета.Получить() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ТипЗнч(РазделУчета) <> Тип("ПеречислениеСсылка.РазделыУчета") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИмяПеречисления = "";
	Для Каждого ЗначениеПеречисления Из РазделУчета.Метаданные().ЗначенияПеречисления Цикл
		Если Перечисления.РазделыУчета[ЗначениеПеречисления.Имя] = РазделУчета Тогда
			ИмяПеречисления = ЗначениеПеречисления.Имя;
		КонецЕсли;
	КонецЦикла;
	
	Если НЕ ЗначениеЗаполнено(ИмяПеречисления) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	1 КАК ЗаписьРегистра
	|ИЗ
	|	(ВЫБРАТЬ ПЕРВЫЕ 1
	|		КОНЕЦПЕРИОДА(ДатаАктуальностиУчета."+ИмяПеречисления+", ДЕНЬ) КАК ДатаАктуальности,
	|		ВЫБОР
	|			КОГДА ДатаАктуальностиУчета.Организация = &Организация
	|				ТОГДА 1
	|			ИНАЧЕ 2
	|		КОНЕЦ КАК Порядок
	|	ИЗ
	|		РегистрСведений.ДатаАктуальностиУчета КАК ДатаАктуальностиУчета
	|	ГДЕ
	|		(ДатаАктуальностиУчета.Организация = &Организация
	|				ИЛИ ДатаАктуальностиУчета.Организация = &ПустаяОрганизация)
	|		И ДатаАктуальностиУчета."+ИмяПеречисления+" <> ДАТАВРЕМЯ(1, 1, 1)
	|	
	|	УПОРЯДОЧИТЬ ПО
	|		Порядок) КАК МаксимальнаяДата
	|ГДЕ
	|	МаксимальнаяДата.ДатаАктуальности <= &ДатаДокумента";
	
	Запрос.УстановитьПараметр("Организация", Организация);            
	Запрос.УстановитьПараметр("ПустаяОрганизация", Справочники.Организации.ПустаяСсылка());
	Запрос.УстановитьПараметр("ДатаДокумента", Дата);
	Возврат Запрос.Выполнить().Пустой();
	
КонецФункции

// Процедура выводит информацию о том что документ будет проводится с упрощением по указанным разделам учета
Процедура СообщитьОНеактуальностиУчета(СтруктураШапкиДокумента, ПроверяемыРазделы, Заголовок) Экспорт
	
	Если НЕ СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете")
		ИЛИ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете = Ложь Тогда
		// документ не проводится по регл учету - сообщать не нужно
		Возврат
		
	КонецЕсли;
	
	ТекстСообщения = "";
	Для каждого Раздел Из ПроверяемыРазделы Цикл
		Если Раздел = Перечисления.РазделыУчета.ОценкаМПЗ И НЕ ПроводитьДокументПоРазделуУчета(СтруктураШапкиДокумента.Организация, Перечисления.РазделыУчета.ОценкаМПЗ, СтруктураШапкиДокумента.Дата) Тогда
			ТекстСообщения = ТекстСообщения + Символы.ПС + Символы.Таб + "Учет партий МПЗ не актуален. Проводки по списанным партиям будут сформированы без указания суммы.";
		КонецЕсли;
		Если Раздел = Перечисления.РазделыУчета.РасчетыСКонтрагентами И НЕ ПроводитьДокументПоРазделуУчета(СтруктураШапкиДокумента.Организация, Перечисления.РазделыУчета.РасчетыСКонтрагентами, СтруктураШапкиДокумента.Дата) Тогда
			ТекстСообщения = ТекстСообщения + Символы.ПС + Символы.Таб + "Учет взаиморасчетов с контрагентами не актуален. Проводки по зачету авансов сформированы не будут.";
		КонецЕсли;
	КонецЦикла; 
	Если НЕ ПустаяСтрока(ТекстСообщения) Тогда
		СообщитьИнформацию(Заголовок + ТекстСообщения);
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает массив документов в периоде, соответствующем
// дате переданного документа и того же типа.
// Данную функцию можно использовать, например для проверки
// уникальности документа данного типа в указанном периоде
// Выбираются проведенные и не помеченые на удаление документы.
// Переданный в качестве параметра документ не попадает в выборку.
//
//	Параметры:
//		Док - документ
//  	Периодичность - период интервала. Например
//			Док.Дата = '15.01.2004', периодичность = "Месяц", тогда
//			будут выбиратся документы за январь 2004 года.
//	  		Возможные значения периодичности = "Год", "Квартал", "Месяц", "Неделя", "День"
//	  		По умолчанию - "Месяц"
//  	СтруктРеквизитов - структура в которой в качестве ключа - имя реквизита
//			документа, в качестве значения - значение, которое должен содержать реквизит документа.
//			Будут выбираться документы в которых значение реквизита совпадает с указанным
//		 	значением.
//
//	Возврат:
//		Массив документов.
Функция ДокументыВПериоде(Док, Периодичность = "Месяц", СтруктРеквизитов = Неопределено) Экспорт
	Перем НачДата;
	Перем КонДата;
	Перем Запрос;
	
	// определим период в котором будем искать
	Если Периодичность = "Год" Тогда
		НачДата = НачалоГода(Док.Дата);
		КонДата = КонецГода (Док.Дата);
	ИначеЕсли Периодичность = "Квартал" Тогда
		НачДата = НачалоКвартала(Док.Дата);
		КонДата = КонецКвартала (Док.Дата);
	ИначеЕсли Периодичность = "Месяц"   Тогда
		НачДата = НачалоМесяца(Док.Дата);
		КонДата = КонецМесяца (Док.Дата);
	ИначеЕсли Периодичность = "Неделя"  Тогда
		НачДата = НачалоНедели(Док.Дата);
		КонДата = КонецНедели (Док.Дата);
	ИначеЕсли Периодичность = "День"  Тогда
		НачДата = НачалоДня(Док.Дата);
		КонДата = КонецДня (Док.Дата);
	Иначе
		СообщитьОбОшибке("Неверное значение параметра ""Периодичность"": " + Периодичность + "!");
		Возврат Новый Массив;
	КонецЕсли;
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Док.Ссылка КАК Док
	|
	|ИЗ
	|   Документ." + Док.Метаданные().Имя + " КАК Док
	|
	|ГДЕ
	|   Док.Дата МЕЖДУ &НачДата И &КонДата И
	|   Док.Проведен И НЕ Док.ПометкаУдаления И
	|   НЕ Док.Ссылка = &ДокСсылка
	|";
	
	Запрос = Новый Запрос;
	
	Если Не СтруктРеквизитов = Неопределено Тогда
		Для Каждого Ключ Из СтруктРеквизитов Цикл
			Запрос.УстановитьПараметр(Ключ.Ключ, Ключ.Значение);
			ТекстЗапроса = ТекстЗапроса + " И
			|Док." + Ключ.Ключ + " = &" + Ключ.Ключ;
		КонецЦикла;
	КонецЕсли;
	
	Запрос.Текст = ТекстЗапроса;
	
	Запрос.УстановитьПараметр("НачДата",   НачДата);
	Запрос.УстановитьПараметр("КонДата",   КонДата);
	Запрос.УстановитьПараметр("ДокСсылка", Док.Ссылка);
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Док");
	
КонецФункции // ДокументыВПериоде()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ


// Функция определяет наличие хотя бы одного элемента в справочнике
//
// Параметры
//  ИмяСправочника - строка
//
// Возвращаемое значение:
//   Булево
//
Функция ЕстьЭлементыВСправочнике(ИмяСправочника) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Спр.Ссылка
	|ИЗ
	|	Справочник." + ИмяСправочника + " КАК Спр";
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Удаляет повторяющиеся значения из массива
//
// Параметры:
//	Массив
//
Процедура УдалитьПовторяющиесяЭлементы(Массив) Экспорт
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда
		
		ОписаниеТиповСправочники = Справочники.ТипВсеСсылки();
		ОписаниеТиповДокументы = Документы.ТипВсеСсылки();
		ОписаниеТиповПВХ = ПланыВидовХарактеристик.ТипВсеСсылки();
		ОписаниеТиповПланыСчетов = ПланыСчетов.ТипВсеСсылки();
		ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки();
		БылоНеопределено = Ложь;
		
		Если ТипЗнч(Массив) = Тип("Массив") Тогда
			
			УжеВМасссиве = Новый Соответствие;
			
			КолвоЭлементовВМассиве = Массив.Количество();
			
			Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл
				ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс];
				
				Если ЭлементМассива = Неопределено Тогда
					Если БылоНеопределено Тогда
						Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс);
					Иначе
						БылоНеопределено = Истина;					
					КонецЕсли;
					Продолжить;
				КонецЕсли;				
				
				ТипЭлемента = ТипЗнч(ЭлементМассива);
				
				
				
				Если (ОписаниеТиповСправочники.СодержитТип(ТипЭлемента)
					ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента)
					ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента)
					ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента)
					ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента)) Тогда
					
					ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор());
					
				Иначе
					
					ИДЭлемента = ЭлементМассива;
					
				КонецЕсли;
				
				Если УжеВМасссиве[ИДЭлемента] = Истина Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс);
				Иначе
					УжеВМасссиве.Вставить(ИДЭлемента, Истина);
				КонецЕсли;
			КонецЦикла;	
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Функция формирует фамилию и инициалы
//
// Параметры
//  Фамилия  - фамилия физ. лица.
//  Имя      - имя физ. лица.
//  Отчество - отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия, имя, отчество одной строкой.
//
Функция ПолучитьФамилиюИмяОтчество(Фамилия = " ", Имя = " ", Отчество = " ", Кратко = Истина) Экспорт
	
	Если Кратко Тогда
		Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + 
		?(НЕ ПустаяСтрока(Отчество) , 
		Лев(Отчество,1)+".", ""), ""), "");
	Иначе
		Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Имя + 
		?(НЕ ПустаяСтрока(Отчество) , " " + Отчество, ""), ""), "");
	КонецЕсли;
	
КонецФункции // ПолучитьФамилиюИмяОтчество()

// Разворачивает таблицу  значений по вложенной таблице
//
// Параметры
//  ТаблицаЗначений  – <ТаблицаЗначений> – базовая таблица
//  КолонкаВложеннойТаблицы  – <Строка> – Наименование колонки влолженной таблицы
//  СписокРаспределяемыхКолонок  – <Структура> – Структура с именами колонок базовой таблицы, значения которых будут распределяться по колонке вложенной таблицы
//         						Ключ - Имя колонки базовой таблицы
//         						Значение - Имя колонки вложенной таблицы. Если во вложенной таблице колонка не обнаружена - обработка прекращается.
// Возвращаемое значение:
//   <ТаблицаЗначений>   – таблица значений, развернутая по значениям вложенной таблицы.
//
// При совпадении имен базовой и вложенной таблиц - если  
Функция РазвернутьПоВложеннойТаблице(ТаблицаЗначений, КолонкаВложеннойТаблицы,СписокРаспределяемыхКолонок, СписокИсключаемыхКолонок, СообщатьОбОшибке = Истина) Экспорт
	
	Если ТаблицаЗначений.Количество()=0 Тогда
		// Таблица не заполнена, софрмировать новую таблицу не представляется возможнным
		// Отсуттствует вложенная таблица, структуру данных выходной таблицы сформировать невозможно
		Если СообщатьОбОшибке Тогда
			СообщитьОбОшибке("Отстутствуют строки в базовой таблице, распределение по вложенной таблице невозможно.",,,СтатусСообщения.Внимание);
		КонецЕсли; 
		Возврат Неопределено;
	КонецЕсли; 
	
	КолонкиВложеннойТаблицы = ТаблицаЗначений[0][КолонкаВложеннойТаблицы].Колонки;
	//Заполним значения по тем колонкам, по которым не были заполены значения ранее
	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
		Если НЕ ЗначениеЗаполнено(Колонка.Значение) Тогда
			СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
		КонецЕсли;
		Если КолонкиВложеннойТаблицы.Найти(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено Тогда
			// Во вложенной таблице не обнаружена колонка, по которой производится распределение.
			Если СообщатьОбОшибке Тогда
				Если НЕ ЗначениеЗаполнено(Колонка.Значение) Тогда
					СообщитьОбОшибке(Локализация.СтрШаблон("Во вложенной таблице не обнаружена колонка (¤1¤), по которой производится распределение.", Колонка.Ключ),,,СтатусСообщения.Внимание);
				Иначе
					СообщитьОбОшибке(Локализация.СтрШаблон("Во вложенной таблице не обнаружена колонка (¤1¤), по которой производится распределение.", Колонка.Значение),,,СтатусСообщения.Внимание);
				КонецЕсли;	
			КонецЕсли; 
			Возврат Неопределено;
		КонецЕсли; 
	КонецЦикла;
	
	НоваяТаблицаЗначений = Новый ТаблицаЗначений();
	Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если Колонка.Имя = КолонкаВложеннойТаблицы Тогда
			Продолжить;
		ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
	КонецЦикла; 
	
	Для каждого Колонка Из КолонкиВложеннойТаблицы Цикл
		Если не НоваяТаблицаЗначений.Колонки.Найти(Колонка.Имя) = неопределено Тогда
			Продолжить;
		ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
	КонецЦикла; 
	
	Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 
		
		ТаблицаДляРаспределения = СтрокаБазовойТаблицы[КолонкаВложеннойТаблицы];
		
		Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл
			
			СтрокаНовойТаблицы = НоваяТаблицаЗначений.Добавить();
			
			Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл
				
				Если СписокРаспределяемыхКолонок.Свойство(Колонка.Имя) тогда
					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[СписокРаспределяемыхКолонок[Колонка.Имя]];
					
				ИначеЕсли не КолонкиВложеннойТаблицы.Найти(Колонка.Имя) = Неопределено тогда
					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[Колонка.Имя];
					
				ИначеЕсли Не(ТаблицаЗначений.Колонки.Найти(Колонка.Имя)=Неопределено) тогда
					СтрокаНовойТаблицы[Колонка.Имя] = СтрокаБазовойТаблицы[Колонка.Имя];
					
				Иначе
					// Колонка не найдена... Неизвестно, как такое может произойти
					Если СообщатьОбОшибке Тогда
						СообщитьОбОшибке(Локализация.СтрШаблон("при распределении по вложенной таблице невозможно определить значение для колонки :¤1¤.", Колонка.Имя),,,СтатусСообщения.Внимание);
					КонецЕсли; 
					
				КонецЕсли;
				
			КонецЦикла; // Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл
			
		КонецЦикла; // Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл
		
	КонецЦикла; // Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 
	
	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
		СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
	КонецЦикла;
	
	// Распределение базовых данных по распределяемым колонкам
	НоваяТаблицаЗначений = СформироватьКорректирующиеЗаписи(ТаблицаЗначений,НоваяТаблицаЗначений,СписокРаспределяемыхКолонок);
	
	Возврат НоваяТаблицаЗначений;
	
КонецФункции // РазвернутьПоВложеннойТаблице()

// Выводит информационное сообщение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - строка, заголовок.
//  Статус         - СтатусСообщения
//
Процедура СообщитьИнформацию(ТекстСообщения, Заголовок = "", Статус = Неопределено) Экспорт
	
	#Если Клиент Тогда
		
		Если Статус = Неопределено Тогда
			
			Статус = СтатусСообщения.Информация;
			
		КонецЕсли; 
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			
			Сообщить(Заголовок);
			Заголовок = "";
			
		КонецЕсли;
		
		Сообщить(ТекстСообщения, Статус);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьИнформацию()

// Выводит информационное сообщение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - строка, заголовок.
//  Статус         - СтатусСообщения
//
Процедура СообщитьСлужебнуюИнформацию(ТекстСообщения, Заголовок = "", Статус = Неопределено) Экспорт
	
	#Если Клиент Тогда
		Если ПараметрыСеанса.ВыводитьСлужебнуюИнформацию = Истина Тогда
			
			СообщитьИнформацию(ТекстСообщения, Заголовок, Статус);
			
		КонецЕсли;
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьИнформацию()

//Процедура для распределения записей из одной таблицы значений по базису (таблица значений или  набору записей)
//Источник 		: ТаблицаЗначений
//Базис 		: ТаблицаЗначений или НаборЗаписей
//Распределение : ключ - поля базиса, значение - поля источника
//Фильтр 		: ключ - поля базиса, значение - поля источника (если не укзан - по совпадающим колонкам)
//Игнорировать  : ключ - поля базиса, значение - поля источника
//Дополнить		: ключ - имя нового поля базиса, значение - значение для заполнения
Функция СформироватьКорректирующиеЗаписи(Источник,Базис,Распределение,Фильтр=неопределено,Игнорировать=Неопределено,Дополнить=Неопределено) Экспорт
	
	Если ТипЗнч(Базис) = Тип("ТаблицаЗначений") тогда
		Временный_Базис = Базис.Скопировать();
		
	Иначе
		Временный_Базис = Базис.Выгрузить();
		
	Конецесли;
	
	КолонкиИсточника = Новый Структура();
	
	Для Каждого Колонка Из источник.Колонки Цикл
		КолонкиИсточника.Вставить(Колонка.Имя);
	КонецЦикла;
	
	КолонкиБазиса = Новый Структура();
	
	Для Каждого Колонка Из Временный_Базис.Колонки Цикл
		
		Если Не(НЕ ЗначениеЗаполнено(Колонка.Имя)) тогда
			КолонкиБазиса.Вставить(Колонка.Имя);
		КонецЕсли;
		
	КонецЦикла;
	
	Если НЕ (ТипЗнч(Игнорировать) = Тип("Структура")) Тогда
		Игнорировать = Новый Структура();
	Иначе
		
		//Зачистим колонки источника и базиса на игнорируемые колонки
		Для Каждого Колонка Из Игнорировать Цикл
			
			Если КолонкиИсточника.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
				КолонкиИсточника.Удалить(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
			Конецесли;
			
			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
				КолонкиБазиса.Удалить(Колонка.Ключ);
			Конецесли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	//Зачистим колонки источника на распределяемые колонки. Они учитываются отдельно.
	Для Каждого Колонка Из Распределение Цикл
		Если КолонкиИсточника.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
			КолонкиИсточника.Удалить(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
		Иначе
			Если Источник.Колонки.Найти(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено тогда
				//Не хватает колонок к распределению
				//Но одну и ту же колонку можно распределить дважды
				Возврат ложь;
			КонецЕсли;
		Конецесли;
		Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
			КолонкиБазиса.Удалить(Колонка.Ключ);
		Иначе
			//Не хватает колонок базиса распределения
			Возврат ложь;
		Конецесли;
	КонецЦикла;
	
	Если (ТипЗнч(Дополнить) = Тип("Структура"))
		И НЕ (Дополнить.Количество() = 0) Тогда
		//Проверим на отсутствие дополняемых колонок!
		Для Каждого Колонка Из Дополнить Цикл
			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
				//Такая колонка уже есть, нельзя добавить новую
				Возврат Ложь;
			Конецесли;
		КонецЦикла;
	КонецЕсли;
	
	//Если фильтр не задан - по всем совпадающим колонкам
	Если Фильтр=Неопределено тогда
		Фильтр = Новый Структура();
		Для каждого Колонка из КолонкиБазиса цикл
			Если КолонкиИсточника.Свойство(Колонка.Ключ)  и не(Игнорировать.Свойство(Колонка.Ключ)) тогда
				Фильтр.Вставить(Колонка.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если НЕ (ТипЗнч(Фильтр) = Тип("Структура") И НЕ (Фильтр.Количество() = 0)) Тогда
		//Должно быть хоть одно объединяющее поле!
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого Колонка Из Фильтр Цикл
		Если не КолонкиБазиса.Свойство(Колонка.Ключ) тогда
			//Не хватает колонок базиса распределения
			Возврат ложь;
		Конецесли;
	КонецЦикла;
	
	
	//Подготовить сворачивание для источника
	СтрокаСверткиИсточник = ВыгрузитьСтруктуруВСтроку(Фильтр,Истина,КолонкиИсточника);
	Если СтрокаСверткиИсточник = ложь Тогда
		//попытка фильтровать по полю, отсутствующему в источнике!
		Возврат ложь;
	КонецЕсли;
	КолонкиКРаспределениюИсточник = ВыгрузитьСтруктуруВСтроку(Распределение,Истина);
	Если КолонкиКРаспределениюИсточник = ложь Тогда
		//попытка распределить поле, отсутствующее в источнике!
		Возврат ложь;
	КонецЕсли;
	
	//Подготовить сворачивание для базиса
	СтрокаСверткиБазис = ВыгрузитьСтруктуруВСтроку(КолонкиБазиса,Ложь);
	Если СтрокаСверткиБазис = ложь Тогда
		//попытка фильтровать по полю, отсутствующему в базисе!
		Возврат ложь;
	КонецЕсли;
	КолонкиКРаспределениюБазис = ВыгрузитьСтруктуруВСтроку(Распределение,Ложь);
	Если КолонкиКРаспределениюБазис = ложь Тогда
		//попытка распределить поле, отсутствующее в базисе!
		Возврат ложь;
	КонецЕсли;
	
	Временный_Источник = Источник.Скопировать();
	
	Временный_Базис.Свернуть(СтрокаСверткиБазис,КолонкиКРаспределениюБазис);
	Временный_Источник.Свернуть(СтрокаСверткиИсточник,КолонкиКРаспределениюИсточник);
	
	НоваяТаблица = новый ТаблицаЗначений();
	Для каждого Колонка из Временный_Базис.Колонки Цикл
		НоваяТаблица.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,,10);
	КонецЦикла;
	
	ТаблицаБазисовРаспределения = Новый ТаблицаЗначений();
	Для каждого Колонка из Распределение Цикл
		ТаблицаБазисовРаспределения.Колонки.Добавить(Колонка.Ключ);
	КонецЦикла;
	
	//установим индексы таблицы для поиска
	СтрокаИндекса = "";
	Для каждого Колонка из Фильтр цикл
		Если СтрокаИндекса = "" Тогда
			СтрокаИндекса = Колонка.Ключ;
		Иначе
			СтрокаИндекса = СтрокаИндекса + "," + Колонка.Ключ;
		КонецЕсли;
	КонецЦикла;
	Если СтрокаИндекса <> "" Тогда
		Временный_Базис.Индексы.Добавить(СтрокаИндекса);
	КонецЕсли;
	
	Для каждого СтрокаИсточника из Временный_Источник цикл
		Отбор = новый структура();
		Для каждого Колонка из Фильтр цикл
			Отбор.Вставить(Колонка.Ключ,СтрокаИсточника[?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)]);
		КонецЦикла;
		СтрокиБазиса = Временный_Базис.НайтиСтроки(Отбор);
		ТаблицаБазисовРаспределения.Очистить();
		Для каждого Строка из СтрокиБазиса Цикл
			СтрокаТБР = ТаблицаБазисовРаспределения.Добавить();
			Для каждого Колонка из ТаблицаБазисовРаспределения.Колонки цикл
				СтрокаТБР[Колонка.Имя] = Строка[Колонка.Имя];
			КонецЦикла;
		КонецЦикла;
		Для каждого Колонка из Распределение цикл
			РаспределяемаяСумма =  СтрокаИсточника[?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)];
			МассивДляРаспределения = ТаблицаБазисовРаспределения.ВыгрузитьКолонку(Колонка.Ключ);
			МассивРезультата = РаспределитьПропорционально(РаспределяемаяСумма, МассивДляРаспределения);
			Если МассивРезультата = неопределено тогда
				ТаблицаБазисовРаспределения.ЗаполнитьЗначения(0,Колонка.Ключ);
			Иначе	
				ТаблицаБазисовРаспределения.ЗагрузитьКолонку(МассивРезультата,Колонка.Ключ);
			КонецЕсли;
			
		КонецЦикла;
		
		СтрокаРезультата = 0;
		Для каждого Строка из СтрокиБазиса Цикл
			СтрокаНовая = НоваяТаблица.Добавить();
			СрокаРекультатаРаспределения = ТаблицаБазисовРаспределения[СтрокаРезультата];
			СтрокаРезультата = СтрокаРезультата +1;
			Для каждого Колонка из Временный_Базис.Колонки цикл
				Если Распределение.Свойство(Колонка.Имя) тогда
					СтрокаНовая[Колонка.Имя] = СрокаРекультатаРаспределения[Колонка.Имя];
				Иначе
					СтрокаНовая[Колонка.Имя] = Строка[Колонка.Имя];
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	Если (ТипЗнч(Дополнить) = Тип("Структура"))
		И НЕ (Дополнить.Количество() = 0) Тогда
		Для Каждого Колонка Из Дополнить Цикл
			НоваяТаблица.Колонки.Добавить(Колонка.Ключ,,,10);
			НоваяТаблица.ЗаполнитьЗначения(Колонка.Значение,Колонка.Ключ);
		КонецЦикла;
	КонецЕсли;
	
	СтрокиС0Распределением = Новый Массив();
	
	Для каждого Строка из НоваяТаблица цикл
		
		СуммаРаспределений0 = Истина;
		
		Для каждого Колонка из распределение цикл
			Если ЗначениеЗаполнено(Строка[Колонка.Ключ]) тогда
				СуммаРаспределений0=Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если СуммаРаспределений0 тогда
			СтрокиС0Распределением.Добавить(Строка);
		Конецесли;
		
	КонецЦикла;
	
	Для каждого ПустаяСтрока из СтрокиС0Распределением Цикл 
		НоваяТаблица.Удалить(ПустаяСтрока);
	КонецЦикла;
	
	Возврат НоваяТаблица;
	
КонецФункции

// функция из исходной строки формирует строку для поиска данных в запросе
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");
	
	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 
	
	Возврат Истина;
	
КонецФункции

// Служебная функция, предназначенная для получения описания типов набора записей по объекту метаданных
// Параметры:
//	Значение - Null, Булево, Строка
//
// Возвращаемое значение:
// Число, полученное в результате преобразования
//
Функция ПреобразоватьВЧисло(Значение) Экспорт
	
	Если (Значение = Null) или (Значение = Неопределено) Тогда
		
		Возврат 0
		
	Иначе
		
		Попытка
			
			Возврат Число(Значение)
			
		Исключение
			
			Возврат 0
			
		КонецПопытки
		
	КонецЕсли;
	
	
КонецФункции // ПреобразоватьВЧисло()

////////////////////////////////////////////////////////////////////////////////
// МАТЕМАТИКА


// возвращает "количество полных и неполных рублей"
// Параметры:
//	Сумма - число
// Возвращаемое значение:
//  число, равное ближайшему целому "сверху"
Функция ЦелМаксимальное(Сумма) Экспорт
	Возврат ?(Цел(Сумма) = Сумма, Сумма, Цел(Сумма) + 1);
	
КонецФункции // ЦелМаксимальное()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА, ПЕРЕМЕННЫХ МОДУЛЯ ПРИЛОЖЕНИЯ


// Функция определяет наличие клиентских подключений к базе других пользователей
Функция ЕстьДругиеПользователиВБазе() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда			
			Возврат Истина;						
		КонецЕсли;		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Процедура удаления существующих движений документа при перепроведении (отмене проведения)
Процедура УдалитьДвиженияРегистратора(ДокументОбъект, Отказ) Экспорт
	
	// получение списка регистров, по которым существуют движения
	ТаблицаДвижений = ПолныеПрава.ОпределитьНаличиеДвиженийПоРегистратору(ДокументОбъект.Ссылка);
	ТаблицаДвижений.Колонки.Добавить("НаборЗаписей");
	ТаблицаДвижений.Колонки.Добавить("БезусловноеУдаление", Новый ОписаниеТипов("Булево"));
	
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		// имя регистра передается как значение, полученное с помощью
		// функции ПолноеИмя() метаданных регистра
		ПозицияТочки = Найти(СтрокаДвижения.Имя, ".");
		ТипРегистра = Лев(СтрокаДвижения.Имя, ПозицияТочки - 1);
		ИмяРегистра = СокрП(Сред(СтрокаДвижения.Имя, ПозицияТочки + 1));
		
		ЕСли ТипРегистра = "РегистрНакопления" Тогда
			МетаданныеНабора = Метаданные.РегистрыНакопления[ИмяРегистра];
			Набор = РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
			
		ИначеЕсли ТипРегистра = "РегистрБухгалтерии" Тогда
			МетаданныеНабора = Метаданные.РегистрыБухгалтерии[ИмяРегистра];
			Набор = РегистрыБухгалтерии[ИмяРегистра].СоздатьНаборЗаписей();
			
		ИначеЕсли ТипРегистра = "РегистрСведений" Тогда
			МетаданныеНабора = Метаданные.РегистрыСведений[ИмяРегистра];
			Набор = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
			
		ИначеЕсли ТипРегистра = "РегистрРасчета" Тогда
			МетаданныеНабора = Метаданные.РегистрыРасчета[ИмяРегистра];
			Набор = РегистрыРасчета[ИмяРегистра].СоздатьНаборЗаписей();
			
		КонецЕсли;
		
		Если НЕ ПравоДоступа("Изменение", МетаданныеНабора) Тогда
			// отсутствуют права на всю таблицу регистра
			СообщитьОбОшибке("Нарушение прав доступа", Отказ, СтрокаДвижения.Имя);
			Возврат;
		КонецЕсли;
		
		Набор.Отбор.Регистратор.Установить(ДокументОбъект.Ссылка);
		// набор не записывается сразу, чтобы не откатывать транзакцию, если впоследствии
		// выяснится, что на один из регистров не хватает прав.
		СтрокаДвижения.НаборЗаписей = Набор;
		
	КонецЦикла;
	
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		Если СтрокаДвижения.БезусловноеУдаление Тогда
			ПолныеПрава.ЗаписатьНаборЗаписейНаСервере(СтрокаДвижения.НаборЗаписей, ДокументОбъект.Ссылка);
		Иначе
			Попытка
				СтрокаДвижения.НаборЗаписей.Записать();
			Исключение
				// возможно «сработал» RLS или механизм даты запрета изменения
				СообщитьОбОшибке(ОписаниеОшибки(), Отказ, СтрокаДвижения.Имя);
				ВызватьИсключение "Операция не выполнена";
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	
	ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект);
	
	// Удаление записей регистрации из всех последовательностей
	УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, Истина);
	
КонецПроцедуры

// Функция загружает таблицы документа в таблицы соответствующие структуре регистров
//
// Параметры:
//  Движение - движение документа (т.е. регистр)
//  СтруктТаблицДокумента - структура содержашая таблицы документа. ключ - имя таблицы, значение - таблица значений с данными документа.
//
// Возвращаемое значение:
//  Структура, в которой ключ - это имя таблицы документа, соответствующий параметру СтруктТаблицДокумента,
//  значение - таблица значений, со структурой соответствующей структуре параметра (т.е. регистра) Движение
//  В таблицы значений данные загружаются по соответствию с имен полей.
//
Функция ЗагрузитьТаблицыДокументаВСтруктуру(Движение, СтруктТаблицДокумента) Экспорт
	
	ПустаяТабРегистра = Движение.Выгрузить();
	ПустаяТабРегистра.Очистить();
	
	СтруктДанных = Новый Структура;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
		
		ТабРегистра = ПустаяТабРегистра.Скопировать();
		
		Если ТабЧасть.Значение <> Неопределено И ТабЧасть.Значение.Количество() > 0 Тогда
			ЗагрузитьВТаблицуЗначений( ТабЧасть.Значение, ТабРегистра);
		КонецЕсли;
		
		СтруктДанных.Вставить( ТабЧасть.Ключ, ТабРегистра);
		
	КонецЦикла;
	
	Возврат СтруктДанных;
	
КонецФункции // ЗагрузитьТаблицыДокументаВСтруктуру()

// Процедура формирует движение в регистр на основании данных в таблицах документов
//
//Параметры:
//  Движение              - движение документа, в которое необходимо произвести добавление записей (т.е. регистр)
//  ВидДвижения           - вид движения накопления (приход/расход)
//  СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//  ДатаДвижения          - дата на которую будут формироваться записи
//
Процедура ЗаписатьТаблицыДокументаВРегистр(Движение, ВидДвижения, СтруктТаблицДокумента, ДатаДвижения) Экспорт
	
	Движение.мПериод = ДатаДвижения;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
		
		Если ТабЧасть.Значение.Количество() = 0 Тогда
			Продолжить; // Пропускаем пустые табличные части
		КонецЕсли;
		
		Движение.мТаблицаДвижений = ТабЧасть.Значение;
		Если ВидДвижения = Неопределено Тогда // Регистр сведений
			ВыполнитьДвижениеПоРегистру(Движение);
		Иначе // Регистр накопления
			ВыполнитьДвижениеПоРегистру(Движение, ВидДвижения);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ЗаписатьТаблицыДокументаВРегистр()

// Заполнение отбора значениями из таблицы значений.
// Соответствие полей устанавливается по представлению и типам значений
//
// Параметры
//  Отбор  – Отбор           – Отбор, который требуется заполнить значениями
//  ТЗ     – ТаблицаЗначений – Таблица содержит значения для отбора.
//                             Структура колонок повторяет структуру отбора
//
Процедура ЗаполнитьОтборПоТаблицеЗначений(Отбор, ТЗ) Экспорт
	
	Для каждого ЭлементОтбора Из ТЗ Цикл
		
		СтрокаТаблицы = Неопределено;
		
		Для каждого стр Из Отбор Цикл
			
			Если стр.Представление = ЭлементОтбора.Представление
				И стр.ТипЗначения = ЭлементОтбора.ТипЗначения Тогда
				Если ПустаяСтрока(стр.Представление)
					И ПустаяСтрока(стр.ПутьКданным) Тогда
					
					Продолжить;
					
				КонецЕсли;
				СтрокаТаблицы = стр;
				
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если ПустаяСтрока(ЭлементОтбора.ПутьКданным) Тогда
			Продолжить;
		КонецЕсли;
		
		Если СтрокаТаблицы = Неопределено Тогда
			
			СтрокаТаблицы = Отбор.Добавить(ЭлементОтбора.ПутьКданным, ЭлементОтбора.Имя, ЭлементОтбора.Представление);		
			
		КонецЕсли;
		
		СтрокаТаблицы.ВидСравнения = ЭлементОтбора.ВидСравнения;
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, ЭлементОтбора, "Значение, ЗначениеПо, ЗначениеС, Использование");
		
	КонецЦикла;
	
КонецПроцедуры // УстановитьОтборИзТаблицы(Отбор, ТЗ)

// Процедура выполняет открытие HTML-страницы 
// по указанному URL
Процедура Интерфейс1Действие() Экспорт
	Форма = Обработки.Обозреватель.ПолучитьФорму("Форма",,"Опрос");
	Форма.Заголовок = "Отзыв о программе";
	Форма.СтартоваяСтраница = "www.1c.ru/usability/inquirer/ut.jsp";
	Форма.Открыть();
КонецПроцедуры

// Процедура копирует значения одной строки таблицы значеницй в другую
// структура колонок должна совпадать
//
// Параметры:
//		СтрокаПриемник - строка в которую копируем
//		СтрокаИсточник - строка из которой копируем
//      ИменаКол - имена колонок, разделенные запятыми, которые надо скопировать
//                 необязателен. По умолчанию - все колонки
//
Процедура КопироватьСтрокуТаблицыЗначений(СтрокаПриемник, СтрокаИсточник, ИменаКол) Экспорт
	
	Если ТипЗнч( ИменаКол) = Тип("ТаблицаЗначений") Тогда
		СписокСвойств = "";
		Для Каждого Кол Из ИменаКол.Колонки Цикл
			Если Не Кол.Имя = "НомерСтроки" Тогда
				Если Не ПустаяСтрока(СписокСвойств) Тогда
					СписокСвойств = СписокСвойств + ",";	
				КонецЕсли;
				СписокСвойств = СписокСвойств + Кол.Имя;
			КонецЕсли;
		КонецЦикла;
		ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, СписокСвойств,);
	Иначе // Строка с именами колонок
		ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, ИменаКол,);
	КонецЕсли;
	
КонецПроцедуры // КопироватьСтрокуТаблицыЗначений()

//Предназначена для получения массива пустых значений, содержащих значение Неопределено и значения переданного типа или описания типов
Функция МассивПустыхЗначений(ОписаниеТипов) Экспорт
	МассивЗначений = новый Массив;
	МассивЗначений.Добавить(неопределено);
	Если ТипЗнч(ОписаниеТипов)=Тип("ОписаниеТипов") Тогда
		Для каждого Тип из ОписаниеТипов.Типы() Цикл
			МассивЗначений.Добавить(ПустоеЗначениеТипа(Тип));
		КонецЦикла;
	ИначеЕсли ТипЗнч(ОписаниеТипов)=Тип("Тип") Тогда	
		МассивЗначений.Добавить(ПустоеЗначениеТипа(ОписаниеТипов));
	КонецЕсли;
	
	Возврат МассивЗначений;
	
КонецФункции


Функция ОпределитьВозможностьРедактированияОбъекта(Ссылка) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ОбъектыЗапрещенныеДляРедактирования.Ссылка
	|ИЗ
	|	РегистрСведений.ОбъектыЗапрещенныеДляРедактирования КАК ОбъектыЗапрещенныеДляРедактирования
	|ГДЕ
	|	ОбъектыЗапрещенныеДляРедактирования.Ссылка = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	Если Не Запрос.Выполнить().Пустой() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция ОпределитьТекущийРежимРаботыМонопольный() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл
		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Процедура очищает коллекцию движений документа
//
Процедура ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект) Экспорт
	
	Для Каждого Движение ИЗ ДокументОбъект.Движения Цикл
		Если Движение.Количество() > 0 Тогда
			Движение.Очистить();
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Возвращает дату начала периода по имеющимся данным о:
// дате окончании периода, значении перечисления Период, количестве периодов.
// Кроме того, в случае, если задать отрицательную периодичность,- функция возвратит
// дату окончания периода по заданной дате начала периода
Функция ПолучитьДатуНачалаПериодаПоДатеОкончанияКоличествуПериодов(ДатаОкончания, ПериодСсылка, КоличествоПериодов) Экспорт
	
	Если КоличествоПериодов = 0 Тогда
		КоличествоПериодов = 1;
	КонецЕсли;
	
	Если ДатаОкончания = Неопределено Тогда
		
		Если КоличествоПериодов > 0 Тогда
			ДатаОкончания = КонецДня(ТекущаяДата());
		ИначеЕсли КоличествоПериодов < 0 Тогда
			ДатаОкончания = НачалоДня(ТекущаяДата());
		КонецЕсли;
		
	КонецЕсли;
	
	Если (ПериодСсылка = Перечисления.Периодичность.День) Тогда
		ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24 * КоличествоПериодов);
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Неделя) Тогда
		ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24*7 * КоличествоПериодов);
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Декада) Тогда
		ДеньМесяца = День(ДатаОкончания);
		НачМесяца = НачалоМесяца(ДатаОкончания);
		Если ДеньМесяца <= 10 Тогда
			НомерДекады = 1;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			НомерДекады = 2;
		Иначе
			НомерДекады = 3;
		КонецЕсли;
		
		НомерДекады = НомерДекады - КоличествоПериодов + ?(КоличествоПериодов > 0, 1 , -1);
		Если НомерДекады > 0 Тогда
			Месяцев = Цел((НомерДекады-1)/3);
		Иначе
			Месяцев = -1 - Цел((-НомерДекады)/3);
		КонецЕсли;
		
		НомерДекады = НомерДекады - 3*Месяцев;
		Дт = ДобавитьМесяц(НачМесяца, Месяцев) + (НомерДекады-1) * 10 * 24 * 60 * 60;
		
		Возврат ?(КоличествоПериодов>0, Дт, ПолучитьКонецДекады(Дт));
		
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Месяц) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Квартал) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(3 * КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Полугодие) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(6 * КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Год) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(12 * КоличествоПериодов)));
	КонецЕсли;
	
	Если КоличествоПериодов > 0 Тогда
		Возврат ДатаНачала + 60*60*24;
	ИначеЕсли КоличествоПериодов < 0 Тогда
		Возврат КонецДня(ДатаНачала - 60*60*24);
	КонецЕсли;
	
КонецФункции

// Процедура предназначена для получения момента определения остатков для заполнения документа.
//
// Параметры:
//  ДокОбъект - (ДокументОбъект), документ, для которого надо определить лату получения остатков.
//
// Возвращаемое значение.
//  Дата (момент времени) - дата остатков
//
Функция ПолучитьДатуОстатков(ДокОбъект) Экспорт
	
	ДатаОстатков = '00010101';
	Если НачалоДня(ДокОбъект.Дата) <> НачалоДня(ТекущаяДата()) 
		И ДокОбъект.Дата <> '00010101' Тогда
		
		Если НЕ ЗначениеЗаполнено(ДокОбъект.Ссылка) Тогда
			ДатаОстатков = КонецДня(ДокОбъект.Дата);
		Иначе
			ДатаОстатков = ДокОбъект.МоментВремени();
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ДатаОстатков;
	
КонецФункции

// Функция определяет дату и время конца календарной декады для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьКонецДекады(ИсходнаяДата) Экспорт
	
	ДеньМесяца = День(ИсходнаяДата);
	
	Если ДеньМесяца <= 10 Тогда
		Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 9);
	ИначеЕсли ДеньМесяца <= 20 Тогда
		Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 19);
	Иначе
		Результат = КонецМесяца(ИсходнаяДата);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПолучитьКонецДекады()

// Функция определяет дату и время конца полугодия для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьКонецПолугодия(ИсходнаяДата) Экспорт
	
	Если Месяц(ИсходнаяДата) < 7 Тогда
		Результат = ДобавитьМесяц(КонецГода(ИсходнаяДата), -6);
	Иначе
		Результат = КонецГода(ИсходнаяДата);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПолучитьКонецПолугодия()

// Функция определяет дату и время начала календарной декады для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьНачалоДекады(ИсходнаяДата) Экспорт
	
	ДеньМесяца = День(ИсходнаяДата);
	
	Если ДеньМесяца <= 10 Тогда
		Результат = НачалоМесяца(ИсходнаяДата);
	ИначеЕсли ДеньМесяца <= 20 Тогда
		Результат = НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 10;
	Иначе
		Результат = НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 20;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПолучитьНачалоДекады()

// Функция определяет дату и время начала полугодия для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьНачалоПолугодия(ИсходнаяДата) Экспорт
	
	Если Месяц(ИсходнаяДата) < 7 Тогда
		Результат = НачалоГода(ИсходнаяДата);
	Иначе
		Результат = ДобавитьМесяц(НачалоГода(ИсходнаяДата), 6);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПолучитьНачалоПолугодия()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ


// Функция возвращает значение реквизита произвольного объекта ссылочного типа
// Предназначена для получения реквизитов недоступных пользователю объектов
Функция ПолучитьРеквизитОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	ОбъектМетаданные = Ссылка.Метаданные();
	ИмяТаблицы = ОбъектМетаданные.ПолноеИмя();
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ " + ИмяРеквизита + " КАК " + ИмяРеквизита + " ИЗ " + ИмяТаблицы + "
	|ГДЕ Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка[ИмяРеквизита];
	Иначе
		РеквизитМетаданные = ОбъектМетаданные.Реквизиты.Найти(ИмяРеквизита);
		Возврат РеквизитМетаданные.Тип.ПривестиЗначение();
	КонецЕсли;
	
КонецФункции //ПолучитьРеквизитОбъекта()

// Если в шапке переданного документа есть реквизит с указанным именем, то возвращается его значение.
// Если такого реквизита нет - возвращается Неопределено.
//
// Параметры:
//  ИмяРеквизита - Строка. Имя искомого реквизита.
//  ДокументОбъект - объект переданного документа.
//  МетаданныеДокумента - Метаданные переданного документа.
//  ПустоеЗначение - значение, которое должно вернуться, если в шапке нет такого реквизита,
//  если не передано, то возвращается значение Неопределено.
//
// Возвращаемое значение:
//  Значение реквизита - значение найденного реквизита или ПустоеЗначение.
//
Функция ПолучитьРеквизитШапки(ИмяРеквизита, ДокументОбъект, МетаданныеДокумента, ПустоеЗначение = Неопределено) Экспорт
	
	ЗначениеРеквизита = ?(ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента),
	ДокументОбъект[ИмяРеквизита], ПустоеЗначение);
	
	Возврат ЗначениеРеквизита;
	
КонецФункции // ПолучитьРеквизитШапки()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СВОЙСТВАМИ И КАТЕГОРИЯМИ ОБЪЕКТОВ


//Функция возвращает список доступных назначений для "Свойств и категорий объектов" 
//по переданной ссылке
// Параметры:
//Ссылка - Ссылка на справочник или документ
//
// Возвращаемое значение:
// Список значений: доступные назначения для свойств и категорий
Функция ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке(Ссылка) Экспорт
	
	Результат = Новый СписокЗначений;
	
	ТипСсылки = ТипЗнч(Ссылка);
	ЭтоХарактеристика = (ТипСсылки = Тип("СправочникСсылка.ХарактеристикиНоменклатуры"));
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НазначениеХарактеристика", ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_ХарактеристикиНоменклатуры);
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Назначения.Ссылка КАК Ссылка,
	|	Назначения.ТипЗначения КАК ТипЗначения
	|ИЗ
	|	ПланВидовХарактеристик.НазначенияСвойствКатегорийОбъектов КАК Назначения
	|ГДЕ
	|	НЕ Назначения.ПометкаУдаления
	|	И НЕ Назначения.ЭтоГруппа
	|";
	
	Если ЭтоХарактеристика Тогда
		ТекстЗапроса = ТекстЗапроса + "
		|	И Назначения.Ссылка = &НазначениеХарактеристика
		|";
	Иначе
		ТекстЗапроса = ТекстЗапроса + "
		|	И Назначения.Ссылка <> &НазначениеХарактеристика
		|";
	КонецЕсли;
	
	Запрос.Текст = ТекстЗапроса;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если ЭтоХарактеристика Или Выборка.ТипЗначения.СодержитТип(ТипСсылки) Тогда
			Результат.Добавить(Выборка.Ссылка);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке()


// Меняет местами значения двух доступных для записи переменных
//
// Параметры
//  Источник - первая переменная
//  Приемник – вторая переменная
//
Процедура ПоменятьПеременныеМестами(Источник, Приемник) Экспорт
	
	тмп = Источник;
	Источник = Приемник;
	Приемник = Тмп;
	
КонецПроцедуры // ПоменятьПеременныеМестами()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С XML


// Функция осуществляет построение дерева XML.
//
// Параметры
//  XML             - <ЧтениеXML>
//                  - Объект, при помощи которого осуществляется чтение
//                    файла отчета.
//
//  Дерево          - <Структура>
//                  - Дерево XML.
//
//  ПервыйВызов     - <Булево>
//                  - Служебный параметр.
//
// Возвращаемое значение:
//  <Булево>        - Результат выполнения.
//
Функция ПостроитьДеревоXML(XML, Дерево, ПервыйВызов = Истина) Экспорт
	
	Результат = Истина;
	Имя       = "";
	Врем      = Неопределено;
	Врем2     = Неопределено;
	Врем3     = Неопределено;
	
	Если ПервыйВызов Тогда
		Дерево = Новый Структура();
	КонецЕсли;
	
	Если XML.Прочитать() Тогда
		Если XML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Имя  = XML.ЛокальноеИмя;
			Врем = Новый Структура();
			Пока ПостроитьДеревоXML(XML, Врем, Ложь) Цикл
			КонецЦикла;
			Пока XML.Имя <> Имя Цикл
				Если XML.ТипУзла = ТипУзлаXML.Текст Тогда
					Врем = XML.Значение;
				КонецЕсли;
				Если Не XML.Прочитать() Тогда
					Результат = Ложь;
					Возврат Результат;
				КонецЕсли;
			КонецЦикла;
			Дерево.Свойство(Имя, Врем2);
			Если Врем2 = Неопределено Тогда
				Врем2 = Врем;
			Иначе
				Если ТипЗнч(Врем2) = Тип("Массив") Тогда
					Врем2.Добавить(Врем);
				Иначе
					Врем3 = Новый Массив();
					Врем3.Добавить(Врем2);
					Врем3.Добавить(Врем);
					Врем2 = Врем3;
				КонецЕсли;
			КонецЕсли;
			Дерево.Вставить(Имя, Врем2);
		Иначе
			Результат = Ложь;
		КонецЕсли;
	Иначе
		Результат = Ложь;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПостроитьДеревоXML()

// Функция выполняет приведение строки к булево
Функция ПривестиСтрокуКБулево(БулевоСтрокой) Экспорт
	
	ОписаниеТипаБулево = Новый ОписаниеТипов("Булево");
	ЗначениеБулево = ОписаниеТипаБулево.ПривестиЗначение(БулевоСтрокой);
	
	Возврат ЗначениеБулево;
	
КонецФункции

// Функция выполняет приведение строки к дате
Функция ПривестиСтрокуКДате(ДатаСтрокой) Экспорт
	
	ОписаниеТипаДаты = Новый ОписаниеТипов("Дата");
	ЗначениеДаты = ОписаниеТипаДаты.ПривестиЗначение(ДатаСтрокой);
	
	Возврат ЗначениеДаты;
	
КонецФункции

//функция выполняет приведение строки к числу
// Параметры:
//  ЧислоСтрокой           - Строка - Строка приводимая к числу
//  ВозвращатьНеопределено - Булево - Если Истина и строка содержит некорректное значение, то возвращать Неопределено
//
// Возвращаемое значение:
//  Число
//
Функция ПривестиСтрокуКЧислу(ЧислоСтрокой, ВозвращатьНеопределено = Ложь) Экспорт
	
	ОписаниеТипаЧисла = Новый ОписаниеТипов("Число");
	ЗначениеЧисла = ОписаниеТипаЧисла.ПривестиЗначение(ЧислоСтрокой);
	
	Если ВозвращатьНеопределено И (ЗначениеЧисла = 0) Тогда
		
		Стр = Строка(ЧислоСтрокой);
		Если Стр = "" Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Стр = СтрЗаменить(СокрЛП(Стр), "0", "");
		Если (Стр <> "") И (Стр <> ".") И (Стр <> ",") Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЗначениеЧисла;	
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КРИТЕРИЯМИ ОТБОРА


// Функция разбирает строку вида например:
// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
// ТипОбъектаМетаданных должен быть Справочник или Документ.
//
// Параметры:
//  ПутьКДанным - строка.
//
// Возвращаемое значение:
//  Структура - путь к объекту метаданных
//
// Функция разбирает строку вида например:
// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
// ТипОбъектаМетаданных должен быть Справочник или Документ.
//
// Параметры:
//  ПутьКДанным - строка.
//
// Возвращаемое значение:
//  Структура - путь к объекту метаданных
//
Функция РазобратьПутьКОбъектуМетаданных(ПутьКДанным, МетаданныеОбъекта = Неопределено) Экспорт
	
	Структура = Новый Структура;
	
	СоответствиеИмен = Новый Массив();
	СоответствиеИмен.Добавить("ТипОбъекта");
	СоответствиеИмен.Добавить("ВидОбъекта");
	СоответствиеИмен.Добавить("ПутьКДанным");
	СоответствиеИмен.Добавить("ИмяТаблЧасти");
	СоответствиеИмен.Добавить("ИмяРеквизита");
	
	Для индекс = 1 по 3 Цикл
		
		Точка = Найти(ПутьКДанным, ".");
		ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
		Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
		ПутьКДанным = Сред(ПутьКДанным, Точка+1);
		
	КонецЦикла;
	
	ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");
	
	Если Структура.ПутьКДанным = "ТабличнаяЧасть" Тогда
		
		Для индекс = 4 по 5  Цикл 
			
			Точка = Найти(ПутьКДанным, ".");
			Если Точка = 0 Тогда
				ТекущееЗначение = ПутьКДанным;
			Иначе
				ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
			КонецЕсли;
			
			Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
			ПутьКДанным = Сред(ПутьКДанным,  Точка+1);
			
		КонецЦикла;
		
	Иначе
		
		Структура.Вставить(СоответствиеИмен[3], "");
		Структура.Вставить(СоответствиеИмен[4], ПутьКДанным);
		
	КонецЕсли;
	
	Если МетаданныеОбъекта <> Неопределено Тогда
		Структура.Вставить("Метаданные", МетаданныеОбъекта);
	Иначе
		Если Структура.ТипОбъекта = "Документ" Тогда
			Структура.Вставить("Метаданные", Метаданные.Документы[Структура.ВидОбъекта]);
		Иначе
			Структура.Вставить("Метаданные", Метаданные.Справочники[Структура.ВидОбъекта]);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Структура;
	
КонецФункции // РазобратьПутьКОбъектуМетаданных()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРАВЛЯЕМЫМИ БЛОКИРОВКАМИ

// Устанавливает управляемую блокировку таблицы
//
// Параметры:
//  СтруктураПараметров 		- <Структура>. Структура параметров блокировки. Обязательный параметр.
//								Обязательно должна содержать свойства:
//								"ИмяТаблицы" - <Строка> - имя таблицы, на которую накладывается блокировка.
//									Например: "АвансовыйОтчет"
//								Необязательные свойства:
//								"ТипТаблицы" - <Строка> - тип таблицы, на которую накладывается блокировка.
//									Пространство блокировки состоит из типа таблицы и имени таблицы.
//									Например: "Документ"
//									Значение по умолчанию: "РегистрНакопления"
//								"РежимБлокировки" - <РежимБлокировкиДанных> - режим накладываемой блокировки.
//									Значение по умолчанию: РежимБлокировкиДанных.Исключительный
//								"ИсточникДанных" - источник данных для блокировки.
//									Может передаваться значение любого типа, поддерживаемого свойством ИсточникДанных элемента блокировки,
//									а также типа "Менеджер временных таблиц".
//									Если в структуре нет этого свойства - блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
//								"ИмяВременнойТаблицы" - <Строка> - имя временной таблицы менеджера временных таблиц, которая служит источником данных для блокировки.
//									Обязательно должно указываться, если в качестве источника данных процедуре передан менеджер временных таблиц.
//  КоллекцияЗначенийБлокировки	- <Структура или Соответствие> - описывает значения блокировки, накладываемые с помощью УстановитьЗначение().
//									Ключ - поле блокировки - <Строка или (только для соответствия) ПланыВидовХарактеристикСсылка>, 
//										ПланыВидовХарактеристикСсылка используется для блокировки регистра бухгалтерии по виду субконто.
//									Значение - блокируемое значение - <Произвольный тип>.
//									Если передано Неопределено или если коллекция не содержит ни одного элемента -
//									блокировки методом УстановитьЗначение() не накладываются.
//  КоллекцияОписанияИсточника	- <Структура или Соответствие> - описывает значения блокировки, накладываемые с помощью ИспользоватьИзИсточникаДанных().
//									Ключ - поле блокировки - <Строка или (только для соответствия) ПланыВидовХарактеристикСсылка>, 
//										ПланыВидовХарактеристикСсылка используется для блокировки регистра бухгалтерии по виду субконто.
//									Значение - поле таблицы источника данных - <Строка>.
//									Если передано Неопределено или если коллекция не содержит ни одного элемента -
//									блокировки методом ИспользоватьИзИсточникаДанных() не накладываются.
//  Отказ 						- <Булево> - при ошибке в процессе установки блокировки в этот параметр процедура возвращает значение Истина
//  Заголовок 					- <Строка> - заголовок сообщения об ошибке при установке блокировки
//
Процедура УстановитьУправляемуюБлокировку(СтруктураПараметров, КоллекцияЗначенийБлокировки = Неопределено, КоллекцияОписанияИсточника = Неопределено, Отказ = Ложь, Заголовок = "") Экспорт
	
	Если НЕ ТипЗнч(СтруктураПараметров) = Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	
	ИспользоватьЗначенияБлокировки = КоллекцияЗначенийБлокировки <> Неопределено 
	И (ТипЗнч(КоллекцияЗначенийБлокировки) = Тип("Структура") 
	ИЛИ ТипЗнч(КоллекцияЗначенийБлокировки) = Тип("Соответствие"))
	И КоллекцияЗначенийБлокировки.Количество() > 0;
	
	ИспользоватьИсточникДанных     = КоллекцияОписанияИсточника <> Неопределено 
	И (ТипЗнч(КоллекцияОписанияИсточника) = Тип("Структура") 
	ИЛИ ТипЗнч(КоллекцияОписанияИсточника) = Тип("Соответствие"))
	И КоллекцияОписанияИсточника.Количество() > 0
	И СтруктураПараметров.Свойство("ИсточникДанных");
	
	Если НЕ ИспользоватьЗначенияБлокировки И НЕ ИспользоватьИсточникДанных Тогда
		Возврат;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	
	ТипТаблицы = ?(СтруктураПараметров.Свойство("ТипТаблицы"), СтруктураПараметров.ТипТаблицы, "РегистрНакопления");
	ИмяТаблицы = СтруктураПараметров.ИмяТаблицы;
	ПространствоБлокировки = ТипТаблицы  + "." + ИмяТаблицы;
	ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
	
	РежимБлокировки = ?(СтруктураПараметров.Свойство("РежимБлокировки"), СтруктураПараметров.РежимБлокировки, РежимБлокировкиДанных.Исключительный);
	ЭлементБлокировки.Режим = РежимБлокировки;
	
	Если ИспользоватьЗначенияБлокировки Тогда
		Для каждого ЭлементКоллекции Из КоллекцияЗначенийБлокировки Цикл
			ЭлементБлокировки.УстановитьЗначение(ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Если ИспользоватьИсточникДанных Тогда
		
		ИсточникДанных = СтруктураПараметров.ИсточникДанных; 
		
		Если ТипЗнч(ИсточникДанных) = Тип("МенеджерВременныхТаблиц") Тогда
			
			Запрос = Новый Запрос;
			Запрос.МенеджерВременныхТаблиц = ИсточникДанных;
			ТекстЗапроса = "";
			Для каждого ЭлементКоллекции Из КоллекцияОписанияИсточника Цикл
				ТекстЗапроса = ТекстЗапроса + ",
				|	Таб." + ЭлементКоллекции.Значение;
			КонецЦикла;
			ТекстЗапроса = Сред(ТекстЗапроса, 2);
			ТекстЗапроса = 			
			"ВЫБРАТЬ РАЗЛИЧНЫЕ"
			+ ТекстЗапроса + "
			|ИЗ
			|	" + СтруктураПараметров.ИмяВременнойТаблицы + " КАК Таб";
			Запрос.Текст = ТекстЗапроса;
			Результат    = Запрос.Выполнить();
			
			ЭлементБлокировки.ИсточникДанных = Результат;
			
		Иначе
			
			ЭлементБлокировки.ИсточникДанных = ИсточникДанных;
			
		КонецЕсли;
		
		Для каждого ЭлементКоллекции Из КоллекцияОписанияИсточника Цикл
			
			ЭлементБлокировки.ИспользоватьИзИсточникаДанных(ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Попытка
		
		Блокировка.Заблокировать();
		
	Исключение
		
		СообщитьОбОшибке(ОписаниеОшибки(), Отказ, Заголовок);
		ВызватьИсключение НСтр("ru='Операция не выполнена';uk='Операція не виконана'");
		
	КонецПопытки;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Процедура удаляет строки с пустыми значениями из структуры таблиц документа
//	Параметры:
//		- ТаблицыДляДвиженийПоЗаказам - структура таблиц документа
//		- ИмяПоля - имя поля, значение которого проверяет на пустое значение.
//
Процедура УдалитьСтрокиИзТаблицДокумента(ТаблицыДляДвиженийПоЗаказам, ИмяПоля) Экспорт
	
	Для Каждого ТабЧасть Из ТаблицыДляДвиженийПоЗаказам Цикл
		КолвоСтрок = ТабЧасть.Значение.Количество();
		Для Инд = 1 По КолвоСтрок Цикл
			ТекСтрока = ТабЧасть.Значение[КолвоСтрок - Инд];
			
			Если НЕ ЗначениеЗаполнено(ТекСтрока[ИмяПоля]) Тогда
				ТабЧасть.Значение.Удалить(ТекСтрока);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // УдалитьСтрокиИзТаблицДокумента()

// Процедура заполняет структуру таблиц документа, значением которое будет одинаковым для всех таблиц (например значением шапки документа)
//
// Параметры:
//  СтруктТаблицДокумента   - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//  ИмяПоля                 - имя колонки в таблицах локумента, в которую будет установлено новое значение
//  УстанавливаемоеЗначение - значение, которое надо установить в таблицы документа
//  СтрТабЧасти             - имена таб. частей документа в которые необходимо установить новое значение. строка, в которой
//                            имена таб. частей разделены запятыми. необязательный параметр, по умолчанию - все таблицы.
//
Процедура УстановитьЗначениеВТаблицыДокумента(СтруктТаблицДокумента, ИмяПоля, УстанавливаемоеЗначение, СтрТабЧасти = "") Экспорт
	
	СтруктТабЧасти = ?( ПустаяСтрока(СтрТабЧасти), СтруктТаблицДокумента, Новый Структура(СтрТабЧасти));
	Для Каждого ТабЧасть Из СтруктТабЧасти Цикл
		
		Если СтруктТаблицДокумента[ТабЧасть.Ключ].Количество() > 0 Тогда
			СтруктТаблицДокумента[ТабЧасть.Ключ].ЗаполнитьЗначения( УстанавливаемоеЗначение, ИмяПоля);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // УстановитьЗначениеВТаблицыДокумента()


// Формирует запрос на дополнительные параметры, нужные при проведении документа.
//
// Параметры: 
//  ДокументОбъект                 - объект проводимого документа, 
//  ДеревоПолейЗапросаПоШапке      - дерево значений, содержащего имена полей, 
//                                   которые нужно заполнить в запросе по шапке документа.
//  СтруктураШапкиДокумента        - структура, содержащая значения реквизитов, относящихся к шапке документа,
//                                   необходимых для его проведения.
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//
// Возвращаемое значение:
//  Дополненная по результату запроса структура СтруктураШапкиДокумента.
//
Функция СформироватьЗапросПоДеревуПолей(ДокументОбъект, ДеревоПолейЗапросаПоШапке, СтруктураШапкиДокумента, ВалютаРегламентированногоУчета)  Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ";
	
	СтрокиЗапроса           = "";
	ТаблицыЗапроса          = "";
	НуженКурсВалютыУпрУчета = Ложь;
	ЕстьУчетнаяПолитика     = Ложь;
	
	ДокументОбъектМетаданные = ДокументОбъект.Метаданные();
	
	// Реквизиты договора взаиморасчетов.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ДоговорыКонтрагентов", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			Если СтрокаПоля.Поле = "НеОтноситьНаЗатратыПоНУ" И СтруктураШапкиДокумента.Дата >= '20120101' Тогда
				
				СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
				Символы.Таб + "ЛОЖЬ" + ?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), " КАК " + СокрЛП(СтрокаПоля.Поле), " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
				
			ИначеЕсли СтрокаПоля.Поле = "Внешнеэкономический" Тогда
				
				СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
				Символы.Таб + "ЕстьNULL(Док.ДоговорКонтрагента." + СокрЛП(СтрокаПоля.Поле) + ", ЛОЖЬ)" +
				?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
				
			Иначе
				
				СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
				Символы.Таб + "Док.ДоговорКонтрагента." + СокрЛП(СтрокаПоля.Поле) +
				?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты договора взаиморасчетов регл.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ДоговорыКонтрагентовРегл", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ДоговорКонтрагентаРегл." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	
	// Реквизиты организации.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("Организации", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для Каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.Организация." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;	
	
	// Реквизиты сделки.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("Сделка", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		Если ЗначениеЗаполнено(ДокументОбъект.Сделка) Тогда
			СделкаМетаданные = ДокументОбъект.Сделка.Метаданные();
		Иначе
			СделкаМетаданные = Неопределено;
		КонецЕсли;
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для Каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + ?(СделкаМетаданные = Неопределено ИЛИ СделкаМетаданные.Реквизиты.Найти(СокрЛП(СтрокаПоля.Поле)) = Неопределено,
			"NULL",
			"ВЫРАЗИТЬ(Док.Сделка КАК Документ." + СделкаМетаданные.Имя + ")." + СокрЛП(СтрокаПоля.Поле)) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты расчетного документа.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("РасчетныйДокумент", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		Если ЗначениеЗаполнено(ДокументОбъект.РасчетныйДокумент) Тогда
			СделкаМетаданные = ДокументОбъект.РасчетныйДокумент.Метаданные();
		Иначе
			СделкаМетаданные = Неопределено;
		КонецЕсли;
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для Каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + ?(СделкаМетаданные = Неопределено, "NULL", "ВЫРАЗИТЬ(Док.РасчетныйДокумент КАК Документ." + СделкаМетаданные.Имя + ")." + СокрЛП(СтрокаПоля.Поле)) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты склада.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("Склад", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.Склад." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты склада-группы.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("СкладГруппа", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для Каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.СкладГруппа." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты склада-отправителя
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("СкладОтправитель", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.СкладОтправитель." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты склада-отправителя
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ДокументПеремещения", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ДокументПеремещения." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты склада-отправителя
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ДокументПередачи", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ДокументПередачи." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты склада-получателя
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("СкладПолучатель", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.СкладПолучатель." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты склада-ордера
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("СкладОрдер", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.СкладОрдер." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("Заказ", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.Заказ." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ВнутреннийЗаказ", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ВнутреннийЗаказ." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты заказа покупателя
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ЗаказыПокупателей", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ЗаказПокупателя." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты заказа поставщику
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ЗаказыПоставщикам", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ЗаказПоставщику." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты номенклатуры
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("Номенклатура", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.Номенклатура." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты документа основания
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("ДокументОснование", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для Каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.ДокументОснование." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	// Реквизиты Схемы реализации
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("СхемаРеализацииПоВознаграждению", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для Каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.СхемаРеализацииПоВознаграждению." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты Услуги по вознаграждению
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("УслугаПоВознаграждению", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для Каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.УслугаПоВознаграждению." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты НалоговоеНазначение по вознаграждению
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("НалоговоеНазначениеДоходовИЗатратПоВознаграждению", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для Каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.НалоговоеНазначениеДоходовИЗатратПоВознаграждению." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	
	// Реквизиты НалоговоеНазначение
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("НалоговоеНазначение", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для Каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.НалоговоеНазначение." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Реквизиты состояния ОС
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("Состояние", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.Состояние." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("СостояниеВводаВЭксплуатацию", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "Док.СостояниеВводаВЭксплуатацию." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Пустые реквизиты.
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("NULL", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для Каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
			Символы.Таб + "NULL" +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
			
		КонецЦикла;
		
	КонецЕсли;	
	
	// Константы.
	ТаблицыЗапроса = ТаблицыЗапроса + ", Константы";
	
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("Константы", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			
			Если СтрокаПоля.Поле = "КурсВалютыУправленческогоУчета" Тогда
				
				СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
				Символы.Таб + "КурсыВалютСрезПоследних.Курс КАК КурсВалютыУправленческогоУчета";
				
				СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
				Символы.Таб + "КурсыВалютСрезПоследних.Кратность КАК КратностьВалютыУправленческогоУчета";
				
				НуженКурсВалютыУпрУчета = Истина;
				
			Иначе
				
				СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС +
				Символы.Таб + "Константы." + СокрЛП(СтрокаПоля.Поле) +
				?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	СтрокаОбъекта = ДеревоПолейЗапросаПоШапке.Строки.Найти("УчетнаяПолитика", "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		ЕстьУчетнаяПолитика = Истина;
		
		// В цикле по вложенным строкам формируем строки запроса.
		Для каждого СтрокаПоля Из СтрокаОбъекта.Строки Цикл
			СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС + 
			Символы.Таб + "УчетнаяПолитикаСрезПоследних." + СокрЛП(СтрокаПоля.Поле) +
			?(НЕ ЗначениеЗаполнено(СтрокаПоля.Псевдоним), "", " КАК " + СокрЛП(СтрокаПоля.Псевдоним));
		КонецЦикла;
		
	КонецЕсли;
	
	НужнаВалюта = СтруктураШапкиДокумента.Свойство("ВалютаДокумента");	
	
	// Надо добавить константу ВалютаРегламнтированногоУчета
	СтрокиЗапроса = СтрокиЗапроса + "," + Символы.ПС + 
	Символы.Таб + "Константы.ВалютаУчета КАК ВалютаРегламентированногоУчета
	|"+ ?(НужнаВалюта, ",
	|	КурсыВалютыДокументаСрезПоследних.Курс       КАК КурсВалютыДокумента,
	|	КурсыВалютыДокументаСрезПоследних.Кратность  КАК КратностьВалютыДокумента", "");
	
	СтрокаЗапросаКурсВалютыУпрУчета = Символы.ПС + "
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КурсыВалют.СрезПоследних(&ДатаДокумента,) КАК КурсыВалютСрезПоследних
	|	ПО Константы.ВалютаУправленческогоУчета = КурсыВалютСрезПоследних.Валюта";
	
	СтрокаЗапросаКурсВалютыДокумента = Символы.ПС + "
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.КурсыВалют.СрезПоследних(&ДатаДокумента, Валюта = &ВалютаДокумента) КАК КурсыВалютыДокументаСрезПоследних
	|	ПО ИСТИНА";
	
	СтрокаРегистраУчетнойПолитики = Символы.ПС + "
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.УчетнаяПолитика.СрезПоследних(&ДатаДокумента,) КАК УчетнаяПолитикаСрезПоследних
	|	ПО Истина";
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ " + Сред(СтрокиЗапроса, 2) + "
	| ИЗ 
	|      Документ." + ДокументОбъектМетаданные.Имя + " КАК Док "+ ТаблицыЗапроса +
	?(НуженКурсВалютыУпрУчета, 	СтрокаЗапросаКурсВалютыУпрУчета, "") + Символы.ПС + 
	?(НужнаВалюта, 				СтрокаЗапросаКурсВалютыДокумента,"") + Символы.ПС + 
	?(ЕстьУчетнаяПолитика, 		СтрокаРегистраУчетнойПолитики,	 "") + Символы.ПС + "
	|     ГДЕ Док.Ссылка = &ДокументСсылка";
	
	// Установим параметры запроса.
	Запрос.УстановитьПараметр("ДокументСсылка" , ДокументОбъект.Ссылка);
	Запрос.УстановитьПараметр("ДатаДокумента", ДокументОбъект.Дата);
	Если НужнаВалюта Тогда
		Запрос.УстановитьПараметр("ВалютаДокумента", СтруктураШапкиДокумента.ВалютаДокумента);
	КонецЕсли;
	
	ТаблицаЗапроса = Запрос.Выполнить().Выгрузить();
	
	Для каждого Колонка из ТаблицаЗапроса.Колонки Цикл
		Если ТаблицаЗапроса.Количество() = 0 Тогда
			СтруктураШапкиДокумента.Вставить(Колонка.Имя, Неопределено);
		Иначе
			СтруктураШапкиДокумента.Вставить(Колонка.Имя, ТаблицаЗапроса[0][Колонка.Имя]);
		КонецЕсли;
	КонецЦикла;
	
	Если СтруктураШапкиДокумента.Свойство("ВалютаДокумента") Тогда
		Если ОбщегоНазначения.ЕстьРеквизитДокумента("ВалютаДокумента", ДокументОбъектМетаданные) Тогда
			СтруктураШапкиДокумента.Вставить("КурсДокумента", 		ЗаполнениеДокументов.КурсДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));
			СтруктураШапкиДокумента.Вставить("КратностьДокумента", 	ЗаполнениеДокументов.КратностьДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураШапкиДокумента;
	
КонецФункции // СформироватьЗапросПоДеревуПолей()
//Конец вставки

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с внешним соединением

// Возвращает имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
Функция ИмяCOMСоединителя() Экспорт
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	ПодстрокиВерсии = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
	СистемнаяИнфо.ВерсияПриложения, ".");
	Возврат "v" + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + ".COMConnector";
	
КонецФункции	

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
// 
// Параметры:
//  Параметры - Структура - содержит параметры для установки внешнего соединения с информационной базой.
//  Структура должна содержать следующие ключи (см. функция ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//	  ВариантРаботыИнформационнойБазы             - (Число)  Вариант работы информационной базы: 0 – файловый; 1 – клиент-серверный
//	  КаталогИнформационнойБазы                   - (Строка) Каталог информационной базы для файлового режима работы
//	  ИмяСервера1СПредприятия                     - (Строка) Имя сервера1С:Предприятия
//	  ИмяИнформационнойБазыНаСервере1СПредприятия - (Строка) Имя информационной базы на сервере1С:Предприятия
//	  АутентификацияОперационнойСистемы           - (Булево) Признак аутентификации операционной системы при создании внешнего подключения к информационной базе
//	  ИмяПользователя                             - (Строка) Имя пользователя информационной базы
//	  ПарольПользователя                          - (Строка) Пароль пользователя информационной базы
// 
//  СтрокаСообщенияОбОшибке (необязательный) – Строка – если в процессе установки внешнего соединения возникает ошибка,
//                                                     то подробное описание ошибки помещается в этот параметр
//
// Возвращаемое значение:
//  Тип: COM-объект, Неопределенно.
//  в случае успешной установки внешнего соединения возвращается указатель на COM-объект соединения;
//  в случае ошибки возвращается Неопределенно.
//
Функция УстановитьВнешнееСоединение(Параметры, СтрокаСообщенияОбОшибке = "", ОшибкаПодключенияКомпоненты = Ложь) Экспорт
	
	Результат = УстановитьВнешнееСоединениеСБазой(Параметры);
	
	ОшибкаПодключенияКомпоненты = Результат.ОшибкаПодключенияКомпоненты;
	СтрокаСообщенияОбОшибке     = Результат.ПодробноеОписаниеОшибки;
	
	Возврат Результат.Соединение;
КонецФункции

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель на это соединение
// 
// Параметры:
//  Параметры - Структура - содержит параметры для установки внешнего соединения с информационной базой.
//  Структура должна содержать следующие ключи (см. функция ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//	  ВариантРаботыИнформационнойБазы             - (Число)  Вариант работы информационной базы: 0 – файловый; 1 – клиент-серверный
//	  КаталогИнформационнойБазы                   - (Строка) Каталог информационной базы для файлового режима работы
//	  ИмяСервера1СПредприятия                     - (Строка) Имя сервера1С:Предприятия
//	  ИмяИнформационнойБазыНаСервере1СПредприятия - (Строка) Имя информационной базы на сервере1С:Предприятия
//	  АутентификацияОперационнойСистемы           - (Булево) Признак аутентификации операционной системы при создании внешнего подключения к информационной базе
//	  ИмяПользователя                             - (Строка) Имя пользователя информационной базы
//	  ПарольПользователя                          - (Строка) Пароль пользователя информационной базы
// 
// Возвращаемое значение - структура:
//  Соединение                  - (COM-объект) указатель на COM-объект соединения или Неопределено в случае ошибки
//  КраткоеОписаниеОшибки       - (Строка) краткое описание ошибки
//  ПодробноеОписаниеОшибки     - (Строка) подробное описание ошибки
//  ОшибкаПодключенияКомпоненты - (Булево) флаг ошибки подключения COM
//
Функция УстановитьВнешнееСоединениеСБазой(Параметры) Экспорт
	
	Результат = Новый Структура("Соединение, КраткоеОписаниеОшибки, ПодробноеОписаниеОшибки, ОшибкаПодключенияКомпоненты",
	Неопределено, "", "", Ложь
	);
	
	Попытка
		COMConnector = Новый COMObject(ИмяCOMСоединителя()); // "V82.COMConnector"
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр("ru = 'Не удалось подключится к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
		Возврат Результат;
	КонецПопытки;
	
	Если Параметры.ВариантРаботыИнформационнойБазы = 0 Тогда
		// Файловый режим
		Если ПустаяСтрока(Параметры.КаталогИнформационнойБазы) Тогда
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не задано месторасположение каталога информационной базы.'");
			Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
			Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
			Возврат Результат;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			
		Иначе
			СтрокаСоединения = "File = ""&КаталогИнформационнойБазы""; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&КаталогИнформационнойБазы", Параметры.КаталогИнформационнойБазы);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",           Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",        Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	Иначе 
		// Клиент-серверный вариант работы информационной базы
		Если ПустаяСтрока(Параметры.ИмяСервера1СПредприятия) Или ПустаяСтрока(Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия) Тогда
			СтрокаСообщенияОбОшибке = НСтр("ru = 'Не заданы обязательные параметры подключения: ""Имя сервера""; ""Имя информационной базы на сервере"".'");
			
			Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
			Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
			Возврат Результат;
			
		КонецЕсли;
		
		Если Параметры.АутентификацияОперационнойСистемы Тогда
			СтрокаСоединения = "Srvr = &ИмяСервера1СПредприятия; Ref = &ИмяИнформационнойБазыНаСервере1СПредприятия";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			
		Иначе
			СтрокаСоединения = "Srvr = &ИмяСервера1СПредприятия; Ref = &ИмяИнформационнойБазыНаСервере1СПредприятия; Usr = ""&ИмяПользователя""; Pwd = ""&ПарольПользователя""";
			
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяСервера1СПредприятия",                     Параметры.ИмяСервера1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяИнформационнойБазыНаСервере1СПредприятия", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ИмяПользователя",                             Параметры.ИмяПользователя);
			СтрокаСоединения = СтрЗаменить(СтрокаСоединения, "&ПарольПользователя",                          Параметры.ПарольПользователя);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Попытка
		Результат.Соединение = COMConnector.Connect(СтрокаСоединения);
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр("ru = 'Не удалось подключится к другой программе: %1'");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
	КонецПопытки;
	
	Возврат Результат;
КонецФункции

#Область Добавлены_20170125

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка    - Ссылка на объект - элемент справочника, документ, ...
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
// 
Функция ЗначенияРеквизитовОбъекта(Ссылка, Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		СтруктураРеквизитов = Новый Структура(Реквизиты);
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Структура")
		ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		
		СтруктураРеквизитов = Реквизиты;
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив")
		ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		
		СтруктураРеквизитов = Новый Структура;
		Для каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"),
		Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		СокрЛП(КлючИЗначение.Значение),
		СокрЛП(КлючИЗначение.Ключ));
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(ссылка, имяРеквизита) Экспорт
	
	результат = ЗначенияРеквизитовОбъекта(ссылка, имяРеквизита);
	Возврат результат[имяРеквизита];
	
КонецФункции 

#КонецОбласти 
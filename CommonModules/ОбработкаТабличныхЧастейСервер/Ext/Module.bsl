
#Область ПроверкаДублейСтрокТабличнойЧасти

// Проверяет наличие дублей строк в табличных частях объектов. Дубли строк могут искаться как по
// значениям одной колонки, так и по нескольким колонкам одновременно.
//
// Параметры
//  Отказ  - Булево - Признак отказа от выполнения операции, в которой выполняется проверка дублей
//                 строк. Если в теле процедуры установить данному параметру значение Истина, то
//                 операция выполнена не будет.
//  Объект  - Произвольный - Любой объект, который может иметь табличную часть.
//  ИмяТабличнойЧасти  - Строка - Имя табличной части объекта, в которой производится проверка.
//  стКолонки  - Структура - Набор колонок, по которым производится поиск дублей строк. В качестве ключа
//                 элементов структуры указываются имена колонок табличной части, а в значениях
//                 элементов - представления колонок.
//
Процедура ПроверитьДублиСтрокТабличнойЧасти(Отказ, Объект, ИмяТабличнойЧасти, стКолонки) Экспорт

	ТабличнаяЧасть = Объект[ИмяТабличнойЧасти];

	Если ТабличнаяЧасть.Количество() = 0 Тогда
		Возврат;
	КонецЕсли; 
	
	Если стКолонки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли; 
	
	сзКолонки = Новый СписокЗначений;	// Список колонок для вывода сообщений о дублях строк.
	
	// Формирование частей текста запроса и списка колонок.
	ПоляВременнойТаблицы = "";
	ПоляОсновнойТаблицы = "";
	Условия = "";
	Порядок = "";
	Для каждого Колонка Из стКолонки Цикл
		
		ИмяКолонки = Колонка.Ключ;
		
		Если Не ПустаяСтрока(ПоляВременнойТаблицы) Тогда
			ПоляВременнойТаблицы = ПоляВременнойТаблицы + ",";
		КонецЕсли; 
		
		Если Не ПустаяСтрока(ПоляОсновнойТаблицы) Тогда
			ПоляОсновнойТаблицы = ПоляОсновнойТаблицы + ",";
		КонецЕсли; 
		
		ПоляВременнойТаблицы = ПоляВременнойТаблицы + "
		|	ТабличнаяЧасть." + ИмяКолонки;
		
		ПоляОсновнойТаблицы = ПоляОсновнойТаблицы + "
		|	ТабличнаяЧасть1." + ИмяКолонки + " КАК " + ИмяКолонки;
		
		Условия = Условия + "
		|	И ТабличнаяЧасть1." + ИмяКолонки + " = ТабличнаяЧасть2." + ИмяКолонки;
		
		Порядок = Порядок + "
		|	" + ИмяКолонки + ",";
		
		сзКолонки.Добавить(ИмяКолонки, Колонка.Значение);
	
	КонецЦикла; 
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ТабличнаяЧасть.НомерСтроки," + ПоляВременнойТаблицы + "
	|ПОМЕСТИТЬ ТабличнаяЧастьОбъекта
	|ИЗ
	|	&ТабличнаяЧасть КАК ТабличнаяЧасть
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ТабличнаяЧасть1.НомерСтроки КАК НомерСтроки," + ПоляОсновнойТаблицы + "
	|ИЗ
	|	ТабличнаяЧастьОбъекта КАК ТабличнаяЧасть1,
	|	ТабличнаяЧастьОбъекта КАК ТабличнаяЧасть2
	|ГДЕ
	|	ТабличнаяЧасть1.НомерСтроки <> ТабличнаяЧасть2.НомерСтроки" + Условия + "
	|
	|УПОРЯДОЧИТЬ ПО
	|" + Порядок + "
	|	НомерСтроки";
	
	Запрос.УстановитьПараметр("ТабличнаяЧасть", ТабличнаяЧасть);
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Если Не Результат.Пустой() Тогда
		Отказ = Истина;
	КонецЕсли; 
	
	ВывестиСообщенияОДубляхСтрокТабличнойЧасти(Выборка, 0, ИмяТабличнойЧасти, Метаданные.НайтиПоТипу(ТипЗнч(ТабличнаяЧасть)).Представление(), сзКолонки, Объект);

КонецПроцедуры // ПроверитьДублиСтрокТабличнойЧасти()

Процедура ПроверитьПустыеСтрокиТабличнойЧасти(отказ, объект, имяТабличнойЧасти, стКолонки) Экспорт

	табличнаяЧасть = объект[имяТабличнойЧасти];

	Если табличнаяЧасть.Количество() = 0 Тогда
		Возврат;
	КонецЕсли; 
	
	Если стКолонки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли; 
	
	сзКолонки = Новый СписокЗначений;	// Список колонок для вывода сообщений о дублях строк.
	
	// Формирование частей текста запроса и списка колонок.
	поляВременнойТаблицы = "";
	поляОсновнойТаблицы = "";
	условия = "";
	порядок = "";
	Для каждого колонка Из стКолонки Цикл
		
		имяКолонки = Колонка.Ключ;
		
		Если Не ПустаяСтрока(поляВременнойТаблицы) Тогда
			поляВременнойТаблицы = поляВременнойТаблицы + ",";
		КонецЕсли; 
		
		Если Не ПустаяСтрока(поляОсновнойТаблицы) Тогда
			поляОсновнойТаблицы = поляОсновнойТаблицы + ",";
		КонецЕсли; 
		
		поляВременнойТаблицы = поляВременнойТаблицы + "
		|	ТабличнаяЧасть." + имяКолонки;
		
		поляОсновнойТаблицы = поляОсновнойТаблицы + "
		|	ТабличнаяЧасть." + имяКолонки + " КАК " + имяКолонки;
		
		условия = условия + "
		|	И ТабличнаяЧасть." + имяКолонки + " = ЗНАЧЕНИЕ(Справочник."+Метаданные.НайтиПоТипу(ТипЗнч(табличнаяЧасть[0][имяКолонки])).Имя+".ПустаяСсылка)";
		
		порядок = порядок + "
		|	" + имяКолонки + ",";
		
		сзКолонки.Добавить(имяКолонки, колонка.Значение);
	
	КонецЦикла; 
	
	запрос = Новый Запрос;
	
	#Область ТекстЗапроса
	
	запрос.Текст =
	"ВЫБРАТЬ
	|	ТабличнаяЧасть.НомерСтроки," + поляВременнойТаблицы + "
	|ПОМЕСТИТЬ ТабличнаяЧастьОбъекта
	|ИЗ
	|	&ТабличнаяЧасть КАК ТабличнаяЧасть
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ТабличнаяЧасть.НомерСтроки КАК НомерСтроки," + поляОсновнойТаблицы + "
	|ИЗ
	|	ТабличнаяЧастьОбъекта КАК ТабличнаяЧасть
	|ГДЕ
	|   ИСТИНА " + условия + "
	|
	|УПОРЯДОЧИТЬ ПО
	|" + порядок + "
	|	НомерСтроки";
	
	#КонецОбласти
	
	запрос.УстановитьПараметр("ТабличнаяЧасть", табличнаяЧасть);
	
	результат = запрос.Выполнить();
	выборка = результат.Выбрать();
	
	Если Не результат.Пустой() Тогда
		отказ = Истина;
	КонецЕсли; 
	
	ВывестиСообщенияОПустыхСтрокахТабличнойЧасти(выборка, 0, имяТабличнойЧасти, Метаданные.НайтиПоТипу(ТипЗнч(табличнаяЧасть)).Представление(), сзКолонки, объект);

КонецПроцедуры // ПроверитьПустыеСтрокиТабличнойЧасти()

// Выводит пользователю сообщение о дублях строк в табличной части объекта. Вспомогательная процедура
// для процедуры ПроверитьДублиСтрокТабличнойЧасти().
//
// Параметры
//  Выборка  - ВыборкаИзРезультатаЗапроса - Выборка из результата запроса по табличной части, полученная
//                 в процедуре ПроверитьДублиСтрокТабличнойЧасти().
//  УровеньВыбрки  - Число - Уровень выборки, обрабатываемый на текущем уровне рекурсивного вызова
//                 процедуры.
//  ИмяТабличнойЧасти  - Строка - Имя табличной части объекта, в которой производится проверка.
//  ПредставлениеТабличнойЧасти  - Строка - Строковое представление табличной части объекта.
//  сзКолонки  - СписокЗначений - Список колонок, по которым производится поиск дублей строк. В качестве
//                 значения списка указываются имена колонок табличной части, а в представлениях
//                 элементов - представления колонок.
//  Объект  - Произвольный - Любой объект, который может иметь табличную часть.
//
Процедура ВывестиСообщенияОДубляхСтрокТабличнойЧасти(Выборка, Знач УровеньВыбрки, ИмяТабличнойЧасти, ПредставлениеТабличнойЧасти, сзКолонки, Объект)
	
	Если УровеньВыбрки = сзКолонки.Количество() Тогда
		
		// Формируем параметры описания дублирования строк.
		соПараметрыПредставленияОтбора = Новый Соответствие;
		Для каждого Колонка Из сзКолонки Цикл
			соПараметрыПредставленияОтбора.Вставить(Колонка.Представление, Выборка[Колонка.Значение]);
		КонецЦикла; 
		
		// Формируем список номеров строк.
		СписокСтрок = "";
	
		Пока Выборка.Следующий() Цикл
			
			// Если в списке уже есть номера строк, добавим запятую.
			Если Не ПустаяСтрока(СписокСтрок) Тогда
				СписокСтрок = СписокСтрок + ", ";
			КонецЕсли;
			
			СписокСтрок = СписокСтрок + Выборка.НомерСтроки;
			
		КонецЦикла; 
		
		ТекстСообщения = "Обнаружены дубли строк по параметрам: [ПредставлениеПараметровОтбора].
		|Дублирующиеся строки списка ""[ПредставлениеТабличнойЧасти]"": [СписокСтрок].";
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "[ПредставлениеПараметровОтбора]", ИнтерфейсКлиентСервер.СформироватьПредставлениеПараметровОтбора(соПараметрыПредставленияОтбора));
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "[ПредставлениеТабличнойЧасти]", ПредставлениеТабличнойЧасти);
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "[СписокСтрок]", СписокСтрок);
		
		ПроверкаДанныхКлиентСервер.СообщитьОбОшибке(Истина, ТекстСообщения, Объект, ИмяТабличнойЧасти);
	
	Иначе
	
		Пока Выборка.СледующийПоЗначениюПоля(сзКолонки[УровеньВыбрки].Значение) Цикл
			ВывестиСообщенияОДубляхСтрокТабличнойЧасти(Выборка, УровеньВыбрки + 1, ИмяТабличнойЧасти, ПредставлениеТабличнойЧасти, сзКолонки, Объект);
		КонецЦикла;	
	
	КонецЕсли; 

КонецПроцедуры // ВывестиСообщенияОДубляхСтрокТабличнойЧасти()

Процедура ВывестиСообщенияОПустыхСтрокахТабличнойЧасти(выборка, Знач уровеньВыбрки, имяТабличнойЧасти, представлениеТабличнойЧасти, сзКолонки, объект)
	
	Если уровеньВыбрки = сзКолонки.Количество() Тогда
		
		// Формируем параметры описания дублирования строк.
		соПараметрыПредставленияОтбора = Новый Соответствие;
		Для каждого колонка Из сзКолонки Цикл
			соПараметрыПредставленияОтбора.Вставить(Колонка.Представление, выборка[колонка.Значение]);
		КонецЦикла; 
		
		// Формируем список номеров строк.
		списокСтрок = "";
	
		Пока выборка.Следующий() Цикл
			
			// Если в списке уже есть номера строк, добавим запятую.
			Если Не ПустаяСтрока(списокСтрок) Тогда
				списокСтрок = списокСтрок + ", ";
			КонецЕсли;
			
			списокСтрок = списокСтрок + выборка.НомерСтроки;
			
		КонецЦикла; 
		
		текстСообщения = "Обнаружены пустые значения по параметрам: [ПредставлениеПараметровОтбора].
		|Строки списка ""[ПредставлениеТабличнойЧасти]"": [СписокСтрок].";
		
		текстСообщения = СтрЗаменить(текстСообщения, "[ПредставлениеПараметровОтбора]", ИнтерфейсКлиентСервер.СформироватьПредставлениеПараметровОтбора(соПараметрыПредставленияОтбора));
		текстСообщения = СтрЗаменить(текстСообщения, "[ПредставлениеТабличнойЧасти]", представлениеТабличнойЧасти);
		текстСообщения = СтрЗаменить(текстСообщения, "[СписокСтрок]", списокСтрок);
		
		ПроверкаДанныхКлиентСервер.СообщитьОбОшибке(Истина, текстСообщения, объект, имяТабличнойЧасти);
	
	Иначе
	
		Пока выборка.СледующийПоЗначениюПоля(сзКолонки[уровеньВыбрки].Значение) Цикл
			ВывестиСообщенияОПустыхСтрокахТабличнойЧасти(выборка, уровеньВыбрки + 1, имяТабличнойЧасти, представлениеТабличнойЧасти, сзКолонки, объект);
		КонецЦикла;	
	
	КонецЕсли; 

КонецПроцедуры // ВывестиСообщенияОДубляхСтрокТабличнойЧасти()

#КонецОбласти

#Область ДополнительныеПроцедурыИФункции

// Возвращает перечислимую коллекцию строк документа. Если в качестве параметра передана
// табличная часть, она будет возвращена без изменений. Если передать массив идентификаторов
// строк из таблицы формы, будет возвращена коллекция данных соответствующих строк.
//
// Параметры:
//  данные  - Табличная часть, Массив - Исходная коллекция строк: табличная часть или массив
//                 идентификаторов строк таблицы формы (тип Число).
//  объект  - ДанныеФормыСтруктура - Объект формы, в которой расположена обрабатываемая
//                 таблица. Имеет смысл указывать только если параметр "данные" является
//                 массивом идентификаторов строк.
//
// Возвращаемое значение:
//   Табличная часть, Массив   - Если в качестве данных был передан массив идентификаторов строк,
//                 будет возвращён массив значений типа ДанныеФормыЭлементКоллекции. Если была
//                 указана табличная часть, она эе и будет возвращена.
//
Функция ПолучитьКоллекциюОбрабатываемыхСтрок(данные, дополнительныеСвойства = Неопределено) Экспорт

	Если ТипЗнч(дополнительныеСвойства) = Тип("Структура") Тогда
		имяТабличнойЧасти = дополнительныеСвойства.ИмяТабличнойЧасти;
		объект = дополнительныеСвойства.Объект;
	Иначе
		имяТабличнойЧасти = "Запасы";
		объект = дополнительныеСвойства;
	КонецЕсли;
	
	Если ТипЗнч(данные) = Тип("Массив") Тогда
		
		// Это массив идентификаторов строк.
		коллекцияСтрок = ОбработкаТабличныхЧастейКлиентСервер.ПолучитьСтрокиПоИдентификаторам(объект[имяТабличнойЧасти], данные);
		
	Иначе
		
		// Это табличная часть.
		коллекцияСтрок = данные;
	
	КонецЕсли; 
	
	Возврат коллекцияСтрок;

КонецФункции // ПолучитьКоллекциюОбрабатываемыхСтрок()

#КонецОбласти

Функция ПолучитьДанныеНоменклатураПриИзменении(СтруктураДанные, Знач ДокументОбъект, ИмяТабличнойЧасти = "Запасы") Экспорт
	
	
	//СтруктураПараметров = Новый Структура("Номенклатура, ТипЦен, Подразделение, ДатаСреза, Контрагент", СтруктураДанные.Номенклатура, СтруктураДанные.ТипЦен, СтруктураДанные.Подразделение, СтруктураДанные.ДатаСреза, СтруктураДанные.Контрагент);
	
	СтруктураДанные.Вставить("ЕдиницаИзмерения", 	СтруктураДанные.Номенклатура.ЕдиницаИзмерения);
	
	// если  Склад<>СкладВозвратов И Склад<>Номенклатура.Склад... то новый склад
	СтруктураДанные.Вставить("СтруктурнаяЕдиница", 	СтруктураДанные.Номенклатура.Родитель.Склад);
	
	// ДатаСреза
	Если НЕ СтруктураДанные.Свойство("ДатаСреза") Тогда
		СтруктураДанные.Вставить("ДатаСреза", ДокументОбъект.Дата);
	КонецЕсли;
	
	// Подразделение
	Если НЕ СтруктураДанные.Свойство("Подразделение") Тогда
		СтруктураДанные.Вставить("Подразделение", ДокументОбъект.Подразделение);
	КонецЕсли;
	
	// Получим цену
	Если ОбщегоНазначенияСервер.ЕстьРеквизитТабЧастиДокумента("Цена", ДокументОбъект.Ссылка.Метаданные(), ИмяТабличнойЧасти) Тогда
		
		// ТипЦен
		Если НЕ СтруктураДанные.Свойство("ТипЦен") Тогда
			
			Если ДокументОбъект.Свойство("ТипЦен") Тогда
				
				СтруктураДанные.Вставить("ТипЦен", ДокументОбъект.ТипЦен);
				
			ИначеЕсли ДокументОбъект.Свойство("ДокументОснование") Тогда
				
				СтруктураДанные.Вставить("ТипЦен", ДокументОбъект.ДокументОснование.ТипЦен);
				
			КонецЕсли;
			
		КонецЕсли;
		
		// Валюта
		
		Если СтруктураДанные.Свойство("ТипЦен") И СтруктураДанные.Свойство("Подразделение") Тогда
			СтруктураДанные.Вставить("Цена", ЦенообразованиеСервер.ВернутьЦенуНоменклатуры(СтруктураДанные));
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не структураДанные.Свойство("Контрагент") Тогда
			структураДанные.Вставить("Контрагент", ДокументОбъект.Контрагент);
	КонецЕсли;
		
		
	// Получим скидку на вес - "ПроцентСкидкиНаВес"
	Если ОбщегоНазначенияСервер.ЕстьРеквизитТабЧастиДокумента("ПроцентСкидкиНаВес", ДокументОбъект.Ссылка.Метаданные(), ИмяТабличнойЧасти)  Тогда
		
		
		Если СтруктураДанные.Номенклатура.ЕдиницаИзмерения = Справочники.ЕдиницыИзмерения.Шт Тогда
			структураДанные.Вставить("ПроцентСкидкиНаВес", 0);
		Иначе
			структураДанные.Вставить("ПроцентСкидкиНаВес", ЦенообразованиеСервер.ВернутьСкидкуНаВес(структураДанные));
		КонецЕсли;
		
	КонецЕсли;
	
	// Получим автоматические скидки - "ПроцентСкидки"
	Если ОбщегоНазначенияСервер.ЕстьРеквизитТабЧастиДокумента("ПроцентСкидкиНаВес", ДокументОбъект.Ссылка.Метаданные(), ИмяТабличнойЧасти) Тогда
		
		соответствиеСкидок = ЦенообразованиеСервер.ВернутьАвтоматическиеСкидки(структураДанные);
		
		// проверим запрет скидки))
		Если ЦенообразованиеСервер.ПроверитьЗапретСкидкиПоНоменклатуре(структураДанные) Тогда
			СтруктураДанные.Вставить("ПроцентСкидки", 0);
		Иначе
			Если ЦенообразованиеСервер.ИспользоватьЦеновыеГруппы(структураДанные.Подразделение) Тогда
				структураДанные.Вставить("ПроцентСкидки", соответствиеСкидок.Получить(СокрЛП(структураДанные.Номенклатура.Родитель.Код) +" / "+СокрЛП(структураДанные.Номенклатура.ЦеноваяГруппа.Код)) );
			Иначе
				структураДанные.Вставить("ПроцентСкидки", соответствиеСкидок.Получить(СокрЛП(структураДанные.Номенклатура.Родитель.Код) +" / "+СокрЛП(справочники.ЦеновыеГруппы.ПустаяСсылка().Код)) );
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СтруктураДанные;
	
КонецФункции // ПолучитьДанныеНоменклатураПриИзменении()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБРАБОТКИ ОШИБОК ОКРУГЛЕНИЯ НДС

// Процедура корректирует построчные ошибки округления НДС так, 
// чтобы итоговый НДС по ставке совпадал с расчитанным НДС по базе
//
// Параметры:
//  ТабличнаяЧасть       - табличная часть, для которой следует пересчитать НДС
//  ДокументОбъект       - объект редактируемого документа.
//
Процедура ПересчитатьНДСсУчетомПогрешностиОкругления(ТабличнаяЧасть, ДокументОбъект, ПогрешностиОкругления, ПредставлениеТабличнойЧасти = "", ИмяРеквизитаСумма    = "Сумма", ИмяРеквизитаСуммаНДС = "СуммаНДС", ДополнениеКТексту ="") Экспорт
	
	Для Каждого СтрокаЗапасы Из ДокументОбъект.Запасы Цикл
		
		СтрокаЗапасы.Сумма = Окр(СтрокаЗапасы.Сумма, 2, РежимОкругления.Окр15как20);
		
		СтрокаЗапасы.СуммаНДС = РассчитатьСуммуНДСсУчетомПогрешности(СтрокаЗапасы.Сумма,
			1,
			1,
			"НДС20",
			ПогрешностиОкругления);
	КонецЦикла;
	
КонецПроцедуры

//	----------------------------------------------------------------------------
//	РассчитатьСуммуНДСсУчетомПогрешности()
//
Функция РассчитатьСуммуНДСсУчетомПогрешности(Сумма, УчитыватьНДС, СуммаВключаетНДС, ПеречислениеСтавкаНДС,
	               СоответствиеПогрешностей = "")

	СтавкаНДС = 20;
				   
	Если УчитыватьНДС=1 Тогда 
		Если СуммаВключаетНДС=1 Тогда
			СуммаНДС = ОкруглитьСУчетомПогрешности(Сумма * СтавкаНДС / (100 + СтавкаНДС), 2, , СоответствиеПогрешностей, ПеречислениеСтавкаНДС);
		Иначе
			СуммаНДС = ОкруглитьСУчетомПогрешности(Сумма * СтавкаНДС / 100              , 2, , СоответствиеПогрешностей, ПеречислениеСтавкаНДС);
		КонецЕсли;
	Иначе
		СуммаНДС = 0;
	КонецЕсли;

	Возврат СуммаНДС;

КонецФункции // РассчитатьСуммуНДССУчетомПогрешности()

//	----------------------------------------------------------------------------
//	ОкруглитьСУчетомПогрешности()
//
Функция ОкруглитьСУчетомПогрешности(_Число, Точность, Погрешность = 0, 
	               СоответствиеПогрешностей = "", Ключ = "") 

	Если НЕ (СоответствиеПогрешностей = "")  И НЕ(Ключ="") Тогда
	
		// считываем погрешность округления, накопленную ранее при расчетах
		Погрешность = СоответствиеПогрешностей.Получить(Ключ);
		// погрешности округления еще нет -- первая сумма
		//Если ПустоеЗначение(Погрешность) = 1 Тогда
		Если (Погрешность = Неопределено) Тогда
			Погрешность = 0;
		КонецЕсли;
		// округлим с учетом погрешности
		Округленное = ОкруглитьСУчетомПогрешности(_Число, Точность, Погрешность);
		// сохраним погрешность округления
		СоответствиеПогрешностей.Вставить(Ключ, Погрешность);
	
	Иначе
		
		Если _Число = 0 Тогда
			Возврат 0;
		КонецЕсли; 
	
		// выравнивание разрядности
		_Число = Окр(_Число, 27, ?(_Число<0, 0, 1));
		
		// сумма с учетом погрешности предыдущих вычислений
		Округляемое = _Число + Погрешность;

		// для отрицательного числа меняем направление округления, чтобы избежать ошибки Окр(-0.5) = -1
		Округленное	= Окр(Округляемое, Точность, ?(Округляемое<0,0, 1));
		
		// рассчитаем новую погрешность округления
		Погрешность	= Округляемое - Округленное;
		
	КонецЕсли;
	
	Возврат Округленное;

КонецФункции // ОкруглитьСУчетомПогрешности()